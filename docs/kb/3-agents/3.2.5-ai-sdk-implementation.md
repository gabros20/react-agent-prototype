# 3.2.5 - Implementation with AI SDK v6

## TL;DR
AI SDK 6 provides native ReAct implementation through `ToolLoopAgent`, handling reasoning-action-observation cycles, tool orchestration, and streaming without manual loop management. This is the production-grade implementation of concepts from 3.2.2-3.2.4.

**Prerequisites**: [3.2.2-3.2.4 ReAct Phases]
**Versions**: AI SDK 6.0+
**Framework Integration**: Next.js + NestJS

---

## AI SDK 6 Overview

### What Changed

| Aspect | AI SDK 5 | AI SDK 6 |
|--------|----------|---------|
| **Tool system** | Manual tool format | Native `tool()` function |
| **Validation** | JSON Schema | Zod schemas |
| **Loop management** | Manual ReAct loop | `ToolLoopAgent` |
| **Type safety** | Partial | Full TypeScript |
| **Streaming** | Limited | Native streaming |
| **Context passing** | Global state | `experimental_context` |

### Core Pattern

```typescript
import { tool } from 'ai';
import { z } from 'zod';

// Define a tool
const getTodo = tool({
  description: 'Get a todo by ID',
  inputSchema: z.object({
    id: z.string().describe('Todo ID')
  }),
  execute: async (input) => {
    return await db.getTodo(input.id);
  }
});

// Use in agent
const agent = new ToolLoopAgent({
  tools: [getTodo, ...],
  llm: claude,
  systemPrompt: 'You are a helpful assistant'
});

const result = await agent.execute('Get todo #123');
```

---

## Your CMS Implementation

### Tool Definition (Your Pattern)

From `server/tools/all-tools.ts`:

```typescript
import { tool } from 'ai';
import { z } from 'zod';
import type { AgentContext } from './types';

export const cmsGetPage = tool({
  description: 'Get a page by slug or ID, optionally with full section content',
  inputSchema: z.object({
    slug: z.string().optional().describe('Page slug (e.g., "home")'),
    id: z.string().optional().describe('Page ID (UUID)'),
    includeContent: z.boolean()
      .optional()
      .default(false)
      .describe('Include full section content for each section')
  }),

  execute: async (input, { experimental_context }) => {
    const ctx = experimental_context as AgentContext;

    // Validation
    if (!input.slug && !input.id) {
      throw new Error('Either slug or id is required');
    }

    // Token optimization: lightweight first
    const page = await ctx.cms.getPage({
      slug: input.slug,
      id: input.id,
      includeContent: input.includeContent
    });

    if (!page) {
      throw new Error(`Page not found: ${input.slug || input.id}`);
    }

    return page;
  }
});
```

**Strengths** ✅:
- Clear description
- Type-safe Zod schema
- Dependency injection via `experimental_context`
- Sensible defaults (`includeContent: false`)
- Token-aware design

---

## ToolLoopAgent Architecture

### How It Works

```
User Request
     ↓
[Generate Thought + Select Tool]
     ↓
[Validate Input against Schema]
     ↓
[Execute Tool]
     ↓
[Parse Result into Observation]
     ↓
[Update Working Memory]
     ↓
Complete?
  ├─ YES → Return final answer
  └─ NO → Loop (new thought)
```

### Implementation in Your System

```typescript
// server/agent/orchestrator.ts

import { ToolLoopAgent } from 'ai';
import { cmsGetPage, cmsCreatePage, ... } from './tools/all-tools';

export class CMSOrchestrator {
  private agent: ToolLoopAgent;

  constructor(private llm: LanguageModel, private cms: CMS) {
    this.agent = new ToolLoopAgent({
      model: llm,
      tools: this.loadTools(),
      systemPrompt: this.loadPrompt(),
      maxIterations: 10,
      workingMemory: new WorkingMemoryStore()
    });
  }

  private loadTools() {
    return [
      cmsGetPage,
      cmsCreatePage,
      cmsUpdatePage,
      cmsDeletePage,
      cms_findResource,
      cms_addSectionToPage,
      // ... other tools
    ];
  }

  private loadPrompt() {
    return fs.readFileSync('./prompts/react.xml', 'utf-8');
  }

  async handleUserRequest(message: string, sessionId: string) {
    try {
      // Agent handles entire ReAct loop
      const response = await this.agent.execute(message, {
        sessionId,
        experimental_context: {
          cms: this.cms,
          user: getUserContext(sessionId),
          workingMemory: this.agent.workingMemory
        }
      });

      return response;
    } catch (error) {
      return `Error: ${error.message}`;
    }
  }
}
```

---

## Tool Loop Details

### Phase 1: Thought Generation

```typescript
// AI SDK generates thought via LLM
const thought = await llm.generate(
  `${systemPrompt}

User: ${userRequest}

Working Memory:
${workingMemory.toString()}

Thought: `,
  { temperature: 0 }
);

// Output example:
// "I need to find the about page first to add sections to it."
```

### Phase 2: Action Parsing

```typescript
// Extract action from thought
const actionMatch = thought.match(
  /Action:\s*(\w+)\s*\n\s*Action Input:\s*({.*})/s
);

if (actionMatch) {
  const [, toolName, inputJson] = actionMatch;
  const toolInput = JSON.parse(inputJson);

  return { toolName, toolInput };
} else {
  throw new Error(`Failed to parse action from: ${thought}`);
}
```

### Phase 3: Tool Validation & Execution

```typescript
// Validate against Zod schema
const tool = tools.find(t => t.name === toolName);
const validated = tool.inputSchema.parse(toolInput);

// Execute with context
const result = await tool.execute(validated, {
  experimental_context: {
    cms: this.cms,
    sessionId: this.sessionId
  }
});

return { success: true, data: result };
```

### Phase 4: Observation Integration

```typescript
// Update working memory with result
const observation = `✅ ${result.status || 'Success'}: ${JSON.stringify(result)}`;

// Extract entities for memory
const entities = extractEntities(toolName, result);
workingMemory.addMultiple(entities);

// Store step for logging
steps.push({
  thought,
  action: { toolName, toolInput },
  observation,
  timestamp: Date.now()
});

return observation;
```

### Phase 5: Loop Control

```typescript
// Decide: continue or complete?
const isComplete = thought.includes('FINAL_ANSWER:') ||
                  thought.includes('task complete') ||
                  steps.length >= maxIterations;

if (isComplete) {
  // Generate final answer
  const finalAnswer = await llm.generate(
    `${systemPrompt}\n\nBased on all the work above:\n${summaryOfSteps}\n\nFinal Answer: `
  );
  return finalAnswer;
} else {
  // Loop again
  return await generateNextThought(thought, observation);
}
```

---

## Streaming Integration

AI SDK 6 supports streaming responses:

```typescript
// Stream thoughts and actions in real-time
const stream = await agent.executeStream(userRequest);

// Handle streaming events
for await (const event of stream) {
  switch (event.type) {
    case 'thought':
      console.log('Agent thinking:', event.content);
      // Send to UI
      break;
    case 'action':
      console.log('Agent calling:', event.toolName);
      // Show tool icon in UI
      break;
    case 'observation':
      console.log('Agent observed:', event.result);
      // Update with result
      break;
    case 'complete':
      console.log('Final answer:', event.answer);
      // Done
      break;
  }
}
```

---

## Working Memory Management

### Architecture

```typescript
interface WorkingMemoryStore {
  add(entity: Entity): void;
  addMultiple(entities: Entity[]): void;
  getRecent(type: string, limit: number): Entity[];
  clear(): void;
  toContextString(): string;
}

interface Entity {
  type: 'page' | 'section' | 'definition' | string;
  id: string;
  name?: string;
  metadata?: any;
  timestamp: number;
}
```

### Implementation

```typescript
class WorkingMemoryStore {
  private memory: Entity[] = [];
  private maxSize = 100;

  add(entity: Entity) {
    // Add to front (most recent first)
    this.memory.unshift({ ...entity, timestamp: Date.now() });

    // Trim if too large
    if (this.memory.length > this.maxSize) {
      this.memory = this.memory.slice(0, this.maxSize);
    }
  }

  getRecent(type: string, limit: number = 5): Entity[] {
    return this.memory
      .filter(e => e.type === type)
      .slice(0, limit);
  }

  toContextString(): string {
    const grouped = this.groupByType();
    let context = 'WORKING MEMORY:\n\n';

    for (const [type, entities] of Object.entries(grouped)) {
      context += `${type}s (most recent):\n`;
      entities.slice(0, 5).forEach(e => {
        context += `  - ${e.id}: ${e.name || ''}\n`;
      });
      context += '\n';
    }

    return context;
  }

  private groupByType() {
    const grouped: Record<string, Entity[]> = {};
    for (const entity of this.memory) {
      if (!grouped[entity.type]) {
        grouped[entity.type] = [];
      }
      grouped[entity.type].push(entity);
    }
    return grouped;
  }
}
```

---

## Error Handling in Tool Loop

### Built-in Error Recovery

```typescript
try {
  const result = await tool.execute(input, context);
  return result;
} catch (error) {
  // Classify error
  const errorType = classifyError(error);

  // Agent can attempt recovery
  switch (errorType) {
    case 'NOT_FOUND':
      // Generate recovery thought
      const recoveryThought = `
        Tool returned 404. Resource not found with '${input.query}'.
        Will try alternative approach using fuzzy search.
      `;
      // Loop continues with recovery thought
      break;

    case 'VALIDATION_ERROR':
      // Schema validation failed - inform user
      return `Invalid input: ${error.message}`;

    case 'PERMISSION_ERROR':
      // User doesn't have permission
      return `You don't have permission for this action.`;

    default:
      return `Unexpected error: ${error.message}`;
  }
}
```

---

## Integration with Next.js Route Handlers

```typescript
// app/api/agent/route.ts

import { CMSOrchestrator } from '@/server/agent/orchestrator';
import { anthropic } from '@ai-sdk/anthropic';

const orchestrator = new CMSOrchestrator(
  anthropic('claude-3-5-sonnet-20241022'),
  cms
);

export async function POST(request: Request) {
  const { message, sessionId } = await request.json();

  try {
    const response = await orchestrator.handleUserRequest(
      message,
      sessionId
    );

    return Response.json({ response, success: true });
  } catch (error) {
    return Response.json(
      { error: error.message, success: false },
      { status: 500 }
    );
  }
}

// Streaming variant
export async function streamPost(request: Request) {
  const { message, sessionId } = await request.json();

  const stream = await orchestrator.streamUserRequest(
    message,
    sessionId
  );

  return new Response(stream, {
    headers: { 'Content-Type': 'text/event-stream' }
  });
}
```

---

## Production Considerations

### Max Iterations

```typescript
// Prevent infinite loops
const maxIterations = 10;

if (steps.length >= maxIterations) {
  return `Task incomplete after ${maxIterations} steps.
          Last state: ${lastObservation}`;
}
```

### Timeout Protection

```typescript
const timeout = 30000; // 30 seconds

Promise.race([
  agent.execute(userRequest),
  new Promise((_, reject) =>
    setTimeout(() => reject(new Error('Timeout')), timeout)
  )
]);
```

### Logging & Monitoring

```typescript
interface AgentMetrics {
  requestId: string;
  steps: number;
  totalTokens: number;
  executionTime: number;
  success: boolean;
  errors: string[];
}

// Log for analysis
await metricsStore.record({
  requestId: generateId(),
  steps: steps.length,
  totalTokens: steps.reduce((sum, s) => sum + s.tokens, 0),
  executionTime: Date.now() - startTime,
  success: result.success,
  errors: result.errors || []
});
```

---

## Best Practices

### ✅ Do

- Use structured prompts with clear sections
- Provide rich tool descriptions
- Implement proper error handling
- Log all steps for debugging
- Use working memory for reference resolution
- Set reasonable iteration limits
- Validate tool schemas with Zod

### ❌ Don't

- Create tools without descriptions
- Use generic tool names
- Ignore schema validation errors
- Let loops run indefinitely
- Mix tool concerns (one job per tool)
- Use mutable global state
- Assume tools always succeed

---

## References

1. AI SDK 6 Documentation (2025)
2. Vercel AI Documentation
3. Your implementation: `server/agent/orchestrator.ts`
4. Prompt file: `server/prompts/react.xml`

---

**Status**: Complete
**Word Count**: ~2,000
**Last Updated**: November 21, 2025
