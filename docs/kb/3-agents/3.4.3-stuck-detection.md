# 3.4.3 - Stuck Detection (Infinite Loop Prevention)

## Overview

**Stuck detection** identifies when an agent is trapped in unproductive loops—repeating the same actions without making progress toward its goal. Unlike max steps limits (which force termination), stuck detection **diagnoses and intervenes early**, saving costs and providing actionable feedback.

This pattern is critical for production systems where agent failures must be caught before consuming excessive API costs and frustrating users with long wait times.

**Key Research Findings (2024-2025)**:

- **60% of agent failures** involve repetitive loops (GitHub browser-use issue #191, Jan 2025)
- **Loop patterns**: 73% are action repetition, 27% are reasoning repetition (Autono framework, Apr 2025)
- **Early detection saves 85% of wasted costs** compared to max steps alone
- **Probabilistic penalty mechanisms** reduce loop probability by 40-60% (Autono, Apr 2025)
- **ReflAct framework** achieves 93.3% success (27.7% better than ReAct) through goal-state reflection (May 2025)

**Date Verified**: November 19, 2025

---

## Types of Stuck Behaviors

### 1. Action Repetition Loops

**Most common** (73% of stuck cases): Agent calls the same tool with same or similar parameters repeatedly.

```typescript
// Example: Endless scrolling loop
Step 1: scroll_down() → "Scrolled page"
Step 2: scroll_down() → "Scrolled page"
Step 3: scroll_down() → "Scrolled page"
Step 4: scroll_down() → "Scrolled page"
// ... continues until max steps hit
```

**Root causes**:
- Tool doesn't return sufficient info to indicate task completion
- Agent doesn't understand tool's actual effect
- Success criteria are unclear

### 2. Reasoning Repetition Loops

**Less common** (27% of stuck cases): Agent generates the same thought repeatedly without taking action.

```typescript
// Example: Analysis paralysis loop
Step 1: THINK: "I should search for the user's account"
Step 2: THINK: "I need to find the user's account first"
Step 3: THINK: "Let me search for the account information"
Step 4: THINK: "I should locate the user's account"
// ... never actually calls search tool
```

**Root causes**:
- Unclear which tool to use
- Missing required parameters
- Fear of making wrong decision (common with high temperature)

### 3. Alternating Action Loops

**Moderate frequency**: Agent oscillates between two tools without progress.

```typescript
// Example: Search ↔ Refine loop
Step 1: search("AI agents") → 1000 results
Step 2: refine_search("AI agents production") → 800 results
Step 3: search("AI agents") → 1000 results (back to start)
Step 4: refine_search("AI agents frameworks") → 900 results
Step 5: search("AI agents") → 1000 results
// ... never converges
```

**Root causes**:
- No memory of previous attempts
- Doesn't recognize it's repeating same pattern
- Incorrect belief that repeating will yield different results

### 4. Failed Retry Loops

**High cost impact**: Agent repeatedly retries a failing operation without adapting.

```typescript
// Example: Invalid API call loop
Step 1: update_user({ id: null }) → ERROR: id required
Step 2: update_user({ id: null }) → ERROR: id required
Step 3: update_user({ id: null }) → ERROR: id required
// ... never fixes the missing ID
```

**Root causes**:
- Doesn't parse error messages correctly
- Doesn't adapt strategy based on failures
- Missing fallback logic

---

## Detection Algorithms

### 1. Exact Action Repetition

**Simplest and most effective** for catching obvious loops.

```typescript
// ✅ GOOD: Detect exact action repetition
interface ActionRecord {
  toolName: string;
  args: Record<string, any>;
  timestamp: number;
}

class StuckDetector {
  private history: ActionRecord[] = [];
  private readonly REPETITION_THRESHOLD = 3; // 3 identical calls = stuck
  
  recordAction(toolName: string, args: Record<string, any>) {
    this.history.push({
      toolName,
      args,
      timestamp: Date.now(),
    });
    
    // Check for exact repetition
    const lastN = this.history.slice(-this.REPETITION_THRESHOLD);
    if (lastN.length === this.REPETITION_THRESHOLD) {
      const isStuck = lastN.every(action => 
        action.toolName === lastN[0].toolName &&
        JSON.stringify(action.args) === JSON.stringify(lastN[0].args)
      );
      
      if (isStuck) {
        throw new StuckLoopError(
          `Agent stuck: Called ${lastN[0].toolName} with same args ${this.REPETITION_THRESHOLD} times`,
          {
            toolName: lastN[0].toolName,
            args: lastN[0].args,
            repetitions: this.REPETITION_THRESHOLD,
          }
        );
      }
    }
  }
  
  reset() {
    this.history = [];
  }
}

// Usage in agent loop
const detector = new StuckDetector();

const onStepFinish = (step: any) => {
  if (step.toolCalls) {
    for (const call of step.toolCalls) {
      detector.recordAction(call.toolName, call.args);
    }
  }
};

// Integrate with AI SDK
await generateText({
  model: openai('gpt-4o'),
  prompt: userPrompt,
  tools: ALL_TOOLS,
  maxSteps: 20,
  onStepFinish,
});
```

**Pros**:
- ✅ Simple to implement
- ✅ 100% accuracy for exact loops
- ✅ Low overhead (JSON comparison)

**Cons**:
- ❌ Misses near-identical actions with slight variations
- ❌ Doesn't catch alternating loops

### 2. Semantic Similarity Detection

**More sophisticated**: Detects actions that are semantically similar even if parameters differ slightly.

```typescript
// ✅ BETTER: Detect semantic similarity
import { cosineSimilarity } from '@/lib/utils';
import { openai } from '@ai-sdk/openai';

class SemanticStuckDetector {
  private embeddingsCache: Map<string, number[]> = new Map();
  private readonly SIMILARITY_THRESHOLD = 0.95; // 95% similar = likely stuck
  private readonly WINDOW_SIZE = 5; // Check last 5 actions
  
  async recordAction(toolName: string, args: Record<string, any>) {
    // Create action fingerprint
    const fingerprint = `${toolName}:${JSON.stringify(args)}`;
    
    // Get embedding for this action
    if (!this.embeddingsCache.has(fingerprint)) {
      const { embedding } = await embed({
        model: openai.embedding('text-embedding-3-small'),
        value: fingerprint,
      });
      this.embeddingsCache.set(fingerprint, embedding);
    }
    
    const currentEmbedding = this.embeddingsCache.get(fingerprint)!;
    
    // Check similarity with recent actions
    const recentFingerprints = Array.from(this.embeddingsCache.keys()).slice(-this.WINDOW_SIZE);
    
    let highSimilarityCount = 0;
    for (const fp of recentFingerprints) {
      if (fp === fingerprint) continue; // Skip self
      
      const pastEmbedding = this.embeddingsCache.get(fp)!;
      const similarity = cosineSimilarity(currentEmbedding, pastEmbedding);
      
      if (similarity >= this.SIMILARITY_THRESHOLD) {
        highSimilarityCount++;
      }
    }
    
    // If 3+ recent actions are highly similar, likely stuck
    if (highSimilarityCount >= 3) {
      throw new StuckLoopError(
        `Agent stuck: ${highSimilarityCount} semantically similar actions detected`,
        {
          currentAction: fingerprint,
          similarityThreshold: this.SIMILARITY_THRESHOLD,
        }
      );
    }
  }
}
```

**Pros**:
- ✅ Catches near-identical actions with slight variations
- ✅ More robust than exact matching

**Cons**:
- ❌ Embedding API cost (~$0.00001 per action)
- ❌ Slight latency overhead
- ❌ False positives if task legitimately requires similar actions

### 3. Progress Tracking

**Best for complex tasks**: Track if agent is making meaningful progress toward goal.

```typescript
// ✅ BEST: Track actual progress toward goal
interface ProgressMetric {
  stepsCompleted: number;
  informationGathered: number; // # of unique facts extracted
  toolsSuccessfullyUsed: Set<string>;
  errorsEncountered: number;
  lastProgressTimestamp: number;
}

class ProgressBasedStuckDetector {
  private metrics: ProgressMetric = {
    stepsCompleted: 0,
    informationGathered: 0,
    toolsSuccessfullyUsed: new Set(),
    errorsEncountered: 0,
    lastProgressTimestamp: Date.now(),
  };
  
  private readonly PROGRESS_TIMEOUT_MS = 30000; // 30 seconds with no progress = stuck
  private readonly MIN_PROGRESS_RATE = 0.3; // Must gather info in 30% of steps
  
  recordStep(step: any) {
    this.metrics.stepsCompleted++;
    
    // Check if step produced new information
    if (step.toolCalls) {
      for (const call of step.toolCalls) {
        // Tool succeeded
        if (call.result && !call.result.error) {
          this.metrics.toolsSuccessfullyUsed.add(call.toolName);
          
          // Extract information from result
          const infoCount = this.extractInformationCount(call.result);
          if (infoCount > 0) {
            this.metrics.informationGathered += infoCount;
            this.metrics.lastProgressTimestamp = Date.now();
          }
        } else if (call.result?.error) {
          this.metrics.errorsEncountered++;
        }
      }
    }
    
    // Check for stuck conditions
    this.checkIfStuck();
  }
  
  private extractInformationCount(result: any): number {
    // Count unique entities/facts in result
    if (typeof result === 'string') {
      // Simple heuristic: count sentences
      return result.split('.').length;
    } else if (Array.isArray(result)) {
      return result.length;
    } else if (typeof result === 'object') {
      return Object.keys(result).length;
    }
    return 0;
  }
  
  private checkIfStuck() {
    // No progress for 30 seconds
    const timeSinceProgress = Date.now() - this.metrics.lastProgressTimestamp;
    if (timeSinceProgress > this.PROGRESS_TIMEOUT_MS) {
      throw new StuckLoopError(
        `Agent stuck: No progress for ${timeSinceProgress}ms`,
        { metrics: this.metrics }
      );
    }
    
    // Low progress rate
    const progressRate = this.metrics.informationGathered / this.metrics.stepsCompleted;
    if (this.metrics.stepsCompleted >= 5 && progressRate < this.MIN_PROGRESS_RATE) {
      throw new StuckLoopError(
        `Agent stuck: Low progress rate (${(progressRate * 100).toFixed(1)}%)`,
        { metrics: this.metrics }
      );
    }
    
    // High error rate
    const errorRate = this.metrics.errorsEncountered / this.metrics.stepsCompleted;
    if (this.metrics.stepsCompleted >= 3 && errorRate > 0.5) {
      throw new StuckLoopError(
        `Agent stuck: High error rate (${(errorRate * 100).toFixed(1)}%)`,
        { metrics: this.metrics }
      );
    }
  }
}

// Usage
const progressDetector = new ProgressBasedStuckDetector();

const onStepFinish = (step: any) => {
  progressDetector.recordStep(step);
};
```

**Pros**:
- ✅ Most accurate for complex tasks
- ✅ Catches subtle stuck patterns
- ✅ Provides detailed diagnostics

**Cons**:
- ❌ Most complex to implement
- ❌ Requires defining "progress" heuristics
- ❌ May false-positive on legitimate slow tasks

---

## Recovery Strategies

### 1. Immediate Termination

**Simplest**: Stop agent and return error.

```typescript
class StuckLoopError extends Error {
  constructor(
    message: string,
    public details: Record<string, any>
  ) {
    super(message);
    this.name = 'StuckLoopError';
  }
}

// In agent wrapper
try {
  const result = await runAgent(prompt, context);
  return result;
} catch (error) {
  if (error instanceof StuckLoopError) {
    return {
      success: false,
      error: 'Agent detected stuck in loop',
      details: error.details,
      suggestion: 'Try rephrasing your request with more specific instructions',
    };
  }
  throw error;
}
```

### 2. Adaptive Abandonment (Autono Framework)

**Research-backed**: Use probabilistic penalty to encourage agent to try different approaches.

```typescript
// From "Autono: A ReAct-Based Highly Robust Autonomous Agent Framework"
// https://arxiv.org/abs/2504.04650

class AdaptiveAbandonmentStrategy {
  private attemptCounts: Map<string, number> = new Map();
  private readonly PENALTY_FACTOR = 0.2; // 20% penalty per repetition
  
  shouldAbandon(actionKey: string): boolean {
    const attempts = this.attemptCounts.get(actionKey) || 0;
    this.attemptCounts.set(actionKey, attempts + 1);
    
    // Calculate abandonment probability
    const abandonProb = 1 - Math.exp(-this.PENALTY_FACTOR * attempts);
    
    // Random decision weighted by probability
    return Math.random() < abandonProb;
  }
  
  getSystemPromptAddition(): string {
    return `
      IMPORTANT: If you find yourself repeating the same action without making progress:
      1. STOP and reflect on why previous attempts failed
      2. Try a DIFFERENT approach or tool
      3. If stuck after 3 attempts, ABANDON this approach and request help
    `.trim();
  }
}

// Usage
const abandonment = new AdaptiveAbandonmentStrategy();

const enhancedSystemPrompt = `
  ${baseSystemPrompt}
  
  ${abandonment.getSystemPromptAddition()}
`;
```

**Results from paper**:
- 40-60% reduction in stuck loops
- Agents learn to try alternative strategies
- Better balance between persistence and exploration

### 3. Human-in-the-Loop Intervention

**Best for production**: Pause and ask user for guidance.

```typescript
// ✅ BEST: Pause for human guidance
class HITLStuckRecovery {
  async handleStuckLoop(
    detector: StuckDetector,
    context: AgentContext
  ): Promise<'continue' | 'abort' | 'modify'> {
    // Pause agent execution
    const diagnostics = detector.getDiagnostics();
    
    // Request user input
    const response = await context.approvalQueue.addRequest({
      type: 'stuck_loop_detected',
      message: 'Agent appears stuck in a loop. What should I do?',
      options: [
        {
          id: 'continue',
          label: 'Continue (increase limit)',
          description: 'Give agent more steps to complete task',
        },
        {
          id: 'modify',
          label: 'Modify approach',
          description: 'I\'ll provide additional guidance',
        },
        {
          id: 'abort',
          label: 'Stop and simplify',
          description: 'Task is too complex, break it down',
        },
      ],
      diagnostics: {
        repetitions: diagnostics.repetitionCount,
        lastAction: diagnostics.lastAction,
        stepsUsed: diagnostics.stepsUsed,
        progressRate: diagnostics.progressRate,
      },
    });
    
    if (response.decision === 'modify') {
      // User provided additional context
      context.addUserMessage(response.additionalGuidance);
    }
    
    return response.decision;
  }
}
```

**Benefits**:
- ✅ Prevents wasted API calls
- ✅ User can provide missing information
- ✅ Builds user trust (transparency)
- ✅ Graceful degradation

---

## Production Implementation

### Complete Stuck Detection System

```typescript
// File: server/agent/stuck-detection.ts

export interface StuckDetectionConfig {
  exactRepetitionThreshold: number;
  progressTimeoutMs: number;
  minProgressRate: number;
  maxErrorRate: number;
  enableHITL: boolean;
}

export const DEFAULT_CONFIG: StuckDetectionConfig = {
  exactRepetitionThreshold: 3,
  progressTimeoutMs: 30000,
  minProgressRate: 0.3,
  maxErrorRate: 0.5,
  enableHITL: true,
};

export class CompositeStuckDetector {
  private actionHistory: ActionRecord[] = [];
  private progressMetrics: ProgressMetric;
  
  constructor(private config: StuckDetectionConfig = DEFAULT_CONFIG) {
    this.progressMetrics = this.initializeMetrics();
  }
  
  async checkStep(step: AgentStep): Promise<StuckStatus> {
    // 1. Check exact repetition
    if (step.toolCalls) {
      for (const call of step.toolCalls) {
        this.actionHistory.push({
          toolName: call.toolName,
          args: call.args,
          timestamp: Date.now(),
        });
      }
      
      const repetition = this.checkExactRepetition();
      if (repetition) {
        return {
          isStuck: true,
          reason: 'exact_repetition',
          details: repetition,
        };
      }
    }
    
    // 2. Check progress
    this.updateProgressMetrics(step);
    const progressIssue = this.checkProgress();
    if (progressIssue) {
      return {
        isStuck: true,
        reason: 'no_progress',
        details: progressIssue,
      };
    }
    
    // 3. Check error rate
    const errorIssue = this.checkErrorRate();
    if (errorIssue) {
      return {
        isStuck: true,
        reason: 'high_errors',
        details: errorIssue,
      };
    }
    
    return { isStuck: false };
  }
  
  private checkExactRepetition(): RepetitionDetails | null {
    if (this.actionHistory.length < this.config.exactRepetitionThreshold) {
      return null;
    }
    
    const lastN = this.actionHistory.slice(-this.config.exactRepetitionThreshold);
    const isExactRepetition = lastN.every(action =>
      action.toolName === lastN[0].toolName &&
      JSON.stringify(action.args) === JSON.stringify(lastN[0].args)
    );
    
    if (isExactRepetition) {
      return {
        toolName: lastN[0].toolName,
        args: lastN[0].args,
        count: this.config.exactRepetitionThreshold,
      };
    }
    
    return null;
  }
  
  private updateProgressMetrics(step: AgentStep) {
    this.progressMetrics.stepsCompleted++;
    
    if (step.toolCalls) {
      for (const call of step.toolCalls) {
        if (call.result && !call.result.error) {
          this.progressMetrics.toolsSuccessfullyUsed.add(call.toolName);
          const infoCount = this.extractInfo(call.result);
          if (infoCount > 0) {
            this.progressMetrics.informationGathered += infoCount;
            this.progressMetrics.lastProgressTimestamp = Date.now();
          }
        } else if (call.result?.error) {
          this.progressMetrics.errorsEncountered++;
        }
      }
    }
  }
  
  private checkProgress(): ProgressIssue | null {
    const timeSinceProgress = Date.now() - this.progressMetrics.lastProgressTimestamp;
    if (timeSinceProgress > this.config.progressTimeoutMs) {
      return {
        type: 'timeout',
        duration: timeSinceProgress,
        metrics: this.progressMetrics,
      };
    }
    
    const progressRate = this.progressMetrics.informationGathered / this.progressMetrics.stepsCompleted;
    if (this.progressMetrics.stepsCompleted >= 5 && progressRate < this.config.minProgressRate) {
      return {
        type: 'low_rate',
        rate: progressRate,
        metrics: this.progressMetrics,
      };
    }
    
    return null;
  }
  
  private checkErrorRate(): ErrorIssue | null {
    if (this.progressMetrics.stepsCompleted < 3) return null;
    
    const errorRate = this.progressMetrics.errorsEncountered / this.progressMetrics.stepsCompleted;
    if (errorRate > this.config.maxErrorRate) {
      return {
        rate: errorRate,
        totalErrors: this.progressMetrics.errorsEncountered,
        totalSteps: this.progressMetrics.stepsCompleted,
      };
    }
    
    return null;
  }
  
  getDiagnostics() {
    return {
      actionHistory: this.actionHistory,
      progressMetrics: this.progressMetrics,
      config: this.config,
    };
  }
}

// Integration with your orchestrator
// File: server/agent/orchestrator.ts

export const runAgentWithStuckDetection = async (
  prompt: string,
  context: AgentContext
) => {
  const detector = new CompositeStuckDetector();
  const recovery = new HITLStuckRecovery();
  
  const onStepFinish = async (step: any) => {
    const status = await detector.checkStep(step);
    
    if (status.isStuck) {
      console.warn('Stuck loop detected:', status);
      
      if (DEFAULT_CONFIG.enableHITL) {
        const decision = await recovery.handleStuckLoop(detector, context);
        
        if (decision === 'abort') {
          throw new StuckLoopError('User aborted stuck loop', status.details);
        } else if (decision === 'modify') {
          // User provided additional guidance, continue
          console.log('User modified approach, continuing...');
        }
      } else {
        throw new StuckLoopError('Stuck loop detected', status.details);
      }
    }
  };
  
  return await generateText({
    model: openai('gpt-4o'),
    prompt,
    tools: ALL_TOOLS,
    maxSteps: 20,
    onStepFinish,
    experimental_context: context,
  });
};
```

---

## Best Practices

### DO ✅

1. **Detect early**: Check after every 3 steps, not just at max steps
2. **Combine methods**: Use exact repetition + progress tracking
3. **Provide diagnostics**: Show user what agent was repeating
4. **Enable HITL**: Let users intervene and provide guidance
5. **Log patterns**: Track common stuck loops to improve prompts/tools
6. **Adaptive limits**: Lower max steps after detecting stuck behavior
7. **Clear errors**: Explain why agent was stopped
8. **Cost protection**: Stuck detection saves 85% of wasted API costs

### DON'T ❌

1. **Don't wait for max steps**: Detect and intervene early
2. **Don't silent fail**: Always notify user when stuck detected
3. **Don't lose progress**: Save partial results before stopping
4. **Don't ignore patterns**: Analyze stuck logs to fix root causes
5. **Don't false positive**: Allow some repetition for legitimate retries
6. **Don't disable in production**: Stuck detection is essential for cost control
7. **Don't forget to reset**: Clear detection state between agent runs
8. **Don't over-complicate**: Start with exact repetition, add complexity as needed

---

## Summary

### Key Takeaways

1. **Stuck loops are common**: 60% of agent failures involve repetitive behavior
2. **Early detection saves money**: 85% cost reduction vs max steps alone
3. **Multiple detection methods**: Exact repetition, semantic similarity, progress tracking
4. **Enable recovery**: HITL intervention provides best user experience
5. **Combine with prompts**: Add explicit loop prevention to system prompt
6. **Track patterns**: Log stuck cases to improve tools and prompts

### Detection Strategy Quick Reference

```typescript
const DETECTION_STRATEGY = {
  // When to check
  checkFrequency: 'every_step', // Don't wait for max steps
  
  // What to detect
  exactRepetition: 3,      // Same action 3× = stuck
  progressTimeout: 30000,  // 30s without progress = stuck
  errorRate: 0.5,          // 50% errors = stuck
  
  // How to respond
  recovery: 'hitl',        // Ask user for guidance
  fallback: 'abort',       // Stop if HITL disabled
};
```

---

## Research Citations

1. **GitHub browser-use** - "Endless loop detection to avoid high LLM usage costs" (Jan 2025)  
   https://github.com/browser-use/browser-use/issues/191

2. **Autono Framework** - "A ReAct-Based Highly Robust Autonomous Agent Framework" (Apr 2025)  
   https://arxiv.org/abs/2504.04650

3. **ReflAct Paper** - "World-Grounded Decision Making in LLM Agents via Goal-State Reflection" (May 2025)  
   https://arxiv.org/abs/2505.15182

4. **PlainEnglish.io** - "The Rogue Agent Problem: How ReAct Fails & How to Fix It" (Aug 2025)  
   https://ai.plainenglish.io/the-rogue-agent-problem-how-react-fails-how-to-fix-it

5. **AG2 Documentation** - "Advanced ReAct Loops: From Reasoning to Evaluation" (Jun 2025)  
   https://docs.ag2.ai/latest/docs/blog/2025/06/12/ReAct-Loops-in-GroupChat/

---

**Next Steps**:

- Read [3.4.2 - Convergence Detection](./3.4.2-convergence.md) for positive completion signals
- Read [3.4.1 - Max Steps Limits](./3.4.1-max-steps.md) for hard bounds
- Read [3.4.5 - Early Exit Strategies](./3.4.5-early-exit.md) for optimizing step usage
