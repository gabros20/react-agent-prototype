# 3.1.4 Agent Communication Protocols

> **Date**: November 18, 2025  
> **Layer**: 3 - Agent Architecture  
> **Category**: Core Patterns  
> **Prerequisites**: Basic understanding of agents  
> **Audience**: Developers building multi-agent systems

---

## Table of Contents

1. [Why Communication Matters](#why-communication-matters)
2. [Three Core Patterns](#three-core-patterns)
3. [Pattern 1: Direct Messages](#pattern-1-direct-messages)
4. [Pattern 2: Shared Channel](#pattern-2-shared-channel)
5. [Pattern 3: Broadcast](#pattern-3-broadcast)
6. [Modern Protocols (2024-2025)](#modern-protocols-2024-2025)
7. [Model Context Protocol (MCP)](#model-context-protocol-mcp)
8. [Agent-to-Agent Protocol (A2A)](#agent-to-agent-protocol-a2a)
9. [Real-World Examples](#real-world-examples)
10. [Choosing the Right Approach](#choosing-the-right-approach)
11. [Common Mistakes](#common-mistakes)
12. [Quick Reference](#quick-reference)
13. [References](#references)

---

## Why Communication Matters

### The Problem

When you have multiple agents working together, they need to share information. Without proper communication:

```python
# Agent A does research
research_agent = Agent("Research")
articles = research_agent.find_articles("AI agents")

# Agent B wants to analyze...
analysis_agent = Agent("Analysis")
# âŒ Problem: How does Agent B get the articles?
```

### The Solution

Agents need structured ways to:
- **Share data**: "Here are 10 articles I found"
- **Request help**: "Can you analyze this?"
- **Report status**: "I'm done with my task"
- **Coordinate work**: "I'll handle the next part"

### The MÃ—N Problem

Before standardized protocols, connecting M agents to N tools required MÃ—N custom integrations:

```
Without Standards:
Each agent needs custom code for each tool = MÃ—N integrations

With Protocols:
M agents + N tools = M+N standard implementations
```

This is why **communication protocols** matter in 2024-2025.

---

## Three Core Patterns

Every agent communication system uses one (or more) of these three patterns:

| Pattern | Analogy | When to Use |
|---------|---------|-------------|
| **Direct Message** | Texting a colleague | One-to-one handoff |
| **Shared Channel** | Team Slack channel | Shared workspace |
| **Broadcast** | Company announcement | Notify everyone |

---

## Pattern 1: Direct Messages

**Concept**: Agent A sends a message directly to Agent B.

### Simple Example

```python
class Agent:
    def __init__(self, name):
        self.name = name
    
    def send_message(self, to_agent, message):
        """Send direct message to another agent."""
        print(f"{self.name} â†’ {to_agent.name}: {message}")
        to_agent.receive_message(self.name, message)
    
    def receive_message(self, from_agent, message):
        """Receive message from another agent."""
        print(f"{self.name} received from {from_agent}: {message}")

# Usage
alice = Agent("Alice")
bob = Agent("Bob")
alice.send_message(bob, "Can you review this report?")
```

### When to Use

âœ… **Good for**:
- Sequential pipelines (Research â†’ Analysis â†’ Summary)
- One-to-one handoffs
- Simple workflows

âŒ **Not good for**:
- Many agents need same data
- Complex coordination
- Broadcasting updates

---

## Pattern 2: Shared Channel

**Concept**: All agents read/write to a common space (like a shared document).

### Simple Example

```python
class SharedChannel:
    """A place where all agents can read and write."""
    def __init__(self):
        self.messages = []
    
    def post(self, agent_name, message):
        """Any agent can post."""
        self.messages.append({
            "from": agent_name,
            "content": message,
            "timestamp": datetime.now()
        })
    
    def read_all(self):
        """Any agent can read all messages."""
        return self.messages

# Multiple agents use same channel
channel = SharedChannel()
channel.post("Alice", "I found 10 articles")
channel.post("Bob", "I'll analyze them")
channel.post("Charlie", "I'll write the summary")
```

### When to Use

âœ… **Good for**:
- Team workspace patterns
- Agents work in any order
- Everyone needs context

âŒ **Not good for**:
- Simple two-agent pipelines
- Private conversations
- Time-critical updates

---

## Pattern 3: Broadcast

**Concept**: One agent sends a message to ALL other agents at once.

### Simple Example

```python
class BroadcastSystem:
    def __init__(self):
        self.agents = []
    
    def register(self, agent):
        """Add agent to receive broadcasts."""
        self.agents.append(agent)
    
    def broadcast(self, from_agent, message):
        """Send message to all agents."""
        print(f"ğŸ“¢ BROADCAST from {from_agent}: {message}")
        for agent in self.agents:
            agent.receive_broadcast(from_agent, message)

# All agents receive the same message
broadcast = BroadcastSystem()
broadcast.register(alice)
broadcast.register(bob)
broadcast.register(charlie)

broadcast.broadcast("Coordinator", "All stop! Priority task incoming")
```

### When to Use

âœ… **Good for**:
- Emergency stops
- Status updates
- Priority changes

âŒ **Not good for**:
- Normal workflow messages
- Large data transfers
- Persistent communication

---

## Modern Protocols (2024-2025)

In 2024-2025, standardized protocols emerged to solve the agent communication problem at scale. Two protocols now dominate:

### Protocol Landscape

| Protocol | Purpose | Led By | Released | Status |
|----------|---------|--------|----------|--------|
| **MCP** | LLM â†” Tools | Anthropic | Nov 2024 | Production âœ… |
| **A2A** | Agent â†” Agent | Google | Apr 2025 | Production âœ… |

### Why These Matter

**Before**: Custom integrations for every LLM + Tool combination  
**After**: Implement once, work everywhere

**Adoption**:
- **MCP**: OpenAI, Google, Anthropic, Microsoft (100+ reference servers)
- **A2A**: Google, LangGraph, CrewAI, AutoGen (50+ partners)

---

## Model Context Protocol (MCP)

### What It Does

**MCP standardizes how LLMs connect to external tools and data.**

Think of it as "USB-C for AI" - one standard interface instead of custom cables for everything.

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   HOST (Your App)           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  MCP CLIENT         â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†• JSON-RPC
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   MCP SERVER (Tools)        â”‚
â”‚   â€¢ Resources (data)        â”‚
â”‚   â€¢ Tools (functions)       â”‚
â”‚   â€¢ Prompts (templates)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Client**: Embedded in your LLM application  
**Server**: Exposes tools/data to the LLM

### Three Key Features

#### 1. Resources (Data Access)

```typescript
// Server exposes data
{
  "method": "resources/list",
  "result": {
    "resources": [
      {
        "uri": "file:///docs/api-spec.md",
        "name": "API Specification",
        "mimeType": "text/markdown"
      }
    ]
  }
}
```

#### 2. Tools (Functions)

```typescript
// Server exposes functions
{
  "method": "tools/list",
  "result": {
    "tools": [
      {
        "name": "search_web",
        "description": "Search using Brave API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {"type": "string"},
            "count": {"type": "number", "default": 10}
          }
        }
      }
    ]
  }
}
```

#### 3. Prompts (Templates)

```typescript
// Server provides templates
{
  "method": "prompts/get",
  "params": {
    "name": "code_review",
    "arguments": {
      "files": ["src/api.ts", "tests/api.test.ts"]
    }
  }
}
```

### Practical Example: Weather Tool

```python
from mcp.server import Server

server = Server("weather-server")

@server.list_tools()
async def list_tools():
    return [{
        "name": "get_forecast",
        "description": "Get weather forecast",
        "inputSchema": {
            "type": "object",
            "properties": {
                "location": {"type": "string"},
                "days": {"type": "number", "default": 3}
            },
            "required": ["location"]
        }
    }]

@server.call_tool()
async def call_tool(name: str, arguments: dict):
    if name == "get_forecast":
        location = arguments["location"]
        days = arguments.get("days", 3)
        
        # Fetch weather data
        forecast = await fetch_weather(location, days)
        
        return {
            "content": [{
                "type": "text",
                "text": f"Forecast for {location}: {forecast}"
            }]
        }
```

### Real-World Servers

**Official** (Anthropic-maintained):
- GitHub, Slack, Google Drive
- Postgres, Git
- Brave Search, Puppeteer

**Community** (500+ servers):
- Stripe payments
- Kubernetes management
- Grafana incident investigation
- Spotify playlists
- Obsidian notes

### When to Use MCP

âœ… **Perfect for**:
- LLM needs to call external tools
- Connecting to databases, APIs, services
- Reusing standard tool integrations

âŒ **Not for**:
- Agent-to-agent communication (use A2A)
- Local-only communication
- Simple Python function calls

---

## Agent-to-Agent Protocol (A2A)

### What It Does

**A2A enables direct agent-to-agent collaboration across platforms.**

If MCP is "LLM â†’ Tools", then A2A is "Agent â†’ Agent".

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Agent A      â”‚         â”‚   Agent B      â”‚
â”‚   (Planner)    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   (Executor)   â”‚
â”‚                â”‚         â”‚                â”‚
â”‚ â€¢ Agent Card   â”‚ Discoveryâ”‚ â€¢ Agent Card   â”‚
â”‚ â€¢ Capabilities â”‚         â”‚ â€¢ Capabilities â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Agent Card**: Self-describing metadata (capabilities, endpoints, auth)  
**Transport**: JSON-RPC, REST, or Server-Sent Events (SSE)

### Agent Cards

Agents advertise their capabilities:

```typescript
{
  "id": "agent://planning-assistant",
  "name": "Planning Assistant",
  "description": "Breaks down complex tasks",
  "capabilities": [
    {
      "name": "decompose_task",
      "description": "Break task into subtasks",
      "inputSchema": {
        "type": "object",
        "properties": {
          "task": {"type": "string"}
        }
      }
    }
  ],
  "endpoints": {
    "jsonRpc": "https://api.example.com/agent/planning"
  },
  "authentication": {
    "type": "oauth2"
  }
}
```

### Message Format

```typescript
// Agent A sends message to Agent B
{
  "jsonrpc": "2.0",
  "method": "message/send",
  "params": {
    "from": "agent://planner",
    "to": "agent://executor",
    "message": {
      "role": "user",
      "content": [{
        "type": "text",
        "text": "Implement user authentication feature"
      }]
    },
    "taskId": "task-12345"
  }
}
```

### Task Management

A2A includes lifecycle management for long-running tasks:

```typescript
// Create task
{
  "method": "task/create",
  "params": {
    "title": "Build REST API",
    "assignee": "agent://backend-dev",
    "deadline": "2025-11-30T23:59:59Z"
  }
}

// Update status
{
  "method": "task/update",
  "params": {
    "taskId": "task-12345",
    "status": "in_progress",
    "progress": 0.45
  }
}
```

### Practical Example: Multi-Agent Code Review

```python
from a2a import Agent, AgentCard

# Agent 1: Code Analyzer
analyzer_card = AgentCard(
    id="agent://code-analyzer",
    capabilities=[{
        "name": "analyze_code",
        "inputSchema": {
            "type": "object",
            "properties": {
                "files": {"type": "array"},
                "language": {"type": "string"}
            }
        }
    }]
)

analyzer = Agent(analyzer_card)

@analyzer.on_message()
async def handle_analyze(message):
    files = message.content["files"]
    
    # Run static analysis
    results = await run_linter(files)
    
    # Send to security scanner
    await analyzer.send_message(
        to="agent://security-scanner",
        content={
            "type": "text",
            "text": f"Analysis complete. {len(results.issues)} issues"
        }
    )

# Agent 2: Security Scanner receives and processes
```

### Framework Integration

**LangGraph**:
```python
from a2a import A2AAgent

# Wrap LangGraph agent with A2A
a2a_agent = A2AAgent(agent_card)

@a2a_agent.on_capability("plan_workflow")
async def plan(params):
    result = await langgraph_workflow.invoke(params)
    return result
```

**CrewAI**:
```python
from crewai import Crew

crew = Crew(agents=[...], tasks=[...])

@a2a_agent.on_capability("research_topic")
async def research(params):
    result = crew.kickoff(inputs=params)
    return {"content": result}
```

### When to Use A2A

âœ… **Perfect for**:
- Agent-to-agent collaboration
- Multi-agent workflows
- Cross-platform agent communication
- Long-running tasks

âŒ **Not for**:
- LLM-to-tool connections (use MCP)
- Simple local messaging
- Real-time streaming (use WebSockets)

---

## Real-World Examples

### Example 1: Customer Support (Shared Channel)

```python
class SupportChannel:
    """Shared channel for support tickets."""
    def __init__(self):
        self.tickets = {}
    
    def create_ticket(self, ticket_id, issue):
        self.tickets[ticket_id] = {
            "issue": issue,
            "status": "new",
            "resolution": None
        }
    
    def update_ticket(self, ticket_id, **updates):
        self.tickets[ticket_id].update(updates)

# Agents communicate via shared channel
channel = SupportChannel()

# Customer creates ticket
channel.create_ticket("T-001", "Can't login")

# Triage agent updates
channel.update_ticket("T-001", status="triaged", assigned_to="Tech")

# Tech support resolves
channel.update_ticket("T-001", status="resolved", resolution="Reset password")
```

### Example 2: News Aggregation (Direct Messages + Hub)

```python
class NewsHub:
    """Central hub for news collection."""
    def __init__(self):
        self.articles = []
    
    def publish(self, source, articles):
        self.articles.extend(articles)
        print(f"ğŸ“° {source} published {len(articles)} articles")

# Multiple agents publish to hub
tech_news = NewsAgent("TechCrunch", hub)
biz_news = NewsAgent("Bloomberg", hub)

tech_news.fetch_and_publish()
biz_news.fetch_and_publish()

# Another agent reads all
all_news = hub.get_all_news()
```

### Example 3: Manufacturing Line (Broadcast + Direct)

```python
class AssemblyLine:
    def __init__(self):
        self.robots = []
    
    def start_product(self, product_id):
        """Broadcast: notify all robots."""
        print(f"ğŸ­ Starting product: {product_id}")
        for robot in self.robots:
            robot.prepare_for_product(product_id)
    
    def robot_completed(self, robot_name, task):
        """Direct: notify next robot."""
        print(f"âœ… {robot_name} completed: {task}")
        self.notify_next_robot(robot_name)
```

---

## Choosing the Right Approach

### Decision Tree

```
Need LLM to call external tools?
â”œâ”€ Yes â†’ Use MCP
â”‚   â€¢ Database queries
â”‚   â€¢ API calls
â”‚   â€¢ File access
â”‚
Need agents to collaborate?
â”œâ”€ Yes â†’ Use A2A
â”‚   â€¢ Multi-agent workflows
â”‚   â€¢ Cross-platform communication
â”‚   â€¢ Task management
â”‚
Building simple local system?
â””â”€ Yes â†’ Use Basic Patterns
    â€¢ Direct Messages (1-to-1)
    â€¢ Shared Channel (team workspace)
    â€¢ Broadcast (notify all)
```

### Pattern Comparison

| Need | Direct | Shared | Broadcast | MCP | A2A |
|------|--------|--------|-----------|-----|-----|
| **One-to-One** | âœ… | âŒ | âŒ | âŒ | âœ… |
| **Team Workspace** | âŒ | âœ… | âŒ | âŒ | âš ï¸ |
| **Notify All** | âŒ | âŒ | âœ… | âŒ | âš ï¸ |
| **LLM â†’ Tools** | âŒ | âŒ | âŒ | âœ… | âŒ |
| **Agent â†’ Agent** | âš ï¸ | âš ï¸ | âš ï¸ | âŒ | âœ… |
| **Production Scale** | âŒ | âŒ | âŒ | âœ… | âœ… |

---

## Common Mistakes

### Mistake 1: Using Broadcast for Everything

```python
# âŒ Bad: Broadcasting private messages
broadcast.send_to_all("Hey Bob, here's your sensitive data")

# âœ… Good: Direct message
alice.send_message(bob, sensitive_data)
```

### Mistake 2: No Message Structure

```python
# âŒ Bad: Unstructured strings
agent.send("data 123 more stuff")

# âœ… Good: Structured messages
agent.send({
    "type": "data",
    "value": 123,
    "description": "more stuff"
})
```

### Mistake 3: Ignoring Modern Protocols

```python
# âŒ Bad: Custom LLM tool integration
def custom_github_connector(llm, repo):
    # 500 lines of custom code...
    pass

# âœ… Good: Use MCP server
from mcp import Client
client = Client()
await client.connect("github-mcp-server")
```

### Mistake 4: Wrong Pattern for Scale

```python
# âŒ Bad: Direct messages for 100 agents
for agent in all_100_agents:
    coordinator.send_message(agent, update)

# âœ… Good: Broadcast or shared channel
broadcast.send_to_all(update)
# or
channel.post("coordinator", update)
```

---

## Quick Reference

### Basic Patterns (Code Templates)

**Direct Message**:
```python
class Agent:
    def send_to(self, other_agent, message):
        other_agent.receive(self.name, message)
```

**Shared Channel**:
```python
class Channel:
    def __init__(self):
        self.messages = []
    
    def post(self, agent_name, message):
        self.messages.append({"from": agent_name, "content": message})
```

**Broadcast**:
```python
class Broadcaster:
    def __init__(self):
        self.agents = []
    
    def broadcast(self, message):
        for agent in self.agents:
            agent.receive(message)
```

### Modern Protocols (Setup)

**MCP Server** (Python):
```python
from mcp.server import Server

server = Server("my-server")

@server.list_tools()
async def list_tools():
    return [{"name": "my_tool", "inputSchema": {...}}]

@server.call_tool()
async def call_tool(name, arguments):
    # Execute tool
    return {"content": [...]}
```

**A2A Agent** (Python):
```python
from a2a import Agent, AgentCard

card = AgentCard(
    id="agent://my-agent",
    capabilities=[{"name": "my_capability"}]
)

agent = Agent(card)

@agent.on_message()
async def handle_message(message):
    # Process message
    await agent.send_message(to="agent://other", content={...})
```

---

## References

### Modern Protocols (2024-2025)

1. **Model Context Protocol Specification** (Anthropic, Nov 2024)  
   [https://modelcontextprotocol.io/specification/2025-06-18](https://modelcontextprotocol.io/specification/2025-06-18)  
   Official MCP specification and documentation

2. **Agent2Agent Protocol** (Google, Apr 2025)  
   [https://a2a-protocol.org/latest/specification/](https://a2a-protocol.org/latest/specification/)  
   A2A protocol specification for agent collaboration

3. **"Agent Communication Protocols Explained: MCP vs. A2A"** (TDeFi, May 2025)  
   [https://tde.fi/founder-resource/blogs/technology/agent-communication-protocols](https://tde.fi/founder-resource/blogs/technology/agent-communication-protocols)  
   Comparison of modern protocols with Web3 example

### Practical Guides

4. **"Agent Communication Protocols Explained"** (DigitalOcean, Nov 2025)  
   [https://www.digitalocean.com/community/tutorials/agent-communication-protocols](https://www.digitalocean.com/community/tutorials/agent-communication-protocols)  
   Beginner-friendly overview of agent communication

5. **"AI Agent Communication"** (IBM Think, Apr 2025)  
   [https://www.ibm.com/think/topics/ai-agent-communication](https://www.ibm.com/think/topics/ai-agent-communication)  
   Practical examples in robotics, smart homes, vehicles

6. **"Building Effective Agents"** (Anthropic, Dec 2024)  
   [https://www.anthropic.com/index/building-effective-agents](https://www.anthropic.com/index/building-effective-agents)  
   Production best practices from Anthropic

7. **"A Practical Guide to Building Agents"** (OpenAI, Apr 2025)  
   [https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf](https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf)  
   Customer service, fraud detection, insurance examples

### Framework Documentation

8. **"AG2 - Conversation Patterns Deep-dive"** (AG2, Apr 2025)  
   [https://docs.ag2.ai/0.8.6/docs/user-guide/advanced-concepts/conversation-patterns](https://docs.ag2.ai/0.8.6/docs/user-guide/advanced-concepts/conversation-patterns)  
   Two-agent chat, sequential, group chat patterns

9. **"Dialogues docs"** (Fetch.ai, Sep 2025)  
   [https://uagents.fetch.ai/docs/guides/dialogues](https://uagents.fetch.ai/docs/guides/dialogues)  
   Structured communication protocols, state management

10. **"LangChain Graph API - Multi-Agent Network"** (2025)  
    [https://langchain-ai.github.io/langgraph/how-tos/multi-agent-network/](https://langchain-ai.github.io/langgraph/how-tos/multi-agent-network/)  
    Building multi-agent networks with LangGraph

11. **"Pipeline - AgentScope"** (July 2025)  
    [https://doc.agentscope.io/tutorial/task_pipeline.html](https://doc.agentscope.io/tutorial/task_pipeline.html)  
    MsgHub for automatic message broadcasting

### Tutorials

12. **"Multi-Agent Workflows: A Practical Guide"** (Medium, Sep 2025)  
    [https://medium.com/@kanerika/multi-agent-workflows-a-practical-guide](https://medium.com/@kanerika/multi-agent-workflows-a-practical-guide)  
    Architecture patterns, framework comparisons

13. **"How to Set Up a Simple Multi-Agent System"** (Towards AI, Aug 2024)  
    [https://pub.towardsai.net/how-to-set-up-a-simple-multi-agent-system-with-atomic](https://pub.towardsai.net/how-to-set-up-a-simple-multi-agent-system-with-atomic)  
    Step-by-step tutorial with Atomic Agents

14. **"Quick Start Guide for uAgents Framework"** (Fetch.ai, Sep 2025)  
    [https://uagents.fetch.ai/docs/quickstart](https://uagents.fetch.ai/docs/quickstart)  
    Message passing example with Sender/Receiver agents

15. **"AI Agents in LangGraph"** (DeepLearning.AI, June 2024)  
    [https://learn.deeplearning.ai/courses/ai-agents-in-langgraph/](https://learn.deeplearning.ai/courses/ai-agents-in-langgraph/)  
    ReAct pattern, agent workflows

### Books & Reviews

16. **"AI Agents In Practice"** (Packt, 2025) - Reviewed by Mark Peters  
    [https://www.linkedin.com/pulse/review-ai-agents-practice-packt-2025-mark-peters](https://www.linkedin.com/pulse/review-ai-agents-practice-packt-2025-mark-peters)  
    Comprehensive book on agent orchestration and protocols

17. **"Agentic Patterns and Implementation"** (Salesforce, 2025)  
    [https://architect.salesforce.com/fundamentals/agentic-patterns](https://architect.salesforce.com/fundamentals/agentic-patterns)  
    Conversational, proactive, autonomous agent patterns

---

## Summary

### Three Levels of Communication

**1. Basic Patterns** (Simple systems):
- **Direct Messages**: One agent â†’ another agent
- **Shared Channel**: All agents read/write common space
- **Broadcast**: One agent â†’ all agents

**2. Modern Protocols** (Production systems):
- **MCP**: LLM â†” External tools (standardized tool access)
- **A2A**: Agent â†” Agent (cross-platform collaboration)

**3. When to Use What**:
- Building simple prototype? â†’ Start with basic patterns
- Need LLM to call tools? â†’ Use MCP
- Need agents to collaborate? â†’ Use A2A
- Need production-grade system? â†’ Combine MCP + A2A + patterns

### Key Takeaways

âœ… **Start Simple**: Use direct messages or shared channels for prototypes  
âœ… **Scale Smart**: Adopt MCP/A2A when you need standardization  
âœ… **Structure Messages**: Always use structured data (dicts/JSON)  
âœ… **Pick the Right Tool**: Don't use broadcast when you need direct messages  
âœ… **Follow Standards**: MCP and A2A are production-ready in 2025

The future of agent communication is **standardized protocols** (MCP, A2A) that work like USB-C - one interface, many uses. But understanding the core patterns (direct, shared, broadcast) helps you design better systems regardless of which protocol you choose.

**Next**: Explore state management in 3.1.5.
