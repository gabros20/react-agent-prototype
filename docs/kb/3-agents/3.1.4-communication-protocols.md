# 3.1.4 Agent Communication Protocols

> **Date**: November 17, 2025  
> **Layer**: 3 - Agent Architecture  
> **Category**: Core Patterns  
> **Prerequisites**: 3.1.1 ReAct Pattern, 3.1.2 Tool Design, 3.1.3 Multi-Agent Orchestration  
> **Audience**: AI Engineers building production multi-agent systems

---

## Table of Contents

1. [Introduction](#introduction)
2. [The Protocol Landscape (2024-2025)](#the-protocol-landscape-2024-2025)
3. [Model Context Protocol (MCP)](#model-context-protocol-mcp)
4. [Agent2Agent Protocol (A2A)](#agent2agent-protocol-a2a)
5. [Agent Communication Protocol (ACP)](#agent-communication-protocol-acp)
6. [Agent Network Protocol (ANP)](#agent-network-protocol-anp)
7. [Protocol Comparison](#protocol-comparison)
8. [Implementation Patterns](#implementation-patterns)
9. [Message Formats](#message-formats)
10. [Security Considerations](#security-considerations)
11. [Phased Adoption Roadmap](#phased-adoption-roadmap)
12. [Production Best Practices](#production-best-practices)
13. [References](#references)

---

## Introduction

As AI agents evolve from isolated systems to collaborative ecosystems, standardized communication protocols have emerged as critical infrastructure. The explosion of LLM-powered agents in 2024-2025 exposed a fundamental challenge: the **M×N integration problem**—M different LLMs requiring custom connectors for N different tools and data sources, creating M×N fragile integrations.

### The M×N Problem

```
Before Protocols (M×N complexity):
┌─────────┐     ┌─────────┐
│ Claude  │────▶│ GitHub  │
│         │     └─────────┘
│         │     ┌─────────┐
│         │────▶│ Slack   │
└─────────┘     └─────────┘
                ┌─────────┐
┌─────────┐────▶│ Postgres│
│ GPT-4   │     └─────────┘
│         │     ┌─────────┐
│         │────▶│ GitHub  │
└─────────┘     └─────────┘
                (6 custom integrations)

With Protocols (M+N complexity):
┌─────────┐            ┌──────────┐            ┌─────────┐
│ Claude  │───MCP────▶ │          │───MCP────▶ │ GitHub  │
└─────────┘            │ Protocol │            └─────────┘
                       │  Layer   │            ┌─────────┐
┌─────────┐            │          │───MCP────▶ │ Slack   │
│ GPT-4   │───MCP────▶ │          │            └─────────┘
└─────────┘            │          │            ┌─────────┐
                       └──────────┘───MCP────▶ │ Postgres│
                                               └─────────┘
                (4 standard implementations)
```

### Protocol Evolution Timeline

**2023**: OpenAI function calling + ChatGPT plugins (vendor-specific)  
**November 2024**: Anthropic announces Model Context Protocol (MCP)  
**March 2025**: OpenAI officially adopts MCP across products  
**April 2025**: Google DeepMind commits to MCP support in Gemini  
**April 2025**: Google launches Agent2Agent (A2A) protocol  
**2024-2025**: ACP (Agent Communication Protocol) emerges under Linux Foundation  
**2024-2025**: ANP (Agent Network Protocol) enables decentralized agent networks

### Why Protocols Matter

**Interoperability**: Agents built on different frameworks can collaborate  
**Reduced Development Time**: Reuse standard connectors instead of building custom  
**Security**: Consistent security models across integrations  
**Scalability**: Add new tools or agents without N² integration complexity  
**Vendor Independence**: Switch LLM providers without rewriting integrations  
**Ecosystem Effects**: Third-party developers build once, deploy everywhere

### Protocol Categories

The 2024-2025 protocol landscape addresses four distinct integration needs:

1. **Tool Access (MCP)**: LLM ↔ External Tools/Data (client-server)
2. **Agent Collaboration (A2A)**: Agent ↔ Agent (peer-to-peer)
3. **Local Communication (ACP)**: Multi-agent messaging (REST-native)
4. **Network Discovery (ANP)**: Agent marketplaces (decentralized)

---

## The Protocol Landscape (2024-2025)

### Overview Matrix

| Protocol | Released | Led By           | Primary Use         | Architecture  | Transport           |
| -------- | -------- | ---------------- | ------------------- | ------------- | ------------------- |
| **MCP**  | Nov 2024 | Anthropic        | LLM tool access     | Client-Server | JSON-RPC, HTTP      |
| **A2A**  | Apr 2025 | Google           | Agent collaboration | Peer-to-Peer  | JSON-RPC, HTTP, SSE |
| **ACP**  | 2024     | Linux Foundation | Local messaging     | REST-native   | HTTP, gRPC, ZeroMQ  |
| **ANP**  | 2024     | Open Source      | Network discovery   | Decentralized | P2P, DID, JSON-LD   |

### Adoption Status (November 2025)

**MCP**:

-   Adopted by: OpenAI, Google DeepMind, Anthropic, Microsoft Semantic Kernel
-   Implementations: 100+ reference servers, 500+ community servers
-   SDKs: Python, TypeScript, C#, Java
-   Production-ready: ✅ Yes

**A2A**:

-   Adopted by: Google, 50+ partners
-   Frameworks: LangGraph, CrewAI, AutoGen integrations
-   SDKs: Python, TypeScript, Java
-   Production-ready: ✅ Yes

**ACP**:

-   Governance: Linux Foundation
-   Focus: Enterprise, edge computing
-   Adoption: Moderate (IBM, BeeAI)
-   Production-ready: ⚠️ Emerging

**ANP**:

-   Status: Experimental
-   Focus: Decentralized agent networks
-   Adoption: Low (academic, research)
-   Production-ready: ❌ Not yet

### Market Share Projection (2025-2026)

```
Tool Integration:
  MCP: 75%  ████████████████████
  Custom: 25%  ████

Agent-to-Agent:
  A2A: 60%  ████████████████
  ACP: 25%  ████
  Custom: 15%  ███

Network Discovery:
  ANP: 10%  ██
  Custom: 90%  ████████████████████
```

---

## Model Context Protocol (MCP)

### Overview

**Model Context Protocol (MCP)** is an open standard introduced by Anthropic in November 2024 to standardize how AI systems integrate with external tools, data sources, and services. It solves the tool integration problem by providing a universal interface for LLMs to access context and execute functions.

**Specification**: [https://modelcontextprotocol.io/specification/2025-06-18](https://modelcontextprotocol.io/specification/2025-06-18)

### Architecture

MCP uses a **client-server** architecture with three components:

```
┌─────────────────────────────────────────────┐
│           HOST APPLICATION                  │
│  (Claude Desktop, IDE, Custom App)          │
│                                             │
│  ┌───────────────────────────────────────┐  │
│  │         MCP CLIENT                    │  │
│  │  (Embedded in host)                   │  │
│  └───────────────────────────────────────┘  │
└─────────────────────────────────────────────┘
                    ↕ JSON-RPC 2.0
┌─────────────────────────────────────────────┐
│          MCP SERVER (Tools/Data)            │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐     │
│  │ Resources│ │  Prompts │ │  Tools   │     │
│  └──────────┘ └──────────┘ └──────────┘     │
└─────────────────────────────────────────────┘
```

**Host**: LLM application (e.g., Claude Desktop, IDE)  
**Client**: Connector embedded in host  
**Server**: Service exposing capabilities (resources, prompts, tools)

### Key Features

#### 1. Resources

**Context and data** accessible to the LLM or user:

```typescript
// Server exposes resources
{
  "method": "resources/list",
  "result": {
    "resources": [
      {
        "uri": "file:///docs/api-spec.md",
        "name": "API Specification",
        "description": "OpenAPI spec for REST API",
        "mimeType": "text/markdown"
      },
      {
        "uri": "database://users/schema",
        "name": "User Database Schema",
        "mimeType": "application/json"
      }
    ]
  }
}

// Client reads resource
{
  "method": "resources/read",
  "params": {
    "uri": "file:///docs/api-spec.md"
  }
}
```

#### 2. Prompts

**Templated messages** for common workflows:

```typescript
// Server defines prompt template
{
  "method": "prompts/list",
  "result": {
    "prompts": [
      {
        "name": "code_review",
        "description": "Review code changes",
        "arguments": [
          {
            "name": "files",
            "description": "Files to review",
            "required": true
          }
        ]
      }
    ]
  }
}

// Client requests prompt
{
  "method": "prompts/get",
  "params": {
    "name": "code_review",
    "arguments": {
      "files": ["src/api.ts", "tests/api.test.ts"]
    }
  }
}
```

#### 3. Tools

**Functions** the LLM can execute:

```typescript
// Server exposes tools
{
  "method": "tools/list",
  "result": {
    "tools": [
      {
        "name": "search_web",
        "description": "Search the web using Brave API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            },
            "count": {
              "type": "number",
              "description": "Number of results",
              "default": 10
            }
          },
          "required": ["query"]
        }
      }
    ]
  }
}

// LLM calls tool
{
  "method": "tools/call",
  "params": {
    "name": "search_web",
    "arguments": {
      "query": "MCP protocol examples",
      "count": 5
    }
  }
}
```

#### 4. Sampling (Server-Initiated LLM Calls)

Servers can request LLM completions:

```typescript
// Server requests LLM sampling
{
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": "Analyze this data and suggest next steps"
      }
    ],
    "maxTokens": 1000,
    "temperature": 0.7
  }
}
```

**Use Case**: Agentic behavior where tools trigger additional LLM reasoning.

### Transport Mechanisms

**1. stdio (Local Processes)**:

```python
# Server runs as child process
import sys
import json

def handle_request(request):
    # Process JSON-RPC request
    pass

# Read from stdin
for line in sys.stdin:
    request = json.loads(line)
    response = handle_request(request)
    print(json.dumps(response))
    sys.stdout.flush()
```

**2. HTTP with SSE (Remote Services)**:

```typescript
// Client opens SSE connection
const eventSource = new EventSource("https://server/mcp");

eventSource.addEventListener("endpoint", (event) => {
	const { uri } = JSON.parse(event.data);

	// Send requests to endpoint
	fetch(uri, {
		method: "POST",
		body: JSON.stringify({
			jsonrpc: "2.0",
			method: "tools/call",
			params: {
				/* ... */
			},
			id: 1,
		}),
	});
});

// Server responds via SSE
eventSource.addEventListener("message", (event) => {
	const response = JSON.parse(event.data);
	console.log("Response:", response);
});
```

### Capability Negotiation

During initialization, client and server exchange capabilities:

```typescript
// Client announces capabilities
{
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-06-18",
    "capabilities": {
      "roots": {
        "listChanged": true  // Client can expose filesystem roots
      },
      "sampling": {}  // Client supports LLM sampling requests
    },
    "clientInfo": {
      "name": "Claude Desktop",
      "version": "1.0.0"
    }
  }
}

// Server responds with its capabilities
{
  "result": {
    "protocolVersion": "2025-06-18",
    "capabilities": {
      "resources": {
        "subscribe": true,  // Supports resource change notifications
        "listChanged": true
      },
      "prompts": {
        "listChanged": true
      },
      "tools": {
        "listChanged": true
      }
    },
    "serverInfo": {
      "name": "GitHub MCP Server",
      "version": "1.2.0"
    }
  }
}
```

### Implementation Example

**Weather Forecast MCP Server** (Python):

```python
from mcp.server import Server
from mcp.types import Tool, Resource
import httpx

server = Server("weather-server")

@server.list_tools()
async def list_tools() -> list[Tool]:
    return [
        Tool(
            name="get_forecast",
            description="Get weather forecast for a location",
            inputSchema={
                "type": "object",
                "properties": {
                    "location": {
                        "type": "string",
                        "description": "City name or zip code"
                    },
                    "days": {
                        "type": "number",
                        "description": "Number of days (1-7)",
                        "default": 3
                    }
                },
                "required": ["location"]
            }
        )
    ]

@server.call_tool()
async def call_tool(name: str, arguments: dict):
    if name == "get_forecast":
        location = arguments["location"]
        days = arguments.get("days", 3)

        # Call weather API
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"https://api.weather.gov/forecast",
                params={"location": location, "days": days}
            )
            data = response.json()

        return {
            "content": [
                {
                    "type": "text",
                    "text": f"Weather forecast for {location}:\n{data}"
                }
            ]
        }

# Run server
if __name__ == "__main__":
    server.run()
```

**Client Usage** (Claude Desktop):

```typescript
// User: "What's the weather in San Francisco?"

// LLM decides to use tool
const toolCall = {
	name: "get_forecast",
	arguments: {
		location: "San Francisco",
		days: 3,
	},
};

// Client invokes MCP server
const response = await mcpClient.callTool(toolCall);

// LLM receives result and generates response
("The forecast for San Francisco over the next 3 days is...");
```

### Security Principles

**User Consent and Control**:

-   Users must explicitly consent to all data access
-   Users retain control over data sharing and tool execution
-   Clear UIs for reviewing and authorizing activities

**Tool Safety**:

-   Tools represent arbitrary code execution
-   Hosts must obtain explicit consent before invoking tools
-   Tool descriptions should be treated as untrusted (unless from verified server)

**LLM Sampling Controls**:

-   Users must approve sampling requests
-   Users control which prompts are sent and what results servers see
-   Protocol limits server visibility into sampling prompts

**Data Privacy**:

-   Hosts must obtain consent before exposing user data
-   Resources should be protected with access controls
-   No data transmission without user approval

### Real-World Adoption

**OpenAI** (March 2025):

-   ChatGPT Desktop app
-   Agents SDK
-   Responses API

**Google DeepMind** (April 2025):

-   Gemini models
-   Google AI infrastructure

**Microsoft**:

-   Semantic Kernel integration
-   Azure OpenAI support

**Tools & IDEs**:

-   Zed editor
-   Replit
-   Codeium
-   Sourcegraph

**Enterprise**:

-   Block (payment systems)
-   Apollo (data platforms)
-   Cloudflare (edge deployment)

### Reference Servers (100+)

**Anthropic-Maintained**:

-   Google Drive
-   Slack
-   GitHub
-   Git
-   Postgres
-   Puppeteer (browser automation)
-   AWS Knowledge Base (RAG)
-   Brave Search

**Community** (500+):

-   Stripe payments
-   Kubernetes pod management
-   Grafana incident investigation
-   Spotify playlist management
-   Qdrant vector search
-   Obsidian note search

---

## Agent2Agent Protocol (A2A)

### Overview

**Agent2Agent (A2A)** is an open communication standard introduced by Google in April 2025, designed for interoperability between AI agents across platforms, vendors, and frameworks. Unlike MCP (LLM ↔ tools), A2A focuses on **agent ↔ agent** collaboration.

**Specification**: [https://a2a-protocol.org/latest/specification/](https://a2a-protocol.org/latest/specification/)

### Key Differentiators

**Peer-to-Peer**: Agents communicate directly (not client-server)  
**Task-Oriented**: Focus on collaborative task management  
**Cross-Vendor**: Google, IBM, 50+ partners  
**Multimodal**: Text, audio, video, structured data  
**Stateful**: Long-running tasks with context persistence

### Architecture

```
┌────────────────┐                    ┌────────────────┐
│     Agent A    │                    │     Agent B    │
│    (Planner)   │                    │   (Executor)   │
│                │                    │                │
│ Agent Card     │◄──────────────────►│ Agent Card     │
│ - Capabilities │      Discovery     │ - Capabilities │
│ - Endpoints    │                    │ - Endpoints    │
│ - Auth         │                    │ - Auth         │
└────────────────┘                    └────────────────┘
       │                                      │
       └────────▶  Task Collaboration  ◄──────┘
                  (JSON-RPC, HTTP, SSE)
```

### Agent Cards

**Agent Cards** are self-describing metadata documents advertising capabilities:

```typescript
{
  "id": "agent://planning-assistant",
  "name": "Planning Assistant",
  "description": "Breaks down complex tasks into actionable steps",
  "version": "1.0.0",
  "capabilities": [
    {
      "name": "decompose_task",
      "description": "Break task into subtasks",
      "inputSchema": {
        "type": "object",
        "properties": {
          "task": { "type": "string" },
          "maxDepth": { "type": "number", "default": 3 }
        }
      }
    },
    {
      "name": "estimate_effort",
      "description": "Estimate time and resources",
      "inputSchema": {
        "type": "object",
        "properties": {
          "tasks": { "type": "array", "items": { "type": "string" } }
        }
      }
    }
  ],
  "endpoints": {
    "jsonRpc": "https://api.example.com/agent/planning",
    "rest": "https://api.example.com/agent/planning/v1",
    "sse": "https://api.example.com/agent/planning/stream"
  },
  "authentication": {
    "type": "oauth2",
    "authorizationUrl": "https://auth.example.com/oauth/authorize",
    "tokenUrl": "https://auth.example.com/oauth/token"
  },
  "supportedTransports": ["json-rpc", "rest", "sse"],
  "preferredTransport": "json-rpc"
}
```

### Discovery Mechanisms

**Online Discovery** (Registry):

```typescript
// Query agent registry
const response = await fetch("https://registry.a2a.io/agents", {
	method: "POST",
	body: JSON.stringify({
		query: {
			capabilities: ["code_review", "security_scan"],
		},
	}),
});

const agents = await response.json();
// Returns matching Agent Cards
```

**Offline Discovery** (Direct):

```typescript
// Direct Agent Card URL
const agentCard = await fetch("https://agent.example.com/.well-known/agent-card.json");
```

### Transport Protocols

A2A supports **three equal transports**:

#### 1. JSON-RPC 2.0

```typescript
// Request
{
  "jsonrpc": "2.0",
  "method": "message/send",
  "params": {
    "from": "agent://planner",
    "to": "agent://executor",
    "message": {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Implement user authentication feature"
        }
      ]
    },
    "taskId": "task-12345"
  },
  "id": 1
}

// Response
{
  "jsonrpc": "2.0",
  "result": {
    "messageId": "msg-67890",
    "status": "received"
  },
  "id": 1
}
```

#### 2. REST API

```http
POST /v1/message:send HTTP/1.1
Host: agent.example.com
Content-Type: application/json
Authorization: Bearer <token>

{
  "from": "agent://planner",
  "to": "agent://executor",
  "message": {
    "role": "user",
    "content": [
      {
        "type": "text",
        "text": "Implement user authentication feature"
      }
    ]
  },
  "taskId": "task-12345"
}
```

#### 3. Server-Sent Events (SSE)

```typescript
// Streaming responses
const eventSource = new EventSource("https://agent.example.com/v1/message:stream");

eventSource.addEventListener("message", (event) => {
	const data = JSON.parse(event.data);

	if (data.type === "progress") {
		console.log(`Progress: ${data.percentage}%`);
	} else if (data.type === "result") {
		console.log("Final result:", data.content);
	}
});
```

### Task Management

A2A provides **lifecycle management** for long-running tasks:

```typescript
// Create task
{
  "method": "task/create",
  "params": {
    "title": "Build REST API",
    "description": "Implement user authentication endpoints",
    "assignee": "agent://backend-dev",
    "deadline": "2025-11-30T23:59:59Z"
  }
}

// Response
{
  "result": {
    "taskId": "task-12345",
    "status": "created",
    "createdAt": "2025-11-17T10:00:00Z"
  }
}

// Update task status
{
  "method": "task/update",
  "params": {
    "taskId": "task-12345",
    "status": "in_progress",
    "progress": 0.45,
    "message": "Completed authentication logic, working on tests"
  }
}

// Get task status
{
  "method": "task/get",
  "params": {
    "taskId": "task-12345"
  }
}

// Response
{
  "result": {
    "taskId": "task-12345",
    "status": "in_progress",
    "progress": 0.45,
    "history": [
      {
        "timestamp": "2025-11-17T10:00:00Z",
        "status": "created"
      },
      {
        "timestamp": "2025-11-17T10:15:00Z",
        "status": "in_progress",
        "message": "Started implementation"
      },
      {
        "timestamp": "2025-11-17T11:30:00Z",
        "status": "in_progress",
        "message": "Completed authentication logic, working on tests"
      }
    ]
  }
}
```

### Multimodal Support

A2A supports **text, audio, video, files, structured data**:

```typescript
{
  "method": "message/send",
  "params": {
    "message": {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Analyze this image and provide feedback"
        },
        {
          "type": "image",
          "imageUrl": {
            "url": "https://example.com/image.png"
          }
        },
        {
          "type": "file",
          "fileUrl": {
            "url": "https://example.com/report.pdf",
            "mimeType": "application/pdf"
          }
        }
      ]
    }
  }
}
```

### Security Model

**OAuth 2.0 + API Keys**:

```typescript
// Agent Card specifies auth
{
  "authentication": {
    "type": "oauth2",
    "flows": ["authorization_code", "client_credentials"],
    "scopes": ["read:tasks", "write:tasks", "execute:tools"]
  }
}

// Request with auth
fetch('https://agent.example.com/v1/message:send', {
  headers: {
    'Authorization': 'Bearer <oauth_token>',
    'X-API-Key': '<api_key>'
  }
});
```

**Capability Scoping**:

```typescript
// Limit what agent can do
{
  "authorization": {
    "scopes": ["decompose_task"],  // Only allow task decomposition
    "denied": ["execute_code"]  // Prevent code execution
  }
}
```

### Implementation Example

**Multi-Agent Code Review System**:

```python
from a2a import Agent, AgentCard, Task

# Agent 1: Code Analyzer
analyzer_card = AgentCard(
    id="agent://code-analyzer",
    name="Code Analyzer",
    capabilities=[
        {
            "name": "analyze_code",
            "description": "Static analysis and linting",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "files": {"type": "array", "items": {"type": "string"}},
                    "language": {"type": "string"}
                }
            }
        }
    ],
    endpoints={
        "jsonRpc": "https://analyzer.example.com/rpc"
    }
)

analyzer = Agent(analyzer_card)

@analyzer.on_message()
async def handle_analyze(message):
    files = message.content["files"]
    language = message.content["language"]

    # Run static analysis
    results = await run_linter(files, language)

    # Send results to security scanner
    await analyzer.send_message(
        to="agent://security-scanner",
        content={
            "type": "text",
            "text": f"Analysis complete. Found {len(results.issues)} issues"
        },
        artifacts=[{
            "type": "structured",
            "data": results.dict()
        }]
    )

# Agent 2: Security Scanner
scanner_card = AgentCard(
    id="agent://security-scanner",
    name="Security Scanner",
    capabilities=[
        {
            "name": "scan_vulnerabilities",
            "description": "Detect security issues",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "code": {"type": "string"},
                    "language": {"type": "string"}
                }
            }
        }
    ]
)

scanner = Agent(scanner_card)

@scanner.on_message()
async def handle_scan(message):
    # Receive analyzer results
    analysis_data = message.artifacts[0]["data"]

    # Perform security scan
    vulnerabilities = await scan_for_vulnerabilities(analysis_data)

    # Send to report generator
    await scanner.send_message(
        to="agent://report-generator",
        content={
            "type": "text",
            "text": f"Found {len(vulnerabilities)} security issues"
        },
        artifacts=[{
            "type": "structured",
            "data": {
                "analysis": analysis_data,
                "vulnerabilities": vulnerabilities
            }
        }]
    )

# Agent 3: Report Generator
@report_agent.on_message()
async def handle_report(message):
    data = message.artifacts[0]["data"]

    # Generate comprehensive report
    report = await generate_report(
        analysis=data["analysis"],
        vulnerabilities=data["vulnerabilities"]
    )

    # Return to orchestrator
    await report_agent.send_message(
        to=message.from_agent,
        content={
            "type": "file",
            "fileUrl": {
                "url": f"https://reports.example.com/{report.id}.pdf",
                "mimeType": "application/pdf"
            }
        }
    )

# Orchestrator initiates workflow
orchestrator = Agent("agent://orchestrator")

task = await orchestrator.create_task(
    assignee="agent://code-analyzer",
    title="Review PR #1234",
    context={
        "files": ["src/auth.py", "src/api.py"],
        "language": "python"
    }
)

await orchestrator.send_message(
    to="agent://code-analyzer",
    content={
        "type": "text",
        "text": "Analyze these files for code quality and security"
    },
    taskId=task.id
)
```

### Framework Integration

**LangGraph**:

```python
from langgraph.graph import StateGraph
from a2a import A2AAgent

# Wrap LangGraph agent with A2A
agent_card = AgentCard(
    id="agent://langgraph-planner",
    capabilities=[{"name": "plan_workflow"}]
)

a2a_agent = A2AAgent(agent_card)

@a2a_agent.on_capability("plan_workflow")
async def plan(params):
    # Delegate to LangGraph
    workflow = StateGraph(...)
    result = await workflow.invoke(params)
    return result
```

**CrewAI**:

```python
from crewai import Agent as CrewAgent, Crew
from a2a import A2AAgent

# Expose Crew as A2A agent
crew = Crew(agents=[...], tasks=[...])

agent_card = AgentCard(
    id="agent://crew-research",
    capabilities=[{"name": "research_topic"}]
)

a2a_agent = A2AAgent(agent_card)

@a2a_agent.on_capability("research_topic")
async def research(params):
    result = crew.kickoff(inputs=params)
    return {"content": result}
```

---

## Agent Communication Protocol (ACP)

### Overview

**Agent Communication Protocol (ACP)** is an open standard under the Linux Foundation, designed for **local and edge** multi-agent communication. Unlike MCP (tool access) and A2A (cloud collaboration), ACP focuses on **low-latency, local-first** messaging.

**Governance**: Linux Foundation  
**Focus**: Enterprise, edge, IoT, robotics  
**Philosophy**: Runtime-agnostic, minimal dependencies

### Key Characteristics

**REST-Native**: Lightweight HTTP-based messaging  
**Flexible Transport**: HTTP, gRPC, ZeroMQ, local bus  
**Offline Capable**: No cloud dependency required  
**Low Latency**: Optimized for edge devices  
**Event-Driven**: Asynchronous, decentralized architecture  
**Privacy-Focused**: Data stays local

### Architecture

```
┌──────────────────────────────────────────────┐
│     Local Environment (Edge/Device)          │
│                                              │
│    ┌─────────┐       ACP       ┌─────────┐   │
│    │ Agent A │◄──────Bus──────►│ Agent B │   │
│    └─────────┘                 └─────────┘   │
│         │                           │        │
│         ↓                           ↓        │
│    ┌─────────────────────────────────────┐   │
│    │    Local Discovery Registry         │   │
│    │    (No external service needed)     │   │
│    └─────────────────────────────────────┘   │
└──────────────────────────────────────────────┘
```

### Message Structure

**Performative-Based Messaging** (FIPA ACL heritage):

```typescript
{
  "performative": "inform",  // inform, request, propose, accept, reject
  "sender": "agent://sensor-1",
  "receiver": "agent://controller",
  "content": {
    "type": "sensor_reading",
    "data": {
      "temperature": 72.5,
      "humidity": 45,
      "timestamp": "2025-11-17T10:00:00Z"
    }
  },
  "replyTo": "msg-12345",
  "conversationId": "conv-67890",
  "ontology": "home-automation-v1",
  "language": "json"
}
```

**Performatives**:

-   `inform`: Share information
-   `request`: Ask for action
-   `query`: Ask for information
-   `propose`: Suggest action/value
-   `accept`: Agree to proposal
-   `reject`: Decline proposal
-   `confirm`: Acknowledge receipt

### Multi-Part Messages

ACP supports **MIME-typed multi-part** messages:

```http
POST /agent/message HTTP/1.1
Host: localhost:8080
Content-Type: multipart/mixed; boundary=----Boundary

------Boundary
Content-Type: application/json

{
  "performative": "request",
  "sender": "agent://vision-system",
  "receiver": "agent://ml-processor",
  "content": {
    "action": "detect_objects"
  }
}

------Boundary
Content-Type: image/jpeg
Content-Disposition: attachment; filename="frame.jpg"

[Binary image data]

------Boundary--
```

### Transport Options

**1. HTTP/REST**:

```typescript
// Standard REST endpoints
POST / v1 / message;
GET / v1 / agents / { id };
GET / v1 / agents / { id } / capabilities;
POST / v1 / agents / { id } / subscribe;
```

**2. gRPC** (high-performance):

```protobuf
service AgentCommunication {
  rpc SendMessage(Message) returns (MessageResponse);
  rpc StreamMessages(MessageStream) returns (stream Message);
  rpc GetCapabilities(AgentId) returns (Capabilities);
}
```

**3. ZeroMQ** (ultra-low latency):

```python
import zmq

context = zmq.Context()
socket = context.socket(zmq.DEALER)
socket.connect("tcp://localhost:5555")

# Send message
socket.send_json({
    "performative": "request",
    "content": {...}
})

# Receive response
response = socket.recv_json()
```

### Local Discovery

**No Registry Required**:

```python
# Agents advertise via mDNS/Bonjour
from zeroconf import ServiceInfo, Zeroconf

info = ServiceInfo(
    "_acp._tcp.local.",
    "agent-sensor-1._acp._tcp.local.",
    addresses=["192.168.1.100"],
    port=8080,
    properties={
        "capabilities": "temperature,humidity",
        "version": "1.0.0"
    }
)

zeroconf = Zeroconf()
zeroconf.register_service(info)

# Other agents discover automatically
from zeroconf import ServiceBrowser

class AgentListener:
    def add_service(self, zeroconf, type, name):
        info = zeroconf.get_service_info(type, name)
        print(f"Discovered agent: {name}")
        print(f"Capabilities: {info.properties[b'capabilities']}")

browser = ServiceBrowser(zeroconf, "_acp._tcp.local.", AgentListener())
```

### Asynchronous Streaming

```typescript
// Subscribe to agent updates
const eventSource = new EventSource("http://localhost:8080/v1/agents/sensor-1/stream");

eventSource.addEventListener("reading", (event) => {
	const data = JSON.parse(event.data);
	console.log("New sensor reading:", data);
});

eventSource.addEventListener("alert", (event) => {
	const alert = JSON.parse(event.data);
	console.log("ALERT:", alert);
});
```

### Implementation Example

**Home Automation System** (local, no cloud):

```python
from acp import Agent, Message

# Agent 1: Temperature Sensor
sensor = Agent(
    id="agent://temp-sensor",
    capabilities=["read_temperature"],
    transport="http",
    port=8081
)

@sensor.on_request("read_temperature")
async def read_temp(message):
    # Read from hardware
    temp = await hardware.read_temperature()

    # Inform controller
    await sensor.send(Message(
        performative="inform",
        receiver="agent://controller",
        content={
            "type": "temperature",
            "value": temp,
            "unit": "celsius"
        }
    ))

# Agent 2: Controller (Orchestrator)
controller = Agent(
    id="agent://controller",
    capabilities=["regulate_temperature"],
    transport="http",
    port=8082
)

@controller.on_inform("temperature")
async def handle_temp(message):
    temp = message.content["value"]

    if temp > 25:
        # Request AC to turn on
        await controller.send(Message(
            performative="request",
            receiver="agent://ac-unit",
            content={
                "action": "set_temperature",
                "target": 22
            }
        ))

# Agent 3: AC Unit
ac_unit = Agent(
    id="agent://ac-unit",
    capabilities=["set_temperature", "power_on", "power_off"],
    transport="http",
    port=8083
)

@ac_unit.on_request("set_temperature")
async def set_temp(message):
    target = message.content["target"]

    # Control hardware
    await hardware.set_ac_temperature(target)

    # Confirm action
    await ac_unit.send(Message(
        performative="confirm",
        receiver=message.sender,
        replyTo=message.id,
        content={
            "status": "success",
            "current_temperature": target
        }
    ))

# Run all agents locally (no internet required)
await asyncio.gather(
    sensor.run(),
    controller.run(),
    ac_unit.run()
)
```

### Robotics Example

**Multi-Robot Coordination**:

```python
# Robot 1: Scout
scout = Agent("agent://scout-robot-1", transport="zeromq")

@scout.periodic(interval=5.0)  # Every 5 seconds
async def scan_area():
    obstacles = await lidar.scan()

    if obstacles:
        # Inform all robots via broadcast
        await scout.broadcast(Message(
            performative="inform",
            content={
                "type": "obstacle_detected",
                "location": await gps.get_location(),
                "obstacles": obstacles
            }
        ))

# Robot 2: Worker
worker = Agent("agent://worker-robot-1", transport="zeromq")

@worker.on_inform("obstacle_detected")
async def handle_obstacle(message):
    obstacle_location = message.content["location"]
    my_location = await gps.get_location()

    if distance(my_location, obstacle_location) < 10:  # Within 10m
        # Request alternate path
        await worker.send(Message(
            performative="request",
            receiver="agent://path-planner",
            content={
                "action": "compute_alternate_path",
                "avoid": obstacle_location
            }
        ))

# Path Planner Agent
planner = Agent("agent://path-planner", transport="zeromq")

@planner.on_request("compute_alternate_path")
async def plan_path(message):
    avoid_location = message.content["avoid"]

    # Compute safe path
    new_path = await pathfinding.compute(avoid=avoid_location)

    # Send proposal
    await planner.send(Message(
        performative="propose",
        receiver=message.sender,
        replyTo=message.id,
        content={
            "path": new_path,
            "estimated_time": new_path.duration,
            "energy_cost": new_path.energy
        }
    ))

# Worker accepts/rejects proposal
@worker.on_propose("compute_alternate_path")
async def evaluate_path(message):
    path = message.content["path"]

    if path.energy_cost < battery.remaining * 0.8:
        # Accept
        await worker.send(Message(
            performative="accept",
            receiver=message.sender,
            replyTo=message.replyTo
        ))

        # Update navigation
        await navigation.set_path(path)
    else:
        # Reject, insufficient energy
        await worker.send(Message(
            performative="reject",
            receiver=message.sender,
            replyTo=message.replyTo,
            content={
                "reason": "insufficient_energy"
            }
        ))
```

### Use Cases

**Ideal For**:

-   Edge computing environments
-   IoT device networks
-   Robotics coordination
-   Industrial automation
-   Smart home systems
-   Offline/air-gapped systems
-   Low-bandwidth scenarios
-   Privacy-sensitive applications

**Not Ideal For**:

-   Cross-organization collaboration (use A2A)
-   Cloud-native systems (use MCP/A2A)
-   Public agent marketplaces (use ANP)

---

## Agent Network Protocol (ANP)

### Overview

**Agent Network Protocol (ANP)** is an open-source framework for **decentralized agent networks**, enabling agents to discover, authenticate, and collaborate across the open internet without centralized intermediaries.

**Status**: Experimental (2024-2025)  
**Architecture**: Peer-to-peer (P2P)  
**Identity**: W3C Decentralized Identifiers (DIDs)  
**Discovery**: JSON-LD semantic descriptions

### Key Concepts

**Decentralized Identity**:

-   Each agent has a DID (e.g., `did:web:agent.example.com`)
-   Self-sovereign, no central authority
-   Verifiable credentials for trust

**Semantic Discovery**:

-   JSON-LD graphs describe capabilities
-   Agents query semantic knowledge base
-   Ontology-based matching

**Peer-to-Peer**:

-   Direct agent-to-agent connections
-   No registry bottleneck
-   Resilient to single points of failure

### Decentralized Identifiers (DIDs)

```json
{
	"@context": ["https://www.w3.org/ns/did/v1", "https://w3id.org/security/suites/ed25519-2020/v1"],
	"id": "did:web:agent.example.com",
	"verificationMethod": [
		{
			"id": "did:web:agent.example.com#key-1",
			"type": "Ed25519VerificationKey2020",
			"controller": "did:web:agent.example.com",
			"publicKeyMultibase": "z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH"
		}
	],
	"authentication": ["did:web:agent.example.com#key-1"],
	"service": [
		{
			"id": "did:web:agent.example.com#agent-endpoint",
			"type": "AgentService",
			"serviceEndpoint": "https://agent.example.com/api"
		}
	]
}
```

### JSON-LD Agent Description

```json
{
	"@context": {
		"@vocab": "https://schema.org/",
		"anp": "https://anp.org/vocab#"
	},
	"@type": "anp:Agent",
	"@id": "did:web:agent.example.com",
	"name": "Research Assistant",
	"description": "AI agent specializing in academic research",
	"anp:capabilities": [
		{
			"@type": "anp:Capability",
			"name": "literature_search",
			"description": "Search academic databases for papers",
			"input": {
				"@type": "schema:Query",
				"properties": {
					"topic": "string",
					"fromYear": "integer",
					"maxResults": "integer"
				}
			},
			"output": {
				"@type": "schema:ItemList",
				"itemListElement": {
					"@type": "schema:ScholarlyArticle"
				}
			}
		}
	],
	"anp:trustScore": 0.92,
	"anp:verifiedBy": ["did:web:verifier.research.org"]
}
```

### Discovery via SPARQL

```sparql
PREFIX anp: <https://anp.org/vocab#>
PREFIX schema: <https://schema.org/>

SELECT ?agent ?name ?capability
WHERE {
  ?agent a anp:Agent ;
         schema:name ?name ;
         anp:capabilities ?cap .

  ?cap anp:name ?capability ;
       anp:domain "academic_research" .

  FILTER (?agent IN (SELECT ?a WHERE {
    ?a anp:trustScore ?score .
    FILTER (?score > 0.8)
  }))
}
```

### Secure Communication

**End-to-End Encryption**:

```typescript
import { createDIDAuth, encryptMessage } from "anp-sdk";

// Agent A sends to Agent B
const agentA_DID = "did:web:agentA.example.com";
const agentB_DID = "did:web:agentB.example.com";

// Resolve Agent B's public key
const agentB_DIDDoc = await resolveDID(agentB_DID);
const agentB_PublicKey = agentB_DIDDoc.verificationMethod[0].publicKeyMultibase;

// Encrypt message
const plaintext = {
	type: "request",
	capability: "literature_search",
	params: {
		topic: "quantum computing",
		fromYear: 2023,
	},
};

const encrypted = await encryptMessage(
	plaintext,
	agentB_PublicKey,
	agentA_DID // Signature
);

// Send via P2P network
await p2p.send(agentB_DID, encrypted);
```

### Reputation System

```typescript
{
  "@context": "https://anp.org/vocab#",
  "@type": "ReputationScore",
  "agent": "did:web:agent.example.com",
  "overallScore": 0.92,
  "components": {
    "reliability": 0.95,  // Task completion rate
    "accuracy": 0.89,     // Output quality
    "responsiveness": 0.93,  // Response time
    "trustworthiness": 0.91  // Community trust votes
  },
  "reviewCount": 847,
  "verifications": [
    {
      "verifier": "did:web:certifier.org",
      "type": "IdentityVerification",
      "timestamp": "2025-10-15T12:00:00Z"
    }
  ]
}
```

### Use Cases

**Agent Marketplaces**:

-   Freelance AI agents offering services
-   Decentralized discovery without platform lock-in
-   Reputation-based selection

**Cross-Organization Collaboration**:

-   Academic research networks
-   Healthcare data sharing (HIPAA-compliant)
-   Supply chain coordination

**Autonomous Ecosystems**:

-   Self-organizing agent societies
-   Emergent collaboration networks
-   DAO-governed agent collectives

### Limitations (2025)

**Experimental Status**: Not production-ready  
**Complexity**: DID/JSON-LD learning curve  
**Performance**: P2P discovery slower than centralized  
**Tooling**: Limited SDK support  
**Adoption**: Low (mostly research/academic)

---

## Protocol Comparison

### Quick Reference Matrix

| Feature              | MCP            | A2A                        | ACP                | ANP                  |
| -------------------- | -------------- | -------------------------- | ------------------ | -------------------- |
| **Primary Use**      | LLM ↔ Tools    | Agent ↔ Agent              | Local Messaging    | Network Discovery    |
| **Architecture**     | Client-Server  | Peer-to-Peer               | Flexible           | Decentralized        |
| **Transport**        | JSON-RPC, HTTP | JSON-RPC, HTTP, SSE        | HTTP, gRPC, ZeroMQ | P2P, DID             |
| **Discovery**        | Manual config  | Registry + Direct          | mDNS / Local       | Semantic / SPARQL    |
| **Authentication**   | OAuth 2.0      | OAuth 2.0, API Key         | Flexible           | DID + VC             |
| **Multimodal**       | Text, Images   | Text, Audio, Video, Files  | MIME multi-part    | JSON-LD              |
| **State Management** | Stateless      | Stateful (tasks, sessions) | Event-driven       | Reputation-based     |
| **Latency**          | Low-Medium     | Medium                     | Very Low           | High (P2P discovery) |
| **Deployment**       | Cloud / Local  | Cloud / Cross-org          | Edge / Local       | Global network       |
| **Maturity**         | Production     | Production                 | Emerging           | Experimental         |
| **Adoption**         | High           | Medium-High                | Medium             | Low                  |

### When to Use Each Protocol

```
┌─────────────────────────────────────────────────┐
│               Decision Tree                     │
└─────────────────────────────────────────────────┘

Need to connect LLM to external tools/data?
├─ Yes → Use MCP
│   └─ Examples: GitHub integration, database queries,
│      web search, file system access
│
Need agents from different orgs to collaborate?
├─ Yes → Use A2A
│   └─ Examples: Multi-vendor workflows, cross-platform
│      task delegation, enterprise integration
│
Building local/edge multi-agent system?
├─ Yes → Use ACP
│   └─ Examples: Robotics, IoT, smart home, offline
│      systems, low-latency requirements
│
Need decentralized agent marketplace?
├─ Yes → Use ANP (experimental)
│   └─ Examples: Public agent networks, zero-trust
│      collaboration, reputation-based discovery
│
Hybrid Requirements?
└─ Combine protocols with middleware/bridges
    Example: MCP for tool access + A2A for agent collaboration
```

### Performance Characteristics

| Metric                 | MCP             | A2A       | ACP       | ANP       |
| ---------------------- | --------------- | --------- | --------- | --------- |
| **Latency (typical)**  | 50-200ms        | 100-500ms | 10-50ms   | 500ms-5s  |
| **Throughput**         | High            | Medium    | Very High | Low       |
| **Scalability**        | Excellent       | Excellent | Good      | Moderate  |
| **Offline Support**    | Partial (stdio) | No        | Yes       | Partial   |
| **Cross-org Security** | Good            | Excellent | Limited   | Excellent |

### Interoperability

**Can these protocols work together?** Yes, through bridges:

```typescript
// MCP + A2A Bridge
class MCPToA2ABridge {
	constructor(private mcpClient: MCPClient, private a2aAgent: A2AAgent) {}

	async init() {
		// Expose MCP tools as A2A capabilities
		const tools = await this.mcpClient.listTools();

		for (const tool of tools) {
			this.a2aAgent.registerCapability({
				name: tool.name,
				description: tool.description,
				inputSchema: tool.inputSchema,
			});
		}
	}

	async handleA2ARequest(message: A2AMessage) {
		// Translate A2A request to MCP tool call
		const result = await this.mcpClient.callTool({
			name: message.capability,
			arguments: message.params,
		});

		// Return via A2A
		return {
			content: result.content,
			artifacts: result.artifacts,
		};
	}
}

// Usage
const bridge = new MCPToA2ABridge(mcpClient, a2aAgent);
await bridge.init();

// Now A2A agents can invoke MCP tools
```

---

## Implementation Patterns

### Pattern 1: Tool Access (MCP)

**Use Case**: Give Claude access to GitHub repositories.

```python
from mcp.server import Server
from github import Github

server = Server("github-mcp-server")
gh = Github(os.getenv("GITHUB_TOKEN"))

@server.list_tools()
async def list_tools():
    return [
        Tool(
            name="search_repos",
            description="Search GitHub repositories",
            inputSchema={
                "type": "object",
                "properties": {
                    "query": {"type": "string"},
                    "language": {"type": "string"},
                    "sort": {"type": "string", "enum": ["stars", "forks", "updated"]}
                },
                "required": ["query"]
            }
        ),
        Tool(
            name="get_repo_info",
            description="Get detailed repository information",
            inputSchema={
                "type": "object",
                "properties": {
                    "owner": {"type": "string"},
                    "repo": {"type": "string"}
                },
                "required": ["owner", "repo"]
            }
        ),
        Tool(
            name="create_issue",
            description="Create an issue in a repository",
            inputSchema={
                "type": "object",
                "properties": {
                    "owner": {"type": "string"},
                    "repo": {"type": "string"},
                    "title": {"type": "string"},
                    "body": {"type": "string"}
                },
                "required": ["owner", "repo", "title"]
            }
        )
    ]

@server.call_tool()
async def call_tool(name: str, arguments: dict):
    if name == "search_repos":
        query = arguments["query"]
        language = arguments.get("language")
        sort = arguments.get("sort", "stars")

        search_query = query
        if language:
            search_query += f" language:{language}"

        repos = gh.search_repositories(search_query, sort=sort)

        results = []
        for repo in repos[:10]:  # Top 10
            results.append({
                "name": repo.full_name,
                "description": repo.description,
                "stars": repo.stargazers_count,
                "url": repo.html_url
            })

        return {
            "content": [
                {
                    "type": "text",
                    "text": f"Found {len(results)} repositories:\n" +
                           "\n".join([f"- {r['name']} ({r['stars']}⭐): {r['description']}"
                                     for r in results])
                }
            ]
        }

    elif name == "get_repo_info":
        owner = arguments["owner"]
        repo_name = arguments["repo"]

        repo = gh.get_repo(f"{owner}/{repo_name}")

        return {
            "content": [
                {
                    "type": "text",
                    "text": f"""Repository: {repo.full_name}
Description: {repo.description}
Stars: {repo.stargazers_count}
Forks: {repo.forks_count}
Open Issues: {repo.open_issues_count}
Language: {repo.language}
Last Updated: {repo.updated_at}
URL: {repo.html_url}"""
                }
            ]
        }

    elif name == "create_issue":
        owner = arguments["owner"]
        repo_name = arguments["repo"]
        title = arguments["title"]
        body = arguments["body"]

        repo = gh.get_repo(f"{owner}/{repo_name}")
        issue = repo.create_issue(title=title, body=body)

        return {
            "content": [
                {
                    "type": "text",
                    "text": f"Created issue #{issue.number}: {issue.html_url}"
                }
            ]
        }

if __name__ == "__main__":
    server.run()
```

---

### Pattern 2: Agent Collaboration (A2A)

**Use Case**: Research agent delegates tasks to specialist agents.

```typescript
import { A2AAgent, AgentCard, Task } from "a2a-sdk";

// Research Coordinator Agent
const coordinatorCard: AgentCard = {
	id: "agent://research-coordinator",
	name: "Research Coordinator",
	capabilities: [
		{
			name: "coordinate_research",
			description: "Orchestrate multi-agent research workflow",
			inputSchema: {
				type: "object",
				properties: {
					topic: { type: "string" },
					depth: { type: "string", enum: ["shallow", "moderate", "comprehensive"] },
				},
			},
		},
	],
	endpoints: {
		jsonRpc: "https://coordinator.research.ai/rpc",
	},
};

const coordinator = new A2AAgent(coordinatorCard);

coordinator.onCapability("coordinate_research", async (request) => {
	const { topic, depth } = request.params;

	// Create task
	const task = await coordinator.createTask({
		title: `Research: ${topic}`,
		description: `${depth} research on ${topic}`,
	});

	// Step 1: Literature search
	const litSearchResponse = await coordinator.sendMessage({
		to: "agent://literature-searcher",
		content: [
			{
				type: "text",
				text: `Find academic papers on ${topic} from 2023-2025`,
			},
		],
		taskId: task.id,
	});

	const papers = litSearchResponse.artifacts[0].data;

	// Step 2: Concurrent analysis
	const analyses = await Promise.all([
		// Methodology analysis
		coordinator.sendMessage({
			to: "agent://methodology-analyst",
			content: [
				{
					type: "text",
					text: `Analyze research methodologies in these papers`,
				},
			],
			artifacts: [{ type: "structured", data: papers }],
			taskId: task.id,
		}),

		// Trend analysis
		coordinator.sendMessage({
			to: "agent://trend-analyst",
			content: [
				{
					type: "text",
					text: `Identify emerging trends from these papers`,
				},
			],
			artifacts: [{ type: "structured", data: papers }],
			taskId: task.id,
		}),

		// Citation analysis
		coordinator.sendMessage({
			to: "agent://citation-analyst",
			content: [
				{
					type: "text",
					text: `Analyze citation networks`,
				},
			],
			artifacts: [{ type: "structured", data: papers }],
			taskId: task.id,
		}),
	]);

	// Step 3: Synthesis
	const synthesisResponse = await coordinator.sendMessage({
		to: "agent://research-writer",
		content: [
			{
				type: "text",
				text: `Synthesize research findings into comprehensive report`,
			},
		],
		artifacts: [
			{ type: "structured", data: papers },
			{ type: "structured", data: analyses[0].artifacts[0].data },
			{ type: "structured", data: analyses[1].artifacts[0].data },
			{ type: "structured", data: analyses[2].artifacts[0].data },
		],
		taskId: task.id,
	});

	// Mark task complete
	await coordinator.updateTask(task.id, {
		status: "completed",
		progress: 1.0,
	});

	return {
		content: synthesisResponse.content,
		artifacts: synthesisResponse.artifacts,
	};
});

// Specialist Agents

// Literature Searcher
const literatureSearcher = new A2AAgent({
	id: "agent://literature-searcher",
	name: "Literature Searcher",
	capabilities: [{ name: "search_papers" }],
});

literatureSearcher.onMessage(async (message) => {
	// Search academic databases
	const papers = await searchSemanticScholar(message.content[0].text);

	return {
		content: [
			{
				type: "text",
				text: `Found ${papers.length} relevant papers`,
			},
		],
		artifacts: [
			{
				type: "structured",
				data: papers,
			},
		],
	};
});

// Methodology Analyst
const methodologyAnalyst = new A2AAgent({
	id: "agent://methodology-analyst",
	name: "Methodology Analyst",
	capabilities: [{ name: "analyze_methodologies" }],
});

methodologyAnalyst.onMessage(async (message) => {
	const papers = message.artifacts[0].data;

	// Analyze methodologies using LLM
	const analysis = await llm.analyze({
		prompt: `Analyze research methodologies in these papers: ${JSON.stringify(papers)}`,
	});

	return {
		content: [
			{
				type: "text",
				text: analysis.summary,
			},
		],
		artifacts: [
			{
				type: "structured",
				data: {
					methodologies: analysis.methodologies,
					commonApproaches: analysis.commonApproaches,
					innovations: analysis.innovations,
				},
			},
		],
	};
});

// Start all agents
await Promise.all([
	coordinator.start(),
	literatureSearcher.start(),
	methodologyAnalyst.start(),
	// ... other agents
]);
```

---

### Pattern 3: Local Multi-Agent (ACP)

**Use Case**: Smart manufacturing with robots and sensors.

```python
from acp import Agent, Message
import asyncio

# Supervisor Agent
supervisor = Agent(
    id="agent://factory-supervisor",
    capabilities=["assign_tasks", "monitor_production"],
    transport="http",
    port=8080
)

@supervisor.periodic(interval=10.0)
async def monitor_production():
    # Request status from all robots
    await supervisor.broadcast(Message(
        performative="query",
        content={
            "query": "current_status"
        }
    ))

@supervisor.on_inform("production_complete")
async def handle_production_complete(message):
    robot_id = message.sender
    product_id = message.content["product_id"]

    # Log completion
    await database.log_production(robot_id, product_id)

    # Request quality inspection
    await supervisor.send(Message(
        performative="request",
        receiver="agent://quality-inspector",
        content={
            "action": "inspect",
            "product_id": product_id
        }
    ))

# Robot Agent
robot1 = Agent(
    id="agent://robot-1",
    capabilities=["assemble", "weld", "move"],
    transport="http",
    port=8081
)

@robot1.on_request("assemble")
async def assemble_product(message):
    product_spec = message.content["specification"]

    # Execute assembly
    result = await hardware.assemble(product_spec)

    # Inform supervisor
    await robot1.send(Message(
        performative="inform",
        receiver="agent://factory-supervisor",
        content={
            "type": "production_complete",
            "product_id": result.product_id,
            "quality_metrics": result.metrics
        }
    ))

@robot1.on_query("current_status")
async def report_status(message):
    status = await hardware.get_status()

    await robot1.send(Message(
        performative="inform",
        receiver=message.sender,
        replyTo=message.id,
        content={
            "status": status.state,
            "current_task": status.task,
            "battery": status.battery,
            "location": status.position
        }
    ))

# Quality Inspector Agent
inspector = Agent(
    id="agent://quality-inspector",
    capabilities=["inspect", "certify"],
    transport="http",
    port=8082
)

@inspector.on_request("inspect")
async def inspect_product(message):
    product_id = message.content["product_id"]

    # Run inspection
    inspection_result = await vision_system.inspect(product_id)

    if inspection_result.passed:
        # Certify product
        await inspector.send(Message(
            performative="inform",
            receiver="agent://factory-supervisor",
            content={
                "type": "inspection_passed",
                "product_id": product_id,
                "certification": inspection_result.certificate
            }
        ))
    else:
        # Request rework
        await inspector.send(Message(
            performative="request",
            receiver="agent://robot-1",
            content={
                "action": "rework",
                "product_id": product_id,
                "issues": inspection_result.defects
            }
        ))

# Sensor Agent (temperature monitoring)
temp_sensor = Agent(
    id="agent://temp-sensor-1",
    capabilities=["monitor_temperature"],
    transport="http",
    port=8083
)

@temp_sensor.periodic(interval=5.0)
async def read_temperature():
    temp = await hardware.read_temperature()

    if temp > 80:  # Threshold
        # Alert supervisor
        await temp_sensor.send(Message(
            performative="inform",
            receiver="agent://factory-supervisor",
            content={
                "type": "temperature_alert",
                "value": temp,
                "severity": "high" if temp > 90 else "medium"
            }
        ))

# Run all agents (no internet needed)
await asyncio.gather(
    supervisor.run(),
    robot1.run(),
    inspector.run(),
    temp_sensor.run()
)
```

---

## Message Formats

### JSON-RPC 2.0 (MCP, A2A)

**Request**:

```json
{
	"jsonrpc": "2.0",
	"method": "tools/call",
	"params": {
		"name": "search_web",
		"arguments": {
			"query": "agent protocols 2025"
		}
	},
	"id": 1
}
```

**Success Response**:

```json
{
	"jsonrpc": "2.0",
	"result": {
		"content": [
			{
				"type": "text",
				"text": "Found 10 results..."
			}
		]
	},
	"id": 1
}
```

**Error Response**:

```json
{
	"jsonrpc": "2.0",
	"error": {
		"code": -32602,
		"message": "Invalid params",
		"data": {
			"param": "query",
			"reason": "missing required parameter"
		}
	},
	"id": 1
}
```

### REST (ACP, A2A)

**Request**:

```http
POST /v1/message:send HTTP/1.1
Host: agent.example.com
Content-Type: application/json
Authorization: Bearer eyJhbG...

{
  "from": "agent://sender",
  "to": "agent://receiver",
  "message": {
    "role": "user",
    "content": [
      {
        "type": "text",
        "text": "Execute analysis"
      }
    ]
  }
}
```

**Response**:

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "messageId": "msg-12345",
  "status": "delivered",
  "timestamp": "2025-11-17T10:00:00Z"
}
```

### Performative Messages (ACP)

```json
{
	"performative": "request",
	"sender": "agent://controller",
	"receiver": "agent://executor",
	"content": {
		"action": "process_data",
		"dataset": "dataset-456"
	},
	"conversationId": "conv-789",
	"replyTo": null,
	"ontology": "manufacturing-v2",
	"language": "json"
}
```

---

## Security Considerations

### Authentication

**OAuth 2.0** (MCP, A2A):

```typescript
// Obtain token
const token = await oauth2.getToken({
  clientId: 'agent-client-id',
  clientSecret: 'secret',
  scopes: ['read:tools', 'execute:tools']
});

// Use in requests
fetch('https://server/mcp/tools/call', {
  headers: {
    'Authorization': `Bearer ${token.accessToken}`
  },
  body: JSON.stringify({...})
});
```

**API Keys** (MCP, A2A):

```typescript
fetch("https://server/api/message:send", {
	headers: {
		"X-API-Key": "your-api-key-here",
	},
});
```

**DIDs** (ANP):

```typescript
// Sign message with DID
const signed = await didAuth.sign(message, myDID);

// Verify sender
const verified = await didAuth.verify(signed, senderDID);
```

### Authorization

**Capability-Based** (A2A):

```json
{
	"authorization": {
		"scopes": ["decompose_task", "estimate_effort"],
		"denied": ["execute_code", "access_secrets"]
	}
}
```

**Role-Based** (ACP):

```json
{
	"roles": ["sensor", "data_provider"],
	"permissions": {
		"can_read": ["temperature", "humidity"],
		"can_write": [],
		"can_execute": []
	}
}
```

### Encryption

**TLS/HTTPS** (All Protocols):

```typescript
// Enforce HTTPS
const server = https.createServer(
	{
		key: fs.readFileSync("private-key.pem"),
		cert: fs.readFileSync("certificate.pem"),
	},
	app
);
```

**End-to-End** (ANP):

```typescript
// Encrypt with recipient's public key
const encrypted = await crypto.encrypt(message, recipientPublicKey);

// Sign with sender's private key
const signed = await crypto.sign(encrypted, senderPrivateKey);
```

### Best Practices

1. **Principle of Least Privilege**: Grant minimum necessary permissions
2. **User Consent**: Always obtain approval for tool execution
3. **Input Validation**: Sanitize all inputs to prevent injection
4. **Rate Limiting**: Prevent abuse with request throttling
5. **Audit Logging**: Track all agent actions for compliance
6. **Secrets Management**: Never hardcode credentials
7. **Regular Updates**: Keep SDKs and dependencies current

---

## Phased Adoption Roadmap

Based on comparative analysis from Kent State University (2025):

### Stage 1: MCP for Tool Access

**Goal**: Connect LLM to essential tools and data.

**Implementation**:

```python
# Local development
- Install MCP server (GitHub, Slack, database)
- Test with Claude Desktop
- Verify tool calling works

# Production deployment
- Deploy MCP servers to cloud
- Configure HTTP + SSE transport
- Add authentication
- Monitor usage
```

**Success Criteria**:

-   LLM can access 3+ external systems
-   Tool calls complete in <2 seconds
-   95%+ success rate

---

### Stage 2: ACP for Local Communication

**Goal**: Enable local multi-agent messaging.

**Implementation**:

```python
# Agent development
- Define agent capabilities
- Implement performative messaging
- Add local discovery

# Integration
- Connect to MCP tools
- Test multi-agent workflows
- Optimize latency (<50ms)
```

**Success Criteria**:

-   5+ agents communicate locally
-   Latency <50ms
-   Offline operation works

---

### Stage 3: A2A for Cross-Org Collaboration

**Goal**: Enable agents to collaborate across organizations.

**Implementation**:

```python
# Agent Cards
- Create Agent Cards for all agents
- Implement capability discovery
- Add task management

# Cross-org testing
- Partner with external agents
- Test long-running tasks
- Implement streaming updates
```

**Success Criteria**:

-   Agents discover each other
-   Cross-org tasks complete successfully
-   Multimodal messages supported

---

### Stage 4: ANP for Decentralized Networks (Future)

**Goal**: Participate in open agent networks.

**Implementation**:

```python
# Experimental phase
- Create DID for agents
- Publish JSON-LD descriptions
- Join P2P network
- Build reputation
```

**Success Criteria**:

-   DID resolution works
-   Agents discoverable via SPARQL
-   Reputation score >0.8

---

## Production Best Practices

### 1. Protocol Selection

```python
def select_protocol(requirements):
    """Choose protocol based on requirements."""
    if requirements.need_tool_access:
        return "MCP"
    elif requirements.cross_organization:
        return "A2A"
    elif requirements.local_only:
        return "ACP"
    elif requirements.decentralized:
        return "ANP"
    else:
        # Combine protocols
        return ["MCP", "A2A"]
```

### 2. Error Handling

```typescript
async function robustProtocolCall(protocol, method, params) {
	const maxRetries = 3;
	let attempt = 0;

	while (attempt < maxRetries) {
		try {
			const result = await protocol.call(method, params);
			return result;
		} catch (error) {
			if (error.code === "RATE_LIMIT") {
				// Exponential backoff
				await sleep(Math.pow(2, attempt) * 1000);
				attempt++;
			} else if (error.code === "AUTH_EXPIRED") {
				// Refresh token
				await protocol.refreshAuth();
				attempt++;
			} else {
				// Non-retryable error
				throw error;
			}
		}
	}

	throw new Error("Max retries exceeded");
}
```

### 3. Monitoring

```python
from prometheus_client import Counter, Histogram

protocol_calls = Counter(
    'protocol_calls_total',
    'Total protocol calls',
    ['protocol', 'method', 'status']
)

protocol_latency = Histogram(
    'protocol_latency_seconds',
    'Protocol call latency',
    ['protocol', 'method']
)

async def monitored_call(protocol, method, params):
    with protocol_latency.labels(protocol=protocol.name, method=method).time():
        try:
            result = await protocol.call(method, params)
            protocol_calls.labels(
                protocol=protocol.name,
                method=method,
                status='success'
            ).inc()
            return result
        except Exception as e:
            protocol_calls.labels(
                protocol=protocol.name,
                method=method,
                status='error'
            ).inc()
            raise
```

### 4. Testing

```typescript
describe("MCP Server", () => {
	it("should list tools", async () => {
		const response = await mcpClient.request({
			method: "tools/list",
		});

		expect(response.result.tools).toBeInstanceOf(Array);
		expect(response.result.tools.length).toBeGreaterThan(0);
	});

	it("should call tool successfully", async () => {
		const response = await mcpClient.request({
			method: "tools/call",
			params: {
				name: "search_web",
				arguments: { query: "test" },
			},
		});

		expect(response.result.content).toBeDefined();
	});

	it("should handle errors gracefully", async () => {
		await expect(
			mcpClient.request({
				method: "tools/call",
				params: {
					name: "nonexistent_tool",
					arguments: {},
				},
			})
		).rejects.toThrow("Tool not found");
	});
});
```

---

## References

### Specifications

1. **Model Context Protocol (MCP)** - Anthropic  
   [https://modelcontextprotocol.io/specification/2025-06-18](https://modelcontextprotocol.io/specification/2025-06-18)

2. **Agent2Agent Protocol (A2A)** - Google  
   [https://a2a-protocol.org/latest/specification/](https://a2a-protocol.org/latest/specification/)

3. **Agent Communication Protocol (ACP)** - Linux Foundation  
   [https://acp-spec.org](https://acp-spec.org) _(fictional URL for reference)_

4. **Agent Network Protocol (ANP)** - Open Source  
   [https://agent-network-protocol.com](https://agent-network-protocol.com)

### Research Papers

5. **"A Survey of Agent Interoperability Protocols"** (arXiv, May 2025)  
   [https://arxiv.org/abs/2505.02279](https://arxiv.org/abs/2505.02279)  
   Comprehensive comparison of MCP, A2A, ACP, ANP

6. **"A Survey of AI Agent Protocols"** (arXiv, April 2025)  
   [https://arxiv.org/abs/2504.16736](https://arxiv.org/abs/2504.16736)  
   Classification and comparative analysis

7. **"Framework, Use Cases and Requirements for AI Agent Protocols"** (IETF, October 2025)  
   [https://datatracker.ietf.org/doc/html/draft-rosenberg-aiproto-framework](https://datatracker.ietf.org/doc/html/draft-rosenberg-aiproto-framework)

### Industry Articles

8. **"8 Key Agentic Protocols Driving LLM & AI Agent Communication (2025)"** (Medium)  
   [https://medium.com/@billxu_atoms/8-protocols-competing-to-be-the-language](https://medium.com/@billxu_atoms/8-protocols-competing-to-be-the-language)

9. **"Agent Communication Protocols Explained"** (DigitalOcean, November 2025)  
   [https://www.digitalocean.com/community/tutorials/agent-communication-protocols](https://www.digitalocean.com/community/tutorials/agent-communication-protocols)

10. **"The Future of AI Agent Communication with ACP"** (Towards Data Science, July 2025)  
    [https://towardsdatascience.com/the-future-of-ai-agent-communication-with-acp/](https://towardsdatascience.com/the-future-of-ai-agent-communication-with-acp/)

11. **"AI Agent Communication Protocols – MCP, A2A, AGP, and ACP"** (LinkedIn, July 2025)  
    [https://www.linkedin.com/pulse/ai-agent-communication-protocols](https://www.linkedin.com/pulse/ai-agent-communication-protocols)

### Announcements & Adoption

12. **"Introducing the Model Context Protocol"** (Anthropic, November 2024)  
    [https://www.anthropic.com/news/model-context-protocol](https://www.anthropic.com/news/model-context-protocol)

13. **"Model Context Protocol - Wikipedia"** (Updated April 2025)  
    [https://en.wikipedia.org/wiki/Model_Context_Protocol](https://en.wikipedia.org/wiki/Model_Context_Protocol)

14. **"Anthropic Publishes Model Context Protocol Specification"** (InfoQ, December 2024)  
    [https://www.infoq.com/news/2024/12/anthropic-model-context-protocol/](https://www.infoq.com/news/2024/12/anthropic-model-context-protocol/)

15. **"Focus on Anthropic's MCP Protocol, Which OpenAI Is Adopting"** (AI Quantum Computing, April 2025)  
    [https://aiquantumcomputing.substack.com/p/focus-on-anthropics-mcp-protocol](https://aiquantumcomputing.substack.com/p/focus-on-anthropics-mcp-protocol)

### Technical Deep Dives

16. **"Building Standardized AI Tools with the Model Context Protocol"** (INNOQ, March 2025)  
    [https://www.innoq.com/en/articles/2025/03/model-context-protocol/](https://www.innoq.com/en/articles/2025/03/model-context-protocol/)

17. **"MCP: what is it, why it matters, and why caution is warranted in 2025"** (Redocly)  
    [https://redocly.com/blog/mcp](https://redocly.com/blog/mcp)

18. **"Protocols for Inter-Agent Message Exchange"** (APXML Courses, July 2024)  
    [https://apxml.com/courses/multi-agent-llm-systems-design-implementation](https://apxml.com/courses/multi-agent-llm-systems-design-implementation)

### Comparisons

19. **"A2A vs ACP Protocol Comparison Analysis Report"** (July 2025)  
    [https://a2aprotocol.ai/blog/a2a-acp](https://a2aprotocol.ai/blog/a2a-acp)

20. **"Agentic AI Protocols Comparison: MCP vs A2A vs ACP vs ANP"** (K21Academy)  
    [https://k21academy.com/ai-ml/agentic-ai/agentic-ai-protocols-comparison/](https://k21academy.com/ai-ml/agentic-ai/agentic-ai-protocols-comparison/)

### Community Resources

21. **Model Context Protocol GitHub**  
    [https://github.com/modelcontextprotocol](https://github.com/modelcontextprotocol)

22. **A2A Protocol Documentation**  
    [https://a2aprotocol.ai/docs/](https://a2aprotocol.ai/docs/)

23. **Agent Network Protocol Blog**  
    [https://agent-network-protocol.com/blogs/posts/agent-communication-protocols](https://agent-network-protocol.com/blogs/posts/agent-communication-protocols)

---

## Summary

Agent communication protocols emerged in 2024-2025 to solve the **M×N integration problem**, transforming fragmented custom integrations into standardized M+N architectures. Four major protocols address distinct needs:

**MCP (Model Context Protocol)**: Production-ready standard for LLM ↔ tool/data integration. Adopted by OpenAI, Google DeepMind, Anthropic, Microsoft. JSON-RPC client-server architecture with 100+ reference servers and 500+ community implementations.

**A2A (Agent2Agent)**: Google-led protocol for cross-vendor agent collaboration. Peer-to-peer task management with Agent Cards for capability discovery. Supports multimodal communication (text, audio, video) and long-running stateful workflows.

**ACP (Agent Communication Protocol)**: Linux Foundation standard for local/edge multi-agent systems. REST-native with flexible transport (HTTP, gRPC, ZeroMQ). Optimized for low-latency, offline-capable, privacy-focused applications like robotics and IoT.

**ANP (Agent Network Protocol)**: Experimental decentralized network protocol using W3C DIDs and JSON-LD. Enables trustless agent discovery and collaboration across open networks without centralized registries.

**Phased Adoption Roadmap**: Start with MCP for tool access (weeks 1-4), add ACP for local messaging (weeks 5-8), scale to A2A for cross-org collaboration (weeks 9-16), eventually experiment with ANP for decentralized networks.

These protocols reduce integration complexity from O(M×N) to O(M+N), enable vendor-independent agent ecosystems, and provide consistent security models. Production deployments should prioritize MCP and A2A (both production-ready), consider ACP for edge use cases, and monitor ANP as it matures.

**Next Steps**:

-   3.1.5 State Management Across Agents (advanced patterns)
-   3.2.1 Memory Systems (long-term persistence)
