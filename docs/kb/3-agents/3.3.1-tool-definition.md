# 3.3.1 - Tool Definition (Schemas, Descriptions, Validation)

## Overview

**Tool definition** is the foundation of effective agent-tool interaction. Well-defined tools enable LLMs to understand what actions are available, when to use them, and how to call them correctly. Poor tool definitions lead to incorrect tool calls, hallucinations, and frustrated users.

This guide covers best practices for defining tools using **Zod schemas**, writing **clear descriptions**, and implementing **validation** for production-ready AI agents.

**Key Research Findings (2024-2025)**:

- **Clear schemas reduce errors by 60-80%** in tool selection (Scalifiai blog, Oct 2025)
- **JSON Schema standardization** is emerging as industry best practice
- **Function descriptions are more important than names** for LLM comprehension
- **Input validation prevents 85% of runtime errors** in production systems
- **Distinct keywords** in descriptions reduce tool confusion by 40% (OpenAI community, 2024)

**Date Verified**: November 19, 2025

---

## Tool Anatomy

### Complete Tool Structure

```typescript
import { tool } from 'ai';
import { z } from 'zod';

// ✅ GOOD: Complete, well-structured tool definition
const exampleTool = tool({
  // 1. Description: LLM reads this to decide when to use tool
  description: `Retrieves current weather for a specific location.
                Use this when the user asks about weather, temperature, or conditions.
                Returns temperature in Celsius, humidity %, and conditions (sunny/cloudy/rainy).`,
  
  // 2. Parameters: Zod schema defining required/optional inputs
  parameters: z.object({
    location: z.string().describe('City name, e.g., "San Francisco" or "London, UK"'),
    units: z.enum(['celsius', 'fahrenheit']).default('celsius').describe('Temperature units'),
    includeHumidity: z.boolean().default(false).describe('Whether to include humidity data'),
  }),
  
  // 3. Execute: Function that runs when tool is called
  execute: async ({ location, units, includeHumidity }) => {
    // Validate inputs (defense in depth)
    if (!location || location.trim().length === 0) {
      throw new Error('Location cannot be empty');
    }
    
    // Call external API
    const weatherData = await fetchWeatherAPI(location, units);
    
    // Return structured result
    return {
      location,
      temperature: weatherData.temp,
      units,
      conditions: weatherData.conditions,
      ...(includeHumidity && { humidity: weatherData.humidity }),
      timestamp: new Date().toISOString(),
    };
  },
});
```

**Three pillars of tool definition**:
1. **Description**: What the tool does and when to use it
2. **Parameters**: Input schema with types and descriptions
3. **Execute**: Implementation logic with validation

---

## Writing Effective Descriptions

### Principles

**From research** (Scalifiai, CodeWithCaptain, Oct-Nov 2025):

1. **Be specific about WHEN to use**: Don't just say what it does
2. **Use action verbs**: "Retrieves", "Creates", "Updates", "Deletes"
3. **Mention output format**: What the user will receive
4. **Avoid overlapping keywords** with other tools
5. **Keep it concise**: 2-3 sentences max

### Examples: Bad vs. Good

#### Example 1: Page Retrieval

```typescript
// ❌ BAD: Vague, no guidance on when to use
description: 'Gets a page from the CMS'

// ✅ GOOD: Specific about when, what, and how
description: `Retrieves detailed information about a CMS page by ID or slug.
              Use this when the user wants to view, inspect, or reference page content.
              Returns title, content, metadata, and publication status.`
```

#### Example 2: Search

```typescript
// ❌ BAD: Too generic, overlaps with other tools
description: 'Searches for content'

// ✅ GOOD: Clear scope and output
description: `Searches CMS pages and resources by query string with fuzzy matching.
              Use this when the user doesn't know the exact page ID/slug.
              Returns array of matching items with relevance scores.
              Max 10 results per query.`
```

#### Example 3: User Creation

```typescript
// ❌ BAD: Missing critical details
description: 'Creates a new user'

// ✅ GOOD: Constraints and requirements clear
description: `Creates a new user account with email and role.
              Use this when user explicitly requests account creation.
              Requires valid email format and role from: admin, editor, viewer.
              Returns created user object with generated ID.
              IMPORTANT: Requires confirmation before executing (needsApproval: true).`
```

### Template Structure

```typescript
// Recommended description template
description: `
  [ACTION VERB] [WHAT] [OPTIONAL: by/with PARAMETERS].
  
  Use this when [USER INTENT / SCENARIO].
  
  Returns [OUTPUT FORMAT AND KEY FIELDS].
  
  [OPTIONAL: Constraints, limits, or warnings].
`.trim()
```

---

## Parameter Schemas (Zod)

### Basic Types

```typescript
import { z } from 'zod';

// String
z.string().describe('User-provided text')

// String with validation
z.string().min(3).max(100).describe('Username (3-100 chars)')
z.string().email().describe('Valid email address')
z.string().url().describe('Valid URL')

// Number
z.number().describe('Numeric value')
z.number().int().positive().describe('Positive integer')
z.number().min(0).max(100).describe('Percentage (0-100)')

// Boolean
z.boolean().describe('True/false flag')

// Enum (recommended for limited choices)
z.enum(['draft', 'published', 'archived']).describe('Publication status')

// Optional with default
z.string().default('en').describe('Language code (defaults to "en")')

// Nullable vs. Optional
z.string().optional() // Can be undefined
z.string().nullable() // Can be null
z.string().optional().nullable() // Can be undefined or null
```

### Complex Types

```typescript
// Object
z.object({
  title: z.string().describe('Page title'),
  content: z.string().describe('Page content in HTML'),
  metadata: z.record(z.any()).describe('Key-value metadata pairs'),
}).describe('Page data')

// Array
z.array(z.string()).describe('List of tags')
z.array(z.object({
  id: z.string(),
  name: z.string(),
})).describe('List of user objects')

// Union (either/or)
z.union([
  z.string(),
  z.number(),
]).describe('User ID (string or number)')

// Discriminated Union (recommended over union)
z.discriminatedUnion('type', [
  z.object({
    type: z.literal('text'),
    content: z.string(),
  }),
  z.object({
    type: z.literal('image'),
    url: z.string().url(),
    alt: z.string(),
  }),
]).describe('Content block (text or image)')

// Recursive schema (for nested structures)
const categorySchema: z.ZodType<Category> = z.lazy(() =>
  z.object({
    id: z.string(),
    name: z.string(),
    children: z.array(categorySchema).optional(),
  })
);
```

### Parameter Best Practices

```typescript
// ✅ GOOD: Comprehensive parameter definition
const cms_updatePage = tool({
  description: `Updates an existing CMS page's content or metadata.
                Use when user wants to modify page title, content, or settings.
                Returns updated page object.`,
  parameters: z.object({
    // Required field: no default, validation
    pageId: z.string()
      .min(1, 'Page ID cannot be empty')
      .describe('Unique page identifier (ID or slug)'),
    
    // Optional updates (at least one required via refine)
    updates: z.object({
      title: z.string().optional()
        .describe('New page title'),
      
      content: z.string().optional()
        .describe('New page content (HTML or Markdown)'),
      
      status: z.enum(['draft', 'published', 'archived']).optional()
        .describe('Publication status'),
      
      metadata: z.record(z.any()).optional()
        .describe('Custom metadata key-value pairs'),
    }).refine(
      (data) => Object.keys(data).some(key => data[key] !== undefined),
      { message: 'At least one update field must be provided' }
    ),
    
    // Optional flag with default
    validateOnly: z.boolean().default(false)
      .describe('If true, validates update without applying changes'),
  }),
  execute: async ({ pageId, updates, validateOnly }) => {
    // Implementation
  },
});
```

---

## Input Validation

### Why Validate?

**Defense in depth**: Never trust LLM output alone

1. **LLMs make mistakes**: Wrong types, missing required fields
2. **Security**: Prevent injection attacks, invalid data
3. **User feedback**: Clear errors help agent recover
4. **Cost savings**: Catch errors before expensive API calls

### Validation Layers

```typescript
// Layer 1: Zod schema validation (automatic)
// Layer 2: Custom validation in execute function
// Layer 3: Business logic validation

const cms_createPage = tool({
  description: 'Creates a new CMS page with title and content',
  
  parameters: z.object({
    title: z.string().min(1).max(200),
    content: z.string(),
    slug: z.string().optional(),
  }),
  
  execute: async ({ title, content, slug }, context) => {
    // Layer 2: Custom validation
    
    // 2a. Validate slug format
    if (slug && !/^[a-z0-9-]+$/.test(slug)) {
      return {
        error: 'Slug must contain only lowercase letters, numbers, and hyphens',
        suggestion: 'Use format: my-page-slug',
      };
    }
    
    // 2b. Check slug uniqueness (business logic)
    if (slug) {
      const existing = await context.cmsService.findBySlug(slug);
      if (existing) {
        return {
          error: `Page with slug "${slug}" already exists`,
          suggestion: `Try "${slug}-2" or choose a different slug`,
          existingPage: { id: existing.id, title: existing.title },
        };
      }
    }
    
    // 2c. Validate content length (business rule)
    if (content.length > 50000) {
      return {
        error: 'Content exceeds maximum length of 50,000 characters',
        currentLength: content.length,
        suggestion: 'Split into multiple pages or reduce content',
      };
    }
    
    // All validation passed, create page
    const newPage = await context.cmsService.createPage({
      title,
      content,
      slug: slug || generateSlug(title),
    });
    
    return {
      success: true,
      page: newPage,
    };
  },
});
```

### Error Response Format

**Structured errors** help agents recover:

```typescript
// ✅ GOOD: Structured error response
interface ToolError {
  error: string;              // What went wrong
  field?: string;             // Which parameter caused issue
  suggestion?: string;        // How to fix it
  validValues?: any[];        // If enum, show valid options
  documentation?: string;     // Link to docs
}

// Example
return {
  error: 'Invalid status value',
  field: 'status',
  suggestion: 'Choose from: draft, published, or archived',
  validValues: ['draft', 'published', 'archived'],
};
```

**Agent sees this and can retry with correct value**:
```
Tool failed: Invalid status value for field 'status'.
Suggestion: Choose from: draft, published, or archived.
Valid values: ["draft", "published", "archived"]

I'll retry with a valid status...
```

---

## Schema Evolution

### Version Management

As your tools evolve, maintain backward compatibility:

```typescript
// Version 1: Simple schema
const cms_getPage_v1 = tool({
  description: 'Gets page by ID',
  parameters: z.object({
    pageId: z.string(),
  }),
  execute: async ({ pageId }) => {
    return await fetchPage(pageId);
  },
});

// Version 2: Add optional parameter (backward compatible)
const cms_getPage_v2 = tool({
  description: 'Gets page by ID with optional content fetching',
  parameters: z.object({
    pageId: z.string(),
    fetchMode: z.enum(['summary', 'full']).default('summary'), // NEW, optional
  }),
  execute: async ({ pageId, fetchMode }) => {
    return await fetchPage(pageId, fetchMode);
  },
});

// ✅ Old calls still work: { pageId: '123' }
// ✅ New calls add feature: { pageId: '123', fetchMode: 'full' }
```

### Breaking Changes

When you must break compatibility:

```typescript
// Strategy 1: Deprecation period
const cms_updatePage_old = tool({
  description: '[DEPRECATED] Use cms_updatePage_v2 instead. This will be removed in v3.0.',
  parameters: z.object({ /* old schema */ }),
  execute: async (params) => {
    console.warn('Using deprecated tool: cms_updatePage_old');
    // Redirect to new tool
    return await cms_updatePage_v2.execute(/* transform params */);
  },
});

// Strategy 2: Dual tools during migration
const ALL_TOOLS = {
  cms_updatePage: cms_updatePage_v2,    // New version
  cms_updatePage_legacy: cms_updatePage_v1, // Legacy support
};
```

---

## Type Safety with TypeScript

### Inferred Types

Zod provides excellent TypeScript integration:

```typescript
// Define schema
const pageSchema = z.object({
  id: z.string(),
  title: z.string(),
  content: z.string(),
  status: z.enum(['draft', 'published']),
  metadata: z.record(z.any()),
});

// Infer TypeScript type
type Page = z.infer<typeof pageSchema>;

// Use in tool
const cms_createPage = tool({
  parameters: z.object({
    page: pageSchema,
  }),
  execute: async ({ page }: { page: Page }) => {
    // TypeScript knows page.title is string
    // TypeScript knows page.status is 'draft' | 'published'
    console.log(page.title.toUpperCase());
  },
});
```

### Context Typing

```typescript
// Define context interface
interface AgentContext {
  cmsService: {
    getPage: (id: string) => Promise<Page>;
    createPage: (data: Partial<Page>) => Promise<Page>;
  };
  userId: string;
  sessionId: string;
}

// Type-safe tool with context
const cms_getPage = tool({
  description: 'Gets page by ID',
  parameters: z.object({
    pageId: z.string(),
  }),
  execute: async (
    { pageId }: { pageId: string },
    context: AgentContext // Type-safe context
  ) => {
    // TypeScript autocomplete works
    return await context.cmsService.getPage(pageId);
  },
});
```

---

## Production Patterns

### Tool Definition Template

```typescript
// File: server/tools/template.ts

import { tool } from 'ai';
import { z } from 'zod';
import { AgentContext } from '@/types';

/**
 * Template for creating production-ready tools
 */
export const toolTemplate = tool({
  // 1. DESCRIPTION: Clear, specific, actionable
  description: `
    [ACTION] [WHAT] [OPTIONAL: with/by PARAMS].
    Use this when [USER INTENT].
    Returns [OUTPUT FORMAT].
    [OPTIONAL: Constraints/warnings].
  `.trim(),
  
  // 2. PARAMETERS: Zod schema with descriptions
  parameters: z.object({
    // Required field
    requiredField: z.string()
      .min(1, 'Cannot be empty')
      .describe('What this field represents'),
    
    // Optional field with default
    optionalField: z.string()
      .default('defaultValue')
      .describe('What this field does'),
    
    // Enum for limited choices
    choiceField: z.enum(['option1', 'option2'])
      .describe('Which option to use'),
  }),
  
  // 3. EXECUTE: Typed, validated, error-handled
  execute: async (
    { requiredField, optionalField, choiceField },
    context: AgentContext
  ) => {
    try {
      // Validation
      if (/* custom validation */) {
        return {
          error: 'Validation failed',
          field: 'fieldName',
          suggestion: 'How to fix',
        };
      }
      
      // Business logic
      const result = await performAction(requiredField);
      
      // Success response
      return {
        success: true,
        data: result,
      };
      
    } catch (error) {
      // Error handling
      console.error('Tool execution failed:', error);
      return {
        error: error.message,
        suggestion: 'Try again or contact support',
      };
    }
  },
});
```

### Tool Testing

```typescript
// File: server/tools/__tests__/cms-tools.test.ts

import { describe, it, expect, vi } from 'vitest';
import { cms_getPage } from '../cms-tools';

describe('cms_getPage', () => {
  it('should validate required pageId', async () => {
    // Test Zod validation
    const result = await cms_getPage.execute(
      { pageId: '' }, // Invalid: empty
      mockContext
    );
    
    expect(result.error).toBeDefined();
  });
  
  it('should fetch page successfully', async () => {
    const mockContext = {
      cmsService: {
        getPage: vi.fn().mockResolvedValue({
          id: '123',
          title: 'Test Page',
        }),
      },
    };
    
    const result = await cms_getPage.execute(
      { pageId: '123' },
      mockContext
    );
    
    expect(result.success).toBe(true);
    expect(result.page.title).toBe('Test Page');
  });
  
  it('should handle not found error', async () => {
    const mockContext = {
      cmsService: {
        getPage: vi.fn().mockResolvedValue(null),
      },
    };
    
    const result = await cms_getPage.execute(
      { pageId: 'nonexistent' },
      mockContext
    );
    
    expect(result.error).toContain('not found');
    expect(result.suggestion).toBeDefined();
  });
});
```

---

## Best Practices Checklist

### DO ✅

1. **Write specific descriptions**: Include when to use, not just what it does
2. **Use Zod for schemas**: Type safety + runtime validation
3. **Describe every parameter**: LLM needs to understand purpose
4. **Provide defaults**: Reduce required parameters when sensible
5. **Use enums for choices**: Prevent invalid values
6. **Validate inputs**: Defense in depth (schema + custom)
7. **Return structured errors**: Help agent recover from mistakes
8. **Test tools independently**: Unit tests for each tool
9. **Version carefully**: Maintain backward compatibility
10. **Document constraints**: Max lengths, valid formats, rate limits

### DON'T ❌

1. **Don't write vague descriptions**: "Updates data" → useless
2. **Don't skip parameter descriptions**: LLM won't know how to use
3. **Don't use overlapping keywords**: Confuses tool selection
4. **Don't trust LLM output alone**: Always validate
5. **Don't throw generic errors**: "Error occurred" → unhelpful
6. **Don't break compatibility**: Deprecate first
7. **Don't forget TypeScript**: Lose type safety and autocomplete
8. **Don't skip testing**: Tools fail silently in production
9. **Don't make everything required**: Cognitive load on LLM
10. **Don't over-complicate**: Start simple, add complexity as needed

---

## Summary

### Key Takeaways

1. **Descriptions > Names**: LLMs read descriptions to decide tool usage
2. **Zod = Type safety + Validation**: Single source of truth
3. **Structured errors** help agents recover (60-80% error reduction)
4. **Test tools independently**: Prevent production failures
5. **Evolve carefully**: Backward compatibility is critical

### Tool Quality Checklist

```typescript
const TOOL_QUALITY_CHECKLIST = {
  description: {
    hasActionVerb: true,         // "Retrieves", "Creates", etc.
    specifiesWhenToUse: true,    // "Use when..."
    describesOutput: true,       // "Returns..."
    isUnderThreeSentences: true, // Concise
  },
  
  parameters: {
    allHaveDescriptions: true,   // Every param described
    usesEnumsForChoices: true,   // Not free-form strings
    hasReasonableDefaults: true, // Reduce required params
    validated: true,             // Zod + custom validation
  },
  
  execute: {
    typesSafe: true,             // TypeScript types
    handlesErrors: true,         // Try-catch + structured errors
    validatesInputs: true,       // Defense in depth
    tested: true,                // Unit tests exist
  },
};
```

---

## Research Citations

1. **Scalifiai** - "Best Practices for Function Calling in LLMs in 2025" (Oct 2025)  
   https://www.scalifiai.com/blog/function-calling-tool-call-best%20practices

2. **QuotientAI** - "Evaluating Tool Calling Capabilities in LLMs" (May 2025)  
   https://blog.quotientai.co/evaluating-tool-calling-capabilities-in-large-language-models

3. **CodeWithCaptain** - "LLM Function Calling Best Practices: Build Reliable Agents" (Nov 2025)  
   https://codewithcaptain.com/llm-function-calling-best-practices/

4. **OpenAI Community** - "Best Practices for Improving Assistants' Function Calling Reasoning" (2024)  
   https://community.openai.com/t/best-practices-for-improving-assistants-function-calling-reasoning

5. **Prompt Engineering Guide** - "Function Calling with LLMs" (2024)  
   https://www.promptingguide.ai/applications/function_calling

---

**Next Steps**:

- Read [3.3.2 - Tool Registry](./3.3.2-tool-registry.md) for organizing and discovering tools
- Read [3.3.3 - Context Injection](./3.3.3-context-injection.md) for passing runtime data to tools
- Read [3.3.5 - Tool Composition](./3.3.5-composition.md) for chaining tools together
