# 3.3.5 - Tool Composition Patterns

## Overview

**Tool composition** enables agents to execute complex workflows by combining multiple tools in sequence, parallel, or conditional patterns. Rather than requiring a single monolithic tool for each task, composition allows building sophisticated behaviors from simple, reusable building blocks.

This guide covers composition patterns, orchestration strategies, and production implementation for scalable AI agents.

**Key Research Findings (2024-2025)**:

- **Parallel execution** achieves 2-5× speedup for independent tasks (AI SDK, 2025)
- **Monoidal structures** provide formal framework for tool composition (LightcapAI, Nov 2025)
- **Hybrid sequential+parallel** patterns optimal for complex workflows (Skywork.ai, Sep 2025)
- **Map-reduce patterns** scale to 100+ concurrent operations
- **Proper composition reduces token usage by 30-40%** vs. monolithic tools

**Date Verified**: November 19, 2025

---

## Composition Patterns

### 1. Sequential Composition (A → B → C)

**Use case**: Steps depend on previous results

```typescript
// Sequential: Each step needs output from previous step

// Example: Create page → Add content → Publish
async function createAndPublishPage(
  title: string,
  content: string
): Promise<{ pageId: string; url: string }> {
  // Step 1: Create page
  const createResult = await cms_createPage.execute({
    title,
    status: 'draft',
  });
  
  if (!createResult.success) {
    throw new Error(`Failed to create page: ${createResult.error}`);
  }
  
  const pageId = createResult.page.id;
  
  // Step 2: Update content (depends on pageId)
  const updateResult = await cms_updatePage.execute({
    pageId,
    updates: { content },
  });
  
  if (!updateResult.success) {
    throw new Error(`Failed to update content: ${updateResult.error}`);
  }
  
  // Step 3: Publish (depends on content being added)
  const publishResult = await cms_publishPage.execute({
    pageId,
  });
  
  if (!publishResult.success) {
    throw new Error(`Failed to publish: ${publishResult.error}`);
  }
  
  return {
    pageId,
    url: publishResult.url,
  };
}
```

**Characteristics**:
- ✅ Simple to understand and debug
- ✅ Clear data flow
- ❌ Slower (serial execution)
- ❌ One failure blocks entire chain

**When to use**: Steps have strict dependencies

### 2. Parallel Composition (A ⊗ B ⊗ C)

**Use case**: Independent tasks that can run simultaneously

```typescript
// Parallel: Tasks don't depend on each other

// Example: Fetch multiple pages at once
async function fetchMultiplePages(
  pageIds: string[]
): Promise<Page[]> {
  // Execute all fetches in parallel
  const results = await Promise.all(
    pageIds.map(id => 
      cms_getPage.execute({ 
        identifier: id,
        fetchMode: 'summary',
      })
    )
  );
  
  // Filter successful results
  return results
    .filter(r => r.success)
    .map(r => r.page);
}

// Example: Multi-city weather (from AI SDK docs)
async function getWeatherForCities(
  cities: string[]
): Promise<WeatherData[]> {
  // AI SDK automatically parallelizes when possible
  const results = await Promise.all(
    cities.map(city => 
      getWeather.execute({ location: city })
    )
  );
  
  return results;
}
```

**Characteristics**:
- ✅ 2-5× faster than sequential
- ✅ Better resource utilization
- ✅ Resilient (one failure doesn't block others)
- ❌ Harder to debug
- ❌ Potential race conditions

**When to use**: Tasks are independent and can run concurrently

### 3. Map-Reduce Pattern

**Use case**: Apply operation to collection, then aggregate results

```typescript
// Map-Reduce: Process collection in parallel, then combine

// Example: Analyze sentiment across multiple documents
async function analyzeSentimentBatch(
  documentIds: string[]
): Promise<{ overall: number; details: Array<{ id: string; sentiment: number }> }> {
  // Map phase: Parallel analysis
  const sentiments = await Promise.all(
    documentIds.map(async (id) => {
      const doc = await cms_getPage.execute({ identifier: id });
      const sentiment = await analyzeSentiment.execute({ text: doc.page.content });
      
      return {
        id,
        sentiment: sentiment.score,
      };
    })
  );
  
  // Reduce phase: Aggregate results
  const overall = sentiments.reduce((sum, s) => sum + s.sentiment, 0) / sentiments.length;
  
  return {
    overall,
    details: sentiments,
  };
}
```

**Characteristics**:
- ✅ Scales to 100+ operations
- ✅ Natural for batch processing
- ✅ Easy to add more items
- ❌ Memory intensive for large collections
- ❌ All items must complete before reduce

**When to use**: Batch operations on collections

### 4. Conditional Composition (if-then-else)

**Use case**: Different paths based on runtime conditions

```typescript
// Conditional: Choose path based on results

// Example: Create or update page (depends on existence)
async function upsertPage(
  slug: string,
  title: string,
  content: string
): Promise<Page> {
  // Check if page exists
  const searchResult = await cms_findResource.execute({
    query: slug,
    filters: { type: 'page' },
  });
  
  if (searchResult.items.length > 0) {
    // Page exists → Update
    const pageId = searchResult.items[0].id;
    
    const updateResult = await cms_updatePage.execute({
      pageId,
      updates: { title, content },
    });
    
    return updateResult.page;
  } else {
    // Page doesn't exist → Create
    const createResult = await cms_createPage.execute({
      title,
      content,
      slug,
      status: 'draft',
    });
    
    return createResult.page;
  }
}
```

**Characteristics**:
- ✅ Handles different scenarios
- ✅ Reduces unnecessary operations
- ❌ More complex logic
- ❌ Harder to predict execution path

**When to use**: Business logic requires branching

### 5. Pipeline Pattern (Transforms)

**Use case**: Data flows through series of transformations

```typescript
// Pipeline: Transform data through stages

// Example: Document processing pipeline
async function processDocument(
  documentId: string
): Promise<ProcessedDocument> {
  // Stage 1: Fetch
  const doc = await cms_getPage.execute({ identifier: documentId });
  
  // Stage 2: Extract entities
  const entities = await extractEntities.execute({ 
    text: doc.page.content,
  });
  
  // Stage 3: Classify
  const classification = await classifyContent.execute({
    text: doc.page.content,
    entities: entities.entities,
  });
  
  // Stage 4: Generate summary
  const summary = await summarize.execute({
    text: doc.page.content,
    maxLength: 200,
  });
  
  // Stage 5: Store enriched data
  await cms_updatePage.execute({
    pageId: doc.page.id,
    updates: {
      metadata: {
        entities: entities.entities,
        category: classification.category,
        summary: summary.text,
      },
    },
  });
  
  return {
    id: documentId,
    entities: entities.entities,
    classification: classification.category,
    summary: summary.text,
  };
}
```

**Characteristics**:
- ✅ Clear data transformation flow
- ✅ Easy to add/remove stages
- ✅ Testable (test each stage independently)
- ❌ Linear flow only
- ❌ Entire pipeline runs even if later stages fail

**When to use**: Data needs multi-step processing

---

## Advanced Patterns

### Hybrid Sequential + Parallel

**Optimal pattern** for complex workflows (Skywork.ai, Sep 2025)

```typescript
// Combine sequential for dependencies, parallel for independent tasks

async function complexWorkflow(userId: string) {
  // Stage 1: Sequential (must happen first)
  const user = await getUser.execute({ userId });
  
  // Stage 2: Parallel (independent operations using user data)
  const [orders, preferences, activity] = await Promise.all([
    getOrders.execute({ userId: user.id }),
    getPreferences.execute({ userId: user.id }),
    getActivityLog.execute({ userId: user.id, limit: 100 }),
  ]);
  
  // Stage 3: Sequential (depends on all parallel results)
  const recommendations = await generateRecommendations.execute({
    user,
    orders: orders.items,
    preferences: preferences.data,
    activity: activity.events,
  });
  
  // Stage 4: Parallel (independent notifications)
  await Promise.all([
    sendEmail.execute({
      to: user.email,
      subject: 'Your Recommendations',
      body: formatRecommendations(recommendations),
    }),
    logEvent.execute({
      userId: user.id,
      event: 'recommendations_generated',
      data: { count: recommendations.length },
    }),
  ]);
  
  return recommendations;
}
```

**Benefits**:
- 2-3× faster than pure sequential
- More reliable than pure parallel
- Clear dependencies

### Retry with Fallback

**Resilient composition** for production

```typescript
// Retry failed operations, fallback to alternative

async function fetchWithFallback<T>(
  primary: () => Promise<T>,
  fallback: () => Promise<T>,
  maxRetries: number = 3
): Promise<T> {
  let lastError: Error | null = null;
  
  // Try primary with retries
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await primary();
    } catch (error) {
      lastError = error as Error;
      console.warn(`Primary failed (attempt ${i + 1}/${maxRetries}):`, error);
      
      // Exponential backoff
      await sleep(Math.pow(2, i) * 1000);
    }
  }
  
  // Primary exhausted, try fallback
  console.warn('Primary exhausted, using fallback');
  try {
    return await fallback();
  } catch (fallbackError) {
    console.error('Fallback also failed:', fallbackError);
    throw new Error(
      `Both primary and fallback failed. Primary error: ${lastError?.message}`
    );
  }
}

// Usage
const page = await fetchWithFallback(
  // Primary: Fast API
  () => cms_getPage.execute({ identifier: 'about', fetchMode: 'full' }),
  // Fallback: Database query
  () => db_query.execute({ 
    table: 'pages',
    where: { slug: 'about' },
  })
);
```

---

## Monoidal Composition (Category Theory)

**Formal framework** from LightcapAI (Nov 2025)

### Sequential Combinator (∘)

```typescript
// f ∘ g: Apply g, then f
function compose<A, B, C>(
  f: (b: B) => Promise<C>,
  g: (a: A) => Promise<B>
): (a: A) => Promise<C> {
  return async (a: A) => {
    const b = await g(a);
    return await f(b);
  };
}

// Example: Extract → Summarize
const extractAndSummarize = compose(
  (entities: Entity[]) => summarize.execute({ entities }),
  (text: string) => extractEntities.execute({ text })
);

// Usage
const result = await extractAndSummarize('Long document text...');
```

### Parallel Combinator (⊗)

```typescript
// f ⊗ g: Apply both simultaneously
function parallel<A, B, C, D>(
  f: (a: A) => Promise<B>,
  g: (c: C) => Promise<D>
): (inputs: [A, C]) => Promise<[B, D]> {
  return async ([a, c]: [A, C]) => {
    const [b, d] = await Promise.all([
      f(a),
      g(c),
    ]);
    return [b, d];
  };
}

// Example: Get user AND orders simultaneously
const getUserAndOrders = parallel(
  (userId: string) => getUser.execute({ userId }),
  (userId: string) => getOrders.execute({ userId })
);

// Usage
const [user, orders] = await getUserAndOrders(['user-123', 'user-123']);
```

---

## AI SDK Multi-Step Execution

### Native Multi-Step Support

```typescript
// AI SDK v6 handles tool composition automatically

import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';

const result = await generateText({
  model: openai('gpt-4o'),
  prompt: 'Get weather for San Francisco, Los Angeles, and New York',
  tools: {
    getWeather: tool({
      description: 'Gets current weather for a city',
      parameters: z.object({
        city: z.string(),
      }),
      execute: async ({ city }) => {
        return await fetchWeather(city);
      },
    }),
  },
  maxSteps: 10, // Allow multiple tool calls
});

// AI SDK automatically:
// 1. Identifies need for parallel calls (3 cities)
// 2. Executes getWeather 3 times in parallel
// 3. Waits for all to complete
// 4. Synthesizes results into response
```

### Controlling Execution Order

```typescript
// Use stopWhen to control multi-step behavior

const result = await generateText({
  model: openai('gpt-4o'),
  prompt: 'Research and summarize AI trends',
  tools: {
    search: searchTool,
    summarize: summarizeTool,
  },
  maxSteps: 20,
  
  // Stop when agent calls 'finish' tool
  experimental_onStepFinish: async (step) => {
    if (step.toolCalls?.some(call => call.toolName === 'finish')) {
      return { shouldContinue: false };
    }
    return { shouldContinue: true };
  },
});
```

---

## Production Patterns

### Workflow Orchestrator

```typescript
// File: server/workflows/orchestrator.ts

interface WorkflowStep {
  name: string;
  tool: string;
  params: Record<string, any>;
  dependsOn?: string[]; // Step names
}

export class WorkflowOrchestrator {
  async execute(steps: WorkflowStep[]): Promise<Map<string, any>> {
    const results = new Map<string, any>();
    const executed = new Set<string>();
    
    // Topological sort for execution order
    const order = this.topologicalSort(steps);
    
    for (const step of order) {
      // Wait for dependencies
      if (step.dependsOn) {
        await this.waitForSteps(step.dependsOn, executed);
      }
      
      // Execute step
      console.log(`Executing step: ${step.name}`);
      const result = await this.executeStep(step, results);
      
      // Store result
      results.set(step.name, result);
      executed.add(step.name);
    }
    
    return results;
  }
  
  private async executeStep(
    step: WorkflowStep,
    previousResults: Map<string, any>
  ): Promise<any> {
    // Resolve parameters (may reference previous results)
    const params = this.resolveParams(step.params, previousResults);
    
    // Get tool from registry
    const tool = toolRegistry.get(step.tool);
    if (!tool) {
      throw new Error(`Tool not found: ${step.tool}`);
    }
    
    // Execute
    return await tool.execute(params);
  }
  
  private resolveParams(
    params: Record<string, any>,
    results: Map<string, any>
  ): Record<string, any> {
    const resolved: Record<string, any> = {};
    
    for (const [key, value] of Object.entries(params)) {
      // Check if value references previous step
      if (typeof value === 'string' && value.startsWith('$')) {
        const [stepName, path] = value.slice(1).split('.');
        const stepResult = results.get(stepName);
        
        if (!stepResult) {
          throw new Error(`Step result not found: ${stepName}`);
        }
        
        // Navigate path (e.g., "user.id")
        resolved[key] = path ? this.getPath(stepResult, path) : stepResult;
      } else {
        resolved[key] = value;
      }
    }
    
    return resolved;
  }
  
  private topologicalSort(steps: WorkflowStep[]): WorkflowStep[] {
    // Simplified topological sort
    const sorted: WorkflowStep[] = [];
    const visited = new Set<string>();
    
    const visit = (step: WorkflowStep) => {
      if (visited.has(step.name)) return;
      
      // Visit dependencies first
      if (step.dependsOn) {
        for (const depName of step.dependsOn) {
          const dep = steps.find(s => s.name === depName);
          if (dep) visit(dep);
        }
      }
      
      visited.add(step.name);
      sorted.push(step);
    };
    
    steps.forEach(visit);
    return sorted;
  }
}

// Usage
const workflow = new WorkflowOrchestrator();

const results = await workflow.execute([
  {
    name: 'fetchUser',
    tool: 'getUser',
    params: { userId: '123' },
  },
  {
    name: 'fetchOrders',
    tool: 'getOrders',
    params: { userId: '$fetchUser.id' }, // Reference previous result
    dependsOn: ['fetchUser'],
  },
  {
    name: 'generateRecommendations',
    tool: 'recommend',
    params: {
      user: '$fetchUser',
      orders: '$fetchOrders',
    },
    dependsOn: ['fetchUser', 'fetchOrders'],
  },
]);
```

---

## Best Practices

### DO ✅

1. **Parallelize independent tasks**: 2-5× speedup
2. **Use sequential for dependencies**: Clear data flow
3. **Implement retry logic**: Resilience in production
4. **Add fallback options**: Graceful degradation
5. **Track execution time**: Identify bottlenecks
6. **Handle partial failures**: Don't fail entire workflow
7. **Use workflow orchestration**: For complex multi-step
8. **Test compositions independently**: Unit test each pattern
9. **Monitor composition metrics**: Success rates, latency
10. **Document dependencies**: Make data flow clear

### DON'T ❌

1. **Don't over-parallelize**: Diminishing returns after ~10 concurrent
2. **Don't ignore errors**: Handle and report failures
3. **Don't create circular dependencies**: Deadlock risk
4. **Don't nest too deeply**: Hard to debug
5. **Don't forget timeouts**: Prevent hanging workflows
6. **Don't skip validation**: Each step should validate
7. **Don't assume order**: Parallel tasks may complete in any order
8. **Don't hardcode workflows**: Use orchestration for flexibility
9. **Don't forget monitoring**: Track each composition pattern
10. **Don't over-complicate**: Start simple, add complexity as needed

---

## Performance Comparison

### Execution Time Analysis

| Pattern               | Steps | Sequential Time | Optimized Time | Speedup |
| --------------------- | ----- | --------------- | -------------- | ------- |
| **Pure Sequential**   | 5     | 5000ms          | 5000ms         | 1.0×    |
| **Pure Parallel**     | 5     | 5000ms          | 1000ms         | 5.0×    |
| **Hybrid (3+2)**      | 5     | 5000ms          | 2000ms         | 2.5×    |
| **Map-Reduce (10)**   | 10    | 10000ms         | 1500ms         | 6.7×    |
| **Pipeline (5)**      | 5     | 5000ms          | 5000ms         | 1.0×    |

**Assumptions**: Each step takes 1000ms, 100ms overhead per parallel batch

---

## Summary

### Key Takeaways

1. **Composition is essential** for complex workflows (avoid monolithic tools)
2. **Parallel execution** achieves 2-5× speedup for independent tasks
3. **Hybrid patterns** (sequential + parallel) are optimal for most workflows
4. **AI SDK handles composition** automatically in many cases
5. **Workflow orchestration** needed for complex multi-step patterns
6. **Monitor composition metrics** to optimize performance

### Pattern Selection Guide

```typescript
const COMPOSITION_PATTERNS = {
  // Sequential: A → B → C
  sequential: {
    when: 'Strict dependencies between steps',
    speedup: '1×',
    complexity: 'Low',
    example: 'Create → Update → Publish',
  },
  
  // Parallel: A ⊗ B ⊗ C
  parallel: {
    when: 'Independent tasks',
    speedup: '2-5×',
    complexity: 'Medium',
    example: 'Fetch multiple pages',
  },
  
  // Map-Reduce
  mapReduce: {
    when: 'Batch operations',
    speedup: '5-10×',
    complexity: 'Medium',
    example: 'Analyze 100 documents',
  },
  
  // Conditional
  conditional: {
    when: 'Branching logic',
    speedup: 'Varies',
    complexity: 'Medium',
    example: 'Create or update (upsert)',
  },
  
  // Hybrid
  hybrid: {
    when: 'Complex workflows with some dependencies',
    speedup: '2-3×',
    complexity: 'High',
    example: 'Fetch user → parallel fetch orders/preferences → generate recommendations',
  },
};
```

---

## Research Citations

1. **AI SDK** - "Advanced: Multistep Interfaces" (2025)  
   https://ai-sdk.dev/docs/advanced/multistep-interfaces

2. **AI SDK** - "Cookbook: Call Tools in Parallel" (2025)  
   https://ai-sdk.dev/cookbook/rsc/call-tools-in-parallel

3. **LightcapAI** - "Composing Tools with Monoidal Structures in GPT-4 Function Calling" (Nov 2025)  
   https://lightcapai.medium.com/composing-tools-with-monoidal-structures-in-gpt-4

4. **Skywork.ai** - "Design Patterns for AI Agents: Orchestration & Handoffs" (Sep 2025)  
   https://skywork.ai/blog/ai-agent-orchestration-best-practices-handoffs/

5. **Neel Shah** - "Concurrent vs. Parallel Execution in LLM API Calls" (Aug 2025)  
   https://medium.com/@neeldevenshah/concurrent-vs-parallel-execution-in-llm-api-calls

6. **LangChain** - "Parallel Tool Use" (2025)  
   https://js.langchain.com/v0.1/docs/use_cases/tool_use/parallel/

---

**Next Steps**:

- Read [3.3.1 - Tool Definition](./3.3.1-tool-definition.md) for creating well-structured tools
- Read [3.3.2 - Tool Registry](./3.3.2-tool-registry.md) for organizing tools at scale
- Read [3.3.3 - Context Injection](./3.3.3-context-injection.md) for passing runtime data to tools
