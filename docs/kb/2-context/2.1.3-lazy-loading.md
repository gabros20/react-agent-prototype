# 2.1.3 Token Optimization: Lazy Loading (Fetch on Demand)

## Overview

Lazy loading defers content fetching until actually needed, rather than loading everything upfront. Instead of prefetching all possible context (expensive, wasteful), you start with minimal context and fetch additional details only when the agent determines it's necessary. This dramatically reduces token usage while maintaining access to complete information.

**Key Insight** (2024-2025): Don't load what you might need—load what you know you need, when you need it.

**Current Date**: November 17, 2025

## Why Lazy Loading Matters

### The Eager Loading Problem

**Without Lazy Loading** (load everything upfront):
```typescript
// Fetch full content for all pages
const pages = await prisma.page.findMany({
  include: {
    content: true,        // Full HTML/markdown (heavy!)
    sections: {
      include: {
        content: true     // All section content (very heavy!)
      }
    },
    metadata: true,
    revisions: true       // Full history (unnecessary!)
  }
});

const context = pages.map(p => `
Page: ${p.title}
Content: ${p.content} // Could be 10,000+ tokens!
Sections: ${p.sections.map(s => s.content).join('\n')}
...
`).join('\n\n');

// Result: 50,000 tokens for 10 pages (most unused!)
```

**Problems**:
- ❌ Massive token waste (most content never referenced)
- ❌ High database load
- ❌ Slow initial response
- ❌ Expensive context
- ❌ Context window overflow

**With Lazy Loading** (lightweight first, detailed on demand):
```typescript
// 1. Start with lightweight metadata only
const pages = await prisma.page.findMany({
  select: {
    id: true,
    title: true,
    slug: true,
    summary: true,    // Short summary (50-100 tokens)
    updatedAt: true
  }
});

const initialContext = pages.map(p => `
- ${p.title} (${p.slug}): ${p.summary}
`).join('\n');

// Result: 500 tokens for 10 pages (lightweight!)

// 2. Agent decides: "I need details on page-123"
// 3. Fetch full content only for that page
const fullPage = await prisma.page.findUnique({
  where: { id: 'page-123' },
  include: { content: true, sections: true }
});

// Additional cost: 1,000 tokens (only when needed)
```

**Benefits**:
- ✅ 90%+ token reduction (typical)
- ✅ Faster initial responses
- ✅ Lower database load
- ✅ Pay only for what's used
- ✅ Scales to large datasets

### Real-World Impact

**Example: CMS Agent**
```
Scenario: User asks "What pages mention React?"

Eager Loading:
- Load 100 pages × 1,000 tokens = 100,000 tokens
- Search client-side
- Cost: $1.50 per query (GPT-4o)

Lazy Loading:
- Load 100 page titles + summaries = 5,000 tokens
- Agent uses search tool instead
- Fetch only matching pages: 3 pages × 1,000 = 3,000 tokens
- Total: 8,000 tokens
- Cost: $0.12 per query (92% savings!)
```

## Lazy Loading Patterns

### Pattern 1: Two-Tier Fetching (Lightweight → Full)

**Most common pattern**: Start with summaries, fetch details on demand.

**Your Codebase Example** (`server/tools/all-tools.ts`):
```typescript
// Already implements this pattern! ✅
{
  name: 'cms_getPage',
  parameters: {
    slug: { type: 'string', required: true },
    fetchMode: {
      type: 'string',
      enum: ['lightweight', 'full'],
      default: 'lightweight',
      description: 'Lightweight: metadata only. Full: include content.'
    }
  }
}

// Lightweight: ~50 tokens
// Full: ~1,000 tokens
// Savings: 95% when full content not needed
```

**Enhancement**: Multi-level fetching
```typescript
// Level 1: Minimal metadata (10-20 tokens per item)
interface PageMetadata {
  id: string;
  title: string;
  slug: string;
  updatedAt: string;
}

// Level 2: Summary (50-100 tokens per item)
interface PageSummary extends PageMetadata {
  summary: string;
  tags: string[];
  author: string;
}

// Level 3: Full content (1,000+ tokens per item)
interface PageFull extends PageSummary {
  content: string;
  sections: Section[];
  metadata: Record<string, any>;
}

// Tool implementation
async function getPage(slug: string, fetchLevel: 'metadata' | 'summary' | 'full' = 'summary') {
  switch (fetchLevel) {
    case 'metadata':
      return prisma.page.findUnique({
        where: { slug },
        select: { id: true, title: true, slug: true, updatedAt: true }
      });
    
    case 'summary':
      return prisma.page.findUnique({
        where: { slug },
        select: {
          id: true, title: true, slug: true, updatedAt: true,
          summary: true, tags: true, author: true
        }
      });
    
    case 'full':
      return prisma.page.findUnique({
        where: { slug },
        include: { content: true, sections: true, metadata: true }
      });
  }
}
```

**Usage in Agent Prompt**:
```xml
<tool>
  <name>cms_getPage</name>
  <description>Get page information. Use 'metadata' level for browsing, 'summary' for quick overview, 'full' only when you need complete content.</description>
  <parameters>
    <slug>Page identifier</slug>
    <fetchLevel>
      - 'metadata': Just title and ID (fastest, ~10 tokens)
      - 'summary': Add description and tags (~50 tokens)  
      - 'full': Complete content (~1,000+ tokens, slowest)
    </fetchLevel>
  </parameters>
  <strategy>Start with 'summary', upgrade to 'full' only if needed.</strategy>
</tool>
```

### Pattern 2: Paginated Loading

**Load data in chunks as needed**:

**Implementation**:
```typescript
class PaginatedContextLoader {
  private currentPage: number = 1;
  private pageSize: number = 10;
  private hasMore: boolean = true;
  
  async loadNextBatch(query: string): Promise<{
    items: any[];
    hasMore: boolean;
    summary: string;
  }> {
    const results = await this.search(query, {
      page: this.currentPage,
      pageSize: this.pageSize
    });
    
    this.currentPage++;
    this.hasMore = results.total > this.currentPage * this.pageSize;
    
    return {
      items: results.items,
      hasMore: this.hasMore,
      summary: `Loaded ${results.items.length} items. ${this.hasMore ? 'More available.' : 'All loaded.'}`
    };
  }
  
  async search(query: string, options: { page: number; pageSize: number }) {
    const skip = (options.page - 1) * options.pageSize;
    
    const [items, total] = await Promise.all([
      prisma.page.findMany({
        where: { content: { contains: query } },
        select: { id: true, title: true, summary: true },
        skip,
        take: options.pageSize
      }),
      prisma.page.count({
        where: { content: { contains: query } }
      })
    ]);
    
    return { items, total };
  }
}

// Tool for agent
{
  name: 'searchPages',
  description: 'Search pages. Returns 10 results at a time. Use loadMore to get additional results.',
  handler: async (query: string) => {
    const loader = new PaginatedContextLoader();
    return await loader.loadNextBatch(query);
  }
}

{
  name: 'loadMoreResults',
  description: 'Load next batch of search results if hasMore is true.',
  handler: async () => {
    // Loader instance persisted in session
    return await sessionLoader.loadNextBatch(currentQuery);
  }
}
```

**Agent Example**:
```
User: Show me all pages about React

Agent:
Thought: I'll search for React pages
Action: searchPages
Action Input: { "query": "React" }
Observation: Found 45 pages. Loaded first 10. hasMore: true

Thought: User said "all pages", I should load more
Action: loadMoreResults
Observation: Loaded 10 more (20 total). hasMore: true

Thought: Continue loading...
Action: loadMoreResults
Observation: Loaded 10 more (30 total). hasMore: true

[Continues until all loaded or user has enough info]
```

### Pattern 3: Hierarchical Lazy Loading

**Load broad view first, drill down progressively**:

**Implementation**:
```typescript
// Level 1: Category overview (lightweight)
interface CategoryOverview {
  name: string;
  pageCount: number;
  lastUpdated: string;
}

// Level 2: Page titles in category
interface CategoryPages {
  category: string;
  pages: Array<{ slug: string; title: string }>;
}

// Level 3: Individual page details
interface PageDetails {
  // Full page content
}

// Tools
const tools = {
  listCategories: async (): Promise<CategoryOverview[]> => {
    // ~100 tokens total
    return prisma.category.findMany({
      select: {
        name: true,
        _count: { select: { pages: true } },
        updatedAt: true
      }
    });
  },
  
  listPagesInCategory: async (category: string): Promise<CategoryPages> => {
    // ~500 tokens for category with 50 pages
    return prisma.page.findMany({
      where: { category },
      select: { slug: true, title: true }
    });
  },
  
  getPageDetails: async (slug: string): Promise<PageDetails> => {
    // ~1,000 tokens per page
    return prisma.page.findUnique({
      where: { slug },
      include: { content: true, sections: true }
    });
  }
};
```

**Agent Workflow**:
```
User: Find documentation about authentication

Agent:
Step 1: List categories (100 tokens)
→ Found: Authentication, User Management, Security, API

Step 2: List pages in "Authentication" (200 tokens)
→ Found: OAuth Setup, JWT Guide, Session Management, 2FA

Step 3: Get details on relevant pages (2,000 tokens)
→ Fetch: OAuth Setup, JWT Guide

Total: 2,300 tokens vs 50,000 tokens (eager loading all pages)
```

### Pattern 4: Conditional Lazy Loading

**Load additional context based on agent's needs**:

**Implementation**:
```typescript
class ConditionalContextLoader {
  async enrichContext(
    baseContext: string,
    query: string,
    agentRequest?: {
      needsExamples?: boolean;
      needsHistory?: boolean;
      needsRelatedDocs?: boolean;
    }
  ): Promise<string> {
    let enrichedContext = baseContext;
    
    // Only load if requested
    if (agentRequest?.needsExamples) {
      const examples = await this.loadExamples(query);
      enrichedContext += `\n\nEXAMPLES:\n${examples}`;
    }
    
    if (agentRequest?.needsHistory) {
      const history = await this.loadConversationHistory();
      enrichedContext += `\n\nHISTORY:\n${history}`;
    }
    
    if (agentRequest?.needsRelatedDocs) {
      const docs = await this.loadRelatedDocs(query);
      enrichedContext += `\n\nRELATED DOCS:\n${docs}`;
    }
    
    return enrichedContext;
  }
  
  private async loadExamples(query: string): Promise<string> {
    // Fetch only when agent explicitly requests examples
    const examples = await fewShotStore.getSimilar(query, 3);
    return examples.map(e => e.formatted).join('\n\n');
  }
}

// Agent can request enrichment via special tool
{
  name: 'enrichContext',
  description: 'Request additional context if current information is insufficient.',
  parameters: {
    reason: { type: 'string', description: 'Why you need more context' },
    type: {
      type: 'string',
      enum: ['examples', 'history', 'related_docs'],
      description: 'Type of context needed'
    }
  }
}
```

### Pattern 5: Streaming Lazy Loading

**Stream context incrementally as agent processes**:

**Implementation**:
```typescript
async function* streamingContextProvider(query: string) {
  // 1. Yield initial lightweight context immediately
  yield {
    type: 'initial',
    content: await getInitialContext(query),
    tokens: 500
  };
  
  // 2. Agent starts reasoning...
  
  // 3. Yield additional context as needed
  const relatedDocs = await getRelatedDocs(query);
  for (const doc of relatedDocs) {
    yield {
      type: 'additional',
      content: doc.summary,
      tokens: 100,
      fullContentAvailable: true,
      docId: doc.id
    };
  }
  
  // 4. If agent requests full content
  // (via observing agent's tool calls)
  if (agentRequestedFullContent) {
    yield {
      type: 'full',
      content: await getFullContent(requestedDocId),
      tokens: 1000
    };
  }
}

// Usage
for await (const contextChunk of streamingContextProvider(query)) {
  // Agent receives context incrementally
  // Can stop streaming if has enough information
}
```

## Production Best Practices

### 1. Cache Frequently Accessed Content

```typescript
class CachedLazyLoader {
  private cache = new Map<string, { content: any; timestamp: number }>();
  private ttl = 5 * 60 * 1000; // 5 minutes
  
  async load(key: string, fetchFn: () => Promise<any>): Promise<any> {
    const cached = this.cache.get(key);
    
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      metrics.increment('lazy_load.cache.hit');
      return cached.content;
    }
    
    metrics.increment('lazy_load.cache.miss');
    const content = await fetchFn();
    
    this.cache.set(key, { content, timestamp: Date.now() });
    return content;
  }
}

// Usage
const loader = new CachedLazyLoader();

const page = await loader.load(`page:${slug}:summary`, () =>
  prisma.page.findUnique({
    where: { slug },
    select: { id: true, title: true, summary: true }
  })
);
```

### 2. Track Loading Metrics

```typescript
class LazyLoadAnalytics {
  trackLoad(level: string, tokens: number, duration: number) {
    metrics.histogram('lazy_load.fetch.duration', duration, { level });
    metrics.histogram('lazy_load.fetch.tokens', tokens, { level });
    
    // Track fetch level distribution
    metrics.increment('lazy_load.fetch.count', { level });
  }
  
  trackTokenSavings(eagerTokens: number, lazyTokens: number) {
    const savings = 1 - (lazyTokens / eagerTokens);
    metrics.gauge('lazy_load.token.savings', savings);
  }
}

// Usage
const startTime = Date.now();
const content = await loadSummary(slug);
const duration = Date.now() - startTime;
const tokens = estimateTokens(content);

analytics.trackLoad('summary', tokens, duration);
```

### 3. Smart Prefetching

```typescript
// Prefetch likely-needed content in background
class SmartPrefetcher {
  async prefetchLikely(query: string, initialResults: string[]) {
    // Analyze query to predict what might be needed
    const predictions = await this.predictNeeded(query, initialResults);
    
    // Prefetch in background (don't block)
    predictions.forEach(item => {
      this.prefetchInBackground(item.id, item.level);
    });
  }
  
  private async predictNeeded(query: string, initialResults: string[]) {
    // Heuristics:
    // - If query mentions "details", prefetch full content
    // - If query about "all X", prefetch category
    // - If previous queries needed full content, prefetch it
    
    const predictions: Array<{ id: string; level: string }> = [];
    
    if (query.includes('detail') || query.includes('full')) {
      predictions.push(...initialResults.map(id => ({ id, level: 'full' })));
    }
    
    return predictions;
  }
  
  private async prefetchInBackground(id: string, level: string) {
    // Async prefetch, store in cache
    setTimeout(async () => {
      const content = await this.loadContent(id, level);
      await cache.set(`${id}:${level}`, content, 60); // 1 min TTL
    }, 0);
  }
}
```

### 4. Graceful Degradation

```typescript
// Handle loading failures gracefully
class ResilientLazyLoader {
  async loadWithFallback(
    slug: string,
    preferredLevel: 'full' | 'summary' | 'metadata' = 'full'
  ): Promise<{ content: any; level: string }> {
    try {
      // Try preferred level
      return {
        content: await this.load(slug, preferredLevel),
        level: preferredLevel
      };
    } catch (error) {
      console.warn(`Failed to load ${preferredLevel}, falling back`);
      
      // Fallback to lighter level
      if (preferredLevel === 'full') {
        return this.loadWithFallback(slug, 'summary');
      } else if (preferredLevel === 'summary') {
        return this.loadWithFallback(slug, 'metadata');
      } else {
        throw error; // Can't fallback further
      }
    }
  }
}
```

## Your Codebase Integration

**Already Implemented** ✅:
```typescript
// server/tools/all-tools.ts
cms_getPage: {
  fetchMode: 'lightweight' | 'full'  // Two-tier lazy loading
}
```

**Enhancements**:
```typescript
// 1. Add three-tier fetching
cms_getPage: {
  fetchMode: 'metadata' | 'summary' | 'full'
}

// 2. Add pagination to list operations
cms_listPages: {
  page: number,
  pageSize: number
}

// 3. Add hierarchical browsing
cms_listCategories: () => CategoryOverview[]
cms_listPagesInCategory: (category: string) => PageSummary[]

// 4. Track usage
analytics.trackLazyLoad(fetchMode, tokens, duration);
```

## Key Takeaways

**What is Lazy Loading**:
- Defer content fetching until needed
- Start lightweight, load details on demand
- Pay only for what's used

**Why It Matters** (2024-2025):
- **Token Savings**: 90%+ reduction typical
- **Performance**: Faster initial responses
- **Scalability**: Handle large datasets efficiently
- **Cost**: Major savings on context

**Lazy Loading Patterns**:
1. **Two-Tier**: Lightweight → Full (your codebase ✅)
2. **Paginated**: Load in chunks
3. **Hierarchical**: Categories → Pages → Details
4. **Conditional**: Load based on agent request
5. **Streaming**: Incremental context delivery

**Production Practices**:
- Cache frequently accessed content
- Track loading metrics
- Smart prefetching for likely needs
- Graceful fallbacks

**Your Codebase**:
```typescript
// Already implements two-tier! ✅
cms_getPage(slug, fetchMode: 'lightweight' | 'full')

// Enhance to three-tier
cms_getPage(slug, fetchMode: 'metadata' | 'summary' | 'full')

// Add hierarchical
cms_listCategories() → cms_listPagesInCategory(cat) → cms_getPage(slug, 'full')
```

## Navigation

- [← Previous: 2.1.2 Importance Scoring](./2.1.2-importance-scoring.md)
- [↑ Back to Knowledge Base TOC](../../AI_KNOWLEDGE_BASE_TOC.md)
- [→ Next: 2.1.4 Hybrid Content Fetching](./2.1.4-hybrid-fetching.md)

---

*Part of Layer 2: Context Engineering - Efficient on-demand content loading*
