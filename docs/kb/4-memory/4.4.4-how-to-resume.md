# 4.4.4 How to Resume: Load Checkpoint, Continue Execution

**Layer**: 4 - Memory & State  
**Sublayer**: 4.4 - State Persistence & Checkpointing  
**Audience**: Intermediate  
**Updated**: 2025-11-18

---

## Table of Contents

- [Overview](#overview)
- [Resume Process](#resume-process)
- [Loading Checkpoints](#loading-checkpoints)
- [State Reconstruction](#state-reconstruction)
- [Execution Continuation](#execution-continuation)
- [Handling Edge Cases](#handling-edge-cases)
- [Implementation Examples](#implementation-examples)
- [Production Patterns](#production-patterns)
- [Best Practices](#best-practices)
- [Common Pitfalls](#common-pitfalls)
- [Related Topics](#related-topics)
- [References](#references)

---

## Overview

**Resuming execution** from a checkpoint requires three steps:
1. **Load** the checkpoint data from storage
2. **Reconstruct** the agent's state in memory
3. **Continue** execution from where it left off

**Key Challenges**:
- Ensuring idempotency (don't re-execute completed steps)
- Handling partial results (mid-operation failures)
- Validating checkpoint integrity (corruption detection)
- Managing side effects (external state changes)

---

## Resume Process

### Three-Phase Recovery

```
┌────────────────────────────────────────────────────┐
│  PHASE 1: LOAD CHECKPOINT                          │
│  • Query database for latest checkpoint            │
│  • Deserialize JSON → state objects                │
│  • Validate schema version and integrity           │
└────────────────────────────────────────────────────┘
              ↓
┌────────────────────────────────────────────────────┐
│  PHASE 2: RECONSTRUCT STATE                        │
│  • Restore conversation history                    │
│  • Rebuild working memory (entities, facts)        │
│  • Identify current step/phase                     │
│  • Reconnect to external resources                 │
└────────────────────────────────────────────────────┘
              ↓
┌────────────────────────────────────────────────────┐
│  PHASE 3: CONTINUE EXECUTION                       │
│  • Skip completed steps                            │
│  • Resume from current step                        │
│  • Maintain normal checkpoint cadence              │
└────────────────────────────────────────────────────┘
```

---

## Loading Checkpoints

### Basic Load Operation

```typescript
interface LoadedCheckpoint {
  id: string;
  threadId: string;
  timestamp: string;
  state: AgentState;
}

async function loadCheckpoint(threadId: string): Promise<LoadedCheckpoint | null> {
  // Query latest checkpoint for thread
  const result = await db.query(
    `SELECT * FROM checkpoints 
     WHERE thread_id = $1 
     ORDER BY timestamp DESC 
     LIMIT 1`,
    [threadId]
  );

  if (result.rows.length === 0) {
    return null; // No checkpoint found
  }

  const row = result.rows[0];
  
  // Deserialize state
  const state = deserialize(row.state_json);

  return {
    id: row.id,
    threadId: row.thread_id,
    timestamp: row.timestamp,
    state,
  };
}
```

### Checkpoint Validation

```typescript
function validateCheckpoint(checkpoint: LoadedCheckpoint): boolean {
  // 1. Check schema version
  if (checkpoint.state.version !== CURRENT_VERSION) {
    checkpoint.state = migrateCheckpoint(checkpoint.state);
  }

  // 2. Validate required fields
  if (!checkpoint.state.messages || !Array.isArray(checkpoint.state.messages)) {
    throw new Error("Invalid checkpoint: missing messages");
  }

  // 3. Check timestamp (reject too old)
  const age = Date.now() - new Date(checkpoint.timestamp).getTime();
  const MAX_AGE = 30 * 24 * 60 * 60 * 1000; // 30 days
  
  if (age > MAX_AGE) {
    console.warn(`Checkpoint is ${age}ms old - may be stale`);
  }

  // 4. Verify integrity (checksum if available)
  if (checkpoint.state.checksum) {
    const computed = computeChecksum(checkpoint.state);
    if (computed !== checkpoint.state.checksum) {
      throw new Error("Checkpoint corrupted - checksum mismatch");
    }
  }

  return true;
}
```

---

## State Reconstruction

### Rebuilding Agent State

```typescript
async function reconstructState(checkpoint: LoadedCheckpoint): Promise<AgentState> {
  const state: AgentState = {
    // 1. Restore conversation history
    messages: checkpoint.state.messages.map(deserializeMessage),

    // 2. Rebuild working memory
    memory: {
      entities: new Map(checkpoint.state.memory.entities),
      facts: checkpoint.state.memory.facts,
      references: new Map(checkpoint.state.memory.references),
    },

    // 3. Restore execution state
    phase: checkpoint.state.execution.phase,
    currentStep: checkpoint.state.execution.currentStep,
    completedSteps: new Set(checkpoint.state.execution.completedSteps),

    // 4. Restore subgoals
    subgoals: checkpoint.state.subgoals.map(deserializeSubgoal),

    // 5. Restore metadata
    userId: checkpoint.state.metadata.userId,
    sessionId: checkpoint.state.metadata.sessionId,
    config: checkpoint.state.metadata.config,
  };

  return state;
}
```

### Reconnecting External Resources

```typescript
async function reconnectResources(state: AgentState): Promise<void> {
  // 1. Re-establish database connections
  await connectDatabase();

  // 2. Reinitialize LLM client
  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

  // 3. Restore vector database connection
  const vectorDB = await lancedb.connect("./lancedb");

  // 4. Reload user context (if needed)
  const userContext = await loadUserContext(state.userId);
  state.userContext = userContext;

  // 5. Validate external state consistency
  await validateExternalState(state);
}
```

---

## Execution Continuation

### Resuming from Checkpoint

```typescript
async function resumeExecution(threadId: string, newMessage?: string): Promise<any> {
  // 1. Load checkpoint
  const checkpoint = await loadCheckpoint(threadId);
  
  if (!checkpoint) {
    // No checkpoint - start new conversation
    return startNewConversation(threadId, newMessage);
  }

  // 2. Validate and reconstruct
  validateCheckpoint(checkpoint);
  const state = await reconstructState(checkpoint);
  await reconnectResources(state);

  console.log(`Resuming from step ${state.currentStep} (phase: ${state.phase})`);

  // 3. Add new message if provided
  if (newMessage) {
    state.messages.push({
      role: "user",
      content: newMessage,
      timestamp: new Date().toISOString(),
    });
  }

  // 4. Continue execution from current step
  return await continueWorkflow(state);
}

async function continueWorkflow(state: AgentState): Promise<any> {
  const workflow = getWorkflow(); // Get workflow definition

  // Find where to resume
  const remainingSteps = workflow.steps.slice(state.currentStep);

  for (const step of remainingSteps) {
    // Skip if already completed
    if (state.completedSteps.has(step.id)) {
      console.log(`Skipping completed step: ${step.id}`);
      continue;
    }

    // Execute step
    console.log(`Executing step ${state.currentStep}: ${step.id}`);
    const result = await executeStep(step, state);

    // Update state
    state.currentStep++;
    state.completedSteps.add(step.id);

    // Checkpoint after step (normal cadence)
    if (shouldCheckpoint(state)) {
      await checkpoint.save(state);
    }
  }

  // Mark workflow complete
  state.phase = "complete";
  await checkpoint.save(state);

  return { status: "complete", result: state.result };
}
```

### Handling Partial Results

```typescript
async function handlePartialExecution(state: AgentState): Promise<void> {
  const lastStep = workflow.steps[state.currentStep - 1];

  // Check if last step completed successfully
  if (!lastStep.result) {
    console.warn(`Last step ${lastStep.id} has no result - may be partial`);

    // Option 1: Re-execute last step
    if (lastStep.idempotent) {
      console.log(`Re-executing idempotent step: ${lastStep.id}`);
      const result = await executeStep(lastStep, state);
      state.completedSteps.add(lastStep.id);
    }

    // Option 2: Skip and continue (if safe)
    else if (lastStep.optional) {
      console.log(`Skipping optional step: ${lastStep.id}`);
      state.currentStep++;
    }

    // Option 3: Fail and require manual intervention
    else {
      throw new Error(`Cannot resume: step ${lastStep.id} incomplete and not idempotent`);
    }
  }
}
```

---

## Handling Edge Cases

### 1. Checkpoint Not Found (First Run)

```typescript
async function getOrCreateCheckpoint(threadId: string): Promise<AgentState> {
  const checkpoint = await loadCheckpoint(threadId);

  if (checkpoint) {
    // Resume existing conversation
    return await reconstructState(checkpoint);
  } else {
    // Start new conversation
    console.log(`No checkpoint found for ${threadId} - starting fresh`);
    return {
      messages: [],
      memory: { entities: new Map(), facts: [], references: new Map() },
      phase: "init",
      currentStep: 0,
      completedSteps: new Set(),
      userId: extractUserId(threadId),
      sessionId: generateSessionId(),
    };
  }
}
```

### 2. Checkpoint Corrupted

```typescript
async function loadWithFallback(threadId: string): Promise<AgentState> {
  try {
    const checkpoint = await loadCheckpoint(threadId);
    validateCheckpoint(checkpoint);
    return await reconstructState(checkpoint);
  } catch (error) {
    console.error("Checkpoint corrupted:", error);

    // Fallback: Load previous checkpoint
    const previousCheckpoint = await loadPreviousCheckpoint(threadId);
    
    if (previousCheckpoint) {
      console.log("Falling back to previous checkpoint");
      return await reconstructState(previousCheckpoint);
    }

    // Ultimate fallback: Start fresh
    console.warn("No valid checkpoint - starting fresh");
    return initializeNewState(threadId);
  }
}
```

### 3. External State Mismatch

```typescript
async function validateExternalState(state: AgentState): Promise<void> {
  // Check if external resources still exist
  for (const resource of state.externalResources || []) {
    const exists = await checkResourceExists(resource.id);
    
    if (!exists) {
      console.warn(`External resource ${resource.id} no longer exists`);
      
      // Remove from state
      state.externalResources = state.externalResources.filter(
        (r) => r.id !== resource.id
      );
    }
  }
}
```

---

## Implementation Examples

### LangGraph Resume

```typescript
import { StateGraph, PostgresSaver } from "@langchain/langgraph";
import { Pool } from "pg";

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const checkpointer = new PostgresSaver(pool);

// Compile workflow with checkpointer
const app = workflow.compile({ checkpointer });

// First invocation - creates checkpoint
const config1 = { configurable: { thread_id: "thread_123" } };
await app.invoke({ messages: ["Start task"] }, config1);

// ... crash/restart ...

// Second invocation - automatically resumes from checkpoint
const config2 = { configurable: { thread_id: "thread_123" } };
await app.invoke({ messages: ["Continue task"] }, config2);
// ✅ LangGraph automatically loads checkpoint and resumes
```

### Manual Resume System

```typescript
class ResumableAgent {
  private checkpointer: CheckpointManager;

  async run(threadId: string, userMessage: string): Promise<string> {
    // Load or create checkpoint
    let state = await this.loadOrCreate(threadId);

    // Add user message
    state.messages.push({
      role: "user",
      content: userMessage,
      timestamp: new Date().toISOString(),
    });

    // Continue from current step
    while (state.currentStep < this.workflow.length) {
      const step = this.workflow[state.currentStep];

      // Skip completed
      if (state.completedSteps.has(step.id)) {
        state.currentStep++;
        continue;
      }

      // Execute
      try {
        const result = await this.executeStep(step, state);
        state.completedSteps.add(step.id);
        state.currentStep++;

        // Checkpoint every 3 steps
        if (state.currentStep % 3 === 0) {
          await this.checkpointer.save(state);
        }
      } catch (error) {
        // Save error state
        await this.checkpointer.save({
          ...state,
          error: error.message,
        });
        throw error;
      }
    }

    // Final checkpoint
    state.phase = "complete";
    await this.checkpointer.save(state);

    return state.result;
  }

  private async loadOrCreate(threadId: string): Promise<AgentState> {
    const checkpoint = await this.checkpointer.load(threadId);
    
    if (checkpoint) {
      console.log(`Resuming from checkpoint: ${checkpoint.id}`);
      return checkpoint.state;
    }

    console.log("Starting new conversation");
    return this.initializeState(threadId);
  }
}
```

---

## Production Patterns

### Idempotent Step Execution

```typescript
async function executeStepIdempotent(
  step: WorkflowStep,
  state: AgentState
): Promise<any> {
  // Check if step already has a result
  const existingResult = state.stepResults.get(step.id);
  
  if (existingResult) {
    console.log(`Using cached result for step ${step.id}`);
    return existingResult;
  }

  // Execute step
  const result = await step.execute(state);

  // Cache result
  state.stepResults.set(step.id, result);

  return result;
}
```

### Checkpoint History Navigation

```typescript
async function listCheckpoints(threadId: string): Promise<Checkpoint[]> {
  const result = await db.query(
    `SELECT id, timestamp, state->>'phase' as phase, state->>'currentStep' as step
     FROM checkpoints
     WHERE thread_id = $1
     ORDER BY timestamp DESC`,
    [threadId]
  );

  return result.rows;
}

async function resumeFromSpecificCheckpoint(checkpointId: string): Promise<AgentState> {
  const checkpoint = await db.query(
    "SELECT * FROM checkpoints WHERE id = $1",
    [checkpointId]
  );

  if (!checkpoint.rows[0]) {
    throw new Error(`Checkpoint ${checkpointId} not found`);
  }

  return await reconstructState(checkpoint.rows[0]);
}
```

---

## Best Practices

### 1. Always Validate Before Resume

```typescript
// ✅ Validate checkpoint integrity
const checkpoint = await loadCheckpoint(threadId);
if (!validateCheckpoint(checkpoint)) {
  throw new Error("Invalid checkpoint");
}
```

### 2. Log Resume Events

```typescript
// ✅ Track resume operations for debugging
console.log({
  event: "checkpoint_resume",
  threadId,
  checkpointId: checkpoint.id,
  age: Date.now() - new Date(checkpoint.timestamp).getTime(),
  step: checkpoint.state.currentStep,
});
```

### 3. Handle Missing Dependencies

```typescript
// ✅ Gracefully handle missing resources
if (!await resourceExists(state.resourceId)) {
  console.warn("Resource missing - re-fetching");
  state.resource = await refetchResource(state.resourceId);
}
```

---

## Common Pitfalls

### 1. ❌ Not Skipping Completed Steps

```typescript
// ❌ Re-executes everything
for (const step of workflow) {
  await executeStep(step);
}

// ✅ Skip completed steps
for (const step of workflow) {
  if (state.completedSteps.has(step.id)) continue;
  await executeStep(step);
}
```

### 2. ❌ Assuming External State Unchanged

```typescript
// ❌ Use cached IDs without validation
await deleteFile(state.fileId); // May no longer exist!

// ✅ Verify before using
if (await fileExists(state.fileId)) {
  await deleteFile(state.fileId);
}
```

### 3. ❌ Ignoring Schema Migrations

```typescript
// ❌ Assume schema is current
const state = JSON.parse(checkpoint.state);

// ✅ Migrate old schemas
const state = migrateToCurrentVersion(JSON.parse(checkpoint.state));
```

---

## Related Topics

- **[4.4.1 Why Checkpoint](./4.4.1-why-checkpoint.md)** - Benefits and use cases
- **[4.4.2 What to Save](./4.4.2-what-to-save.md)** - State components to checkpoint
- **[4.4.3 When to Checkpoint](./4.4.3-when-to-checkpoint.md)** - Optimal timing strategies
- **[4.4.5 Implementation Patterns](./4.4.5-implementation.md)** - Database storage details

---

## References

[^1]: "Persisting and Resuming Agent Conversations" - Microsoft Agent Framework (2025)
[^2]: "LangGraph v0.2: Increased customization with new checkpointer libraries" - LangChain (2024)
[^3]: "Agent Persistence - Koog" - Koog Documentation (2025)

---

**Next**: [4.4.5 Implementation Patterns](./4.4.5-implementation.md) - Deep dive into JSON serialization and database storage.

**Previous**: [4.4.3 When to Checkpoint](./4.4.3-when-to-checkpoint.md) - Understanding optimal checkpoint timing and frequency.
