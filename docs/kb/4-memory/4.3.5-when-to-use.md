# 4.3.5 When to Use Long-Term Memory vs Working Memory

**Layer**: 4 - Memory & State  
**Sublayer**: 4.3 - Episodic Memory (Long-Term)  
**Audience**: Intermediate  
**Updated**: 2025-11-18

---

## Table of Contents

- [Overview](#overview)
- [Memory Type Comparison](#memory-type-comparison)
- [Decision Framework](#decision-framework)
- [Use Case Matrix](#use-case-matrix)
- [Cost-Benefit Analysis](#cost-benefit-analysis)
- [Implementation Guide](#implementation-guide)
- [Hybrid Strategies](#hybrid-strategies)
- [Performance Trade-offs](#performance-trade-offs)
- [Best Practices](#best-practices)
- [Common Pitfalls](#common-pitfalls)
- [Related Topics](#related-topics)
- [References](#references)

---

## Overview

Choosing between **working memory** (short-term) and **long-term memory** (episodic/semantic) is crucial for building cost-effective, performant AI agents. Each memory type has distinct characteristics, trade-offs, and ideal use cases[^1].

**Simple Rule of Thumb**:
- **Working Memory**: Needed within current session (minutes to hours)
- **Long-Term Memory**: Needed across sessions (days to months/years)

**Example**:
```typescript
// Working Memory: Current conversation context
User: "I like TypeScript" (Session 1, Message 1)
Agent: "Great! Let me show you TypeScript examples..." (Session 1, Message 2)
// âœ… Store in working memory (conversation history)

// Long-Term Memory: Persistent preference
User: "Remember: I always prefer TypeScript" (Session 1, Message 3)
// âœ… Extract fact + store in long-term memory

// Next session (2 weeks later)
User: "Show me code examples" (Session 2, Message 1)
Agent: *retrieves from long-term memory* "Here's a TypeScript example!"
// âœ… Working memory is empty (new session), but long-term memory persists
```

---

## Memory Type Comparison

### Three Memory Types

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. WORKING MEMORY (Short-Term)                         â”‚
â”‚  Duration: Current session only (30 min - 24 hours)     â”‚
â”‚  Storage: In-memory (Redis, local state)                â”‚
â”‚  Retrieval: Automatic (always in context window)        â”‚
â”‚  Cost: Low (no API calls for retrieval)                 â”‚
â”‚  Use Case: Conversation history, temporary entities     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. EPISODIC MEMORY (Medium-Term)                       â”‚
â”‚  Duration: Recent sessions (7-30 days)                  â”‚
â”‚  Storage: Vector DB + Key-Value Store                   â”‚
â”‚  Retrieval: Query-based (semantic search)               â”‚
â”‚  Cost: Medium ($0.01-0.05 per query)                    â”‚
â”‚  Use Case: Recent facts, events, interactions           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. SEMANTIC MEMORY (Long-Term)                         â”‚
â”‚  Duration: Indefinite (months to years)                 â”‚
â”‚  Storage: Vector DB + Graph DB                          â”‚
â”‚  Retrieval: Query-based + relationship traversal        â”‚
â”‚  Cost: Medium-High ($0.02-0.10 per query)               â”‚
â”‚  Use Case: Core preferences, relationships, knowledge   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Feature Comparison Table

| Feature               | Working Memory     | Episodic Memory    | Semantic Memory    |
|-----------------------|--------------------|--------------------|-------------------- |
| **Duration**          | Minutes - Hours    | Days - Weeks       | Months - Years      |
| **Persistence**       | âŒ No (ephemeral)  | âœ… Yes (temporary) | âœ… Yes (permanent)  |
| **Retrieval Speed**   | âš¡ Instant (0ms)   | ğŸŸ¡ Fast (20-50ms)  | ğŸŸ  Moderate (50-100ms)|
| **Cost per Query**    | ğŸ’° Free            | ğŸ’°ğŸ’° Low ($0.01)   | ğŸ’°ğŸ’°ğŸ’° Medium ($0.05)|
| **Storage Cost**      | ğŸ’° $0/month        | ğŸ’°ğŸ’° $5-20/month   | ğŸ’°ğŸ’°ğŸ’° $20-100/month|
| **Capacity**          | Limited (10-20 msgs)| Medium (1k-10k)   | High (10k-1M+)      |
| **Automatic?**        | âœ… Yes             | âŒ No (manual add) | âŒ No (manual add)  |
| **Cross-Session?**    | âŒ No              | âœ… Yes             | âœ… Yes              |

---

## Decision Framework

### Decision Tree

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Is this information needed AFTER the current          â”‚
â”‚  session ends?                                         â”‚
â”‚                                                        â”‚
â”‚  YES â”€â”€â†’ Long-Term Memory                              â”‚
â”‚  NO â”€â”€â”€â†’ Continue...                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Is this information needed MORE THAN once within      â”‚
â”‚  the session?                                          â”‚
â”‚                                                        â”‚
â”‚  YES â”€â”€â†’ Working Memory (extract entity)               â”‚
â”‚  NO â”€â”€â”€â†’ Working Memory (conversation history)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Questions to Ask

**Question 1: Lifetime**
- **Q**: "Will this information be useful next week?"
- **YES** â†’ Long-Term Memory (Episodic or Semantic)
- **NO** â†’ Working Memory

**Question 2: Importance**
- **Q**: "Is this a core user preference or just casual context?"
- **Core Preference** â†’ Semantic Memory (permanent)
- **Temporary Context** â†’ Working Memory or Episodic Memory

**Question 3: Frequency**
- **Q**: "How often will this be referenced?"
- **Every session** â†’ Semantic Memory (cache it)
- **Occasionally** â†’ Episodic Memory
- **Once or twice** â†’ Working Memory

**Question 4: Cost Sensitivity**
- **Q**: "Is retrieval cost a concern?"
- **YES** â†’ Use Working Memory when possible
- **NO** â†’ Use Long-Term Memory for richer context

---

## Use Case Matrix

### When to Use Working Memory

| Use Case                          | Why Working Memory?                                      |
|-----------------------------------|----------------------------------------------------------|
| **Conversation History**          | Auto-included in context window, no retrieval cost      |
| **Temporary References**          | "this page", "that entry" - only valid during session   |
| **Transient Entities**            | "John called earlier" - not important after session      |
| **Short-Term Context**            | User is editing document - context only needed while editing |
| **Streaming State**               | Partial results during long-running tasks                |

**Example: Customer Support Chat**
```typescript
// Session 1: User reports issue
User: "My order #12345 hasn't arrived"
Agent: "Let me check order #12345..." // âœ… Working memory (session-specific)

// Session ends â†’ Working memory cleared
// Order #12345 is NOT relevant to future sessions (issue resolved)
```

---

### When to Use Episodic Memory

| Use Case                          | Why Episodic Memory?                                     |
|-----------------------------------|----------------------------------------------------------|
| **Recent Interactions**           | Facts from last few sessions (may still be relevant)     |
| **Temporary Preferences**         | "I'm on a diet this month" - short-term goal            |
| **Session-Linked Events**         | "Last time we discussed X" - context for next session    |
| **Trial Periods**                 | User testing feature - preference may change             |

**Example: Personal AI Assistant**
```typescript
// Week 1: User shares temporary constraint
User: "I'm training for a marathon, so suggest healthy meals"
Agent: storeFact("diet_goal", "marathon_training", TTL: 90 days) // Episodic memory

// Week 5: Still relevant
Agent: "Based on your marathon training, here's a high-protein meal..."

// Month 4: Auto-expires after 90 days (goal likely achieved/changed)
```

---

### When to Use Semantic Memory

| Use Case                          | Why Semantic Memory?                                     |
|-----------------------------------|----------------------------------------------------------|
| **Core Preferences**              | "I prefer dark mode" - permanent preference              |
| **Relationships**                 | "Alice reports to Bob" - organizational structure        |
| **Medical Info**                  | "Allergic to peanuts" - critical, never forget           |
| **User Profile Data**             | Name, email, location, timezone                          |
| **Long-Term Goals**               | "Learning TypeScript" - ongoing, multi-month goal        |

**Example: Healthcare AI Agent**
```typescript
// Initial consultation
User: "I'm allergic to peanuts and penicillin"
Agent: storeFact("allergy", "peanuts", permanent: true) // Semantic memory
Agent: storeFact("allergy", "penicillin", permanent: true) // Semantic memory

// 6 months later
Agent: *prescribes medication*
// âœ… Automatically checks semantic memory for allergies
// âŒ Never prescribes penicillin
```

---

## Cost-Benefit Analysis

### Scenario 1: E-commerce Chatbot

**User Profile**:
- 10,000 active users
- 5 sessions per user per month
- 10 messages per session

**Memory Strategy**:

| Memory Type       | What to Store                | Cost/Month  | Benefit                          |
|-------------------|------------------------------|-------------|----------------------------------|
| **Working**       | Current session history      | $0          | Conversation context (free)      |
| **Episodic**      | Recent searches, views       | $50         | "You looked at X last week"      |
| **Semantic**      | Preferences, purchase history| $200        | Personalized recommendations     |
| **Total**         | -                            | **$250**    | 30% higher conversion rate       |

**ROI**: $250/month â†’ 30% conversion lift â†’ +$5,000 revenue/month = **20x ROI**

---

### Scenario 2: Personal Productivity Assistant

**User Profile**:
- 1,000 power users (daily usage)
- 20 sessions per user per month
- 50 messages per session

**Memory Strategy**:

| Memory Type       | What to Store                | Cost/Month  | Benefit                          |
|-------------------|------------------------------|-------------|----------------------------------|
| **Working**       | Current task context         | $0          | In-task assistance (free)        |
| **Episodic**      | Weekly goals, deadlines      | $100        | "Your deadline is tomorrow"      |
| **Semantic**      | Habits, work style, contacts | $500        | Deep personalization             |
| **Total**         | -                            | **$600**    | 50% time savings for users       |

**ROI**: $600/month â†’ 50% productivity gain â†’ +$10,000 value/month = **16x ROI**

---

### Scenario 3: Customer Support Bot

**User Profile**:
- 100,000 monthly users (mostly one-time)
- 1.5 sessions per user per month
- 5 messages per session

**Memory Strategy**:

| Memory Type       | What to Store                | Cost/Month  | Benefit                          |
|-------------------|------------------------------|-------------|----------------------------------|
| **Working**       | Current issue context        | $0          | Resolve issue in session (free)  |
| **Episodic**      | Recent issues (30 days)      | $200        | "Your previous issue was X"      |
| **Semantic**      | âŒ Skip                      | $0          | Most users don't return          |
| **Total**         | -                            | **$200**    | 20% faster resolution            |

**Key Decision**: Skip semantic memory (most users are one-time), focus on episodic for repeat customers.

---

## Implementation Guide

### Complete Hybrid System

```typescript
import { OpenAI } from "openai";
import lancedb from "lancedb";
import Redis from "ioredis";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const vectorDB = await lancedb.connect("./lancedb");
const redis = new Redis();

interface MemoryConfig {
  working_memory_size: number; // Number of messages to keep
  episodic_ttl_days: number; // Auto-expire after N days
  semantic_categories: string[]; // Which categories are permanent
}

class HybridMemorySystem {
  private config: MemoryConfig;

  constructor(config: MemoryConfig) {
    this.config = config;
  }

  // 1. Add memory (automatically categorized)
  async add(userId: string, sessionId: string, content: string) {
    // Classify memory type using LLM
    const classification = await this.classifyMemory(content);

    if (classification.type === "working") {
      // Store in Redis (working memory)
      await redis.lpush(`session:${sessionId}:messages`, content);
      await redis.ltrim(
        `session:${sessionId}:messages`,
        0,
        this.config.working_memory_size - 1
      );
      await redis.expire(`session:${sessionId}:messages`, 3600); // 1 hour
    } else if (classification.type === "episodic") {
      // Store in vector DB with TTL
      await this.storeEpisodic(userId, content, this.config.episodic_ttl_days);
    } else if (classification.type === "semantic") {
      // Store in vector DB + graph DB (permanent)
      await this.storeSemantic(userId, content, classification.category);
    }
  }

  // 2. Classify memory type
  private async classifyMemory(
    content: string
  ): Promise<{ type: "working" | "episodic" | "semantic"; category?: string }> {
    const prompt = `Classify the following information:
"${content}"

Categories:
- working: Temporary context (only needed in current session)
- episodic: Recent context (may be useful next session)
- semantic: Permanent fact (core preference, medical, etc.)

Return JSON: { "type": "...", "category": "..." }`;

    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [{ role: "user", content: prompt }],
      response_format: { type: "json_object" },
    });

    return JSON.parse(response.choices[0].message.content!);
  }

  // 3. Store episodic memory (with TTL)
  private async storeEpisodic(userId: string, content: string, ttlDays: number) {
    const embedding = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: content,
    });

    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + ttlDays);

    const table = await vectorDB.openTable("episodic_memory");
    await table.add([
      {
        id: crypto.randomUUID(),
        user_id: userId,
        content,
        vector: embedding.data[0].embedding,
        expires_at: expiresAt.toISOString(),
      },
    ]);
  }

  // 4. Store semantic memory (permanent)
  private async storeSemantic(userId: string, content: string, category: string) {
    const embedding = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: content,
    });

    const table = await vectorDB.openTable("semantic_memory");
    await table.add([
      {
        id: crypto.randomUUID(),
        user_id: userId,
        content,
        category,
        vector: embedding.data[0].embedding,
        permanent: true,
      },
    ]);
  }

  // 5. Retrieve relevant memories (hybrid search)
  async retrieve(query: string, userId: string, sessionId: string) {
    // Step 1: Working memory (current session)
    const workingMemory = await redis.lrange(`session:${sessionId}:messages`, 0, -1);

    // Step 2: Episodic memory (recent sessions, not expired)
    const episodicTable = await vectorDB.openTable("episodic_memory");
    const episodicResults = await episodicTable
      .search(await this.embed(query))
      .where(`user_id = '${userId}' AND expires_at > '${new Date().toISOString()}'`)
      .limit(5)
      .execute();

    // Step 3: Semantic memory (permanent facts)
    const semanticTable = await vectorDB.openTable("semantic_memory");
    const semanticResults = await semanticTable
      .search(await this.embed(query))
      .where(`user_id = '${userId}'`)
      .limit(3)
      .execute();

    return {
      working: workingMemory,
      episodic: episodicResults.map((r) => r.content),
      semantic: semanticResults.map((r) => r.content),
    };
  }

  private async embed(text: string): Promise<number[]> {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: text,
    });
    return response.data[0].embedding;
  }
}

// Usage
const memory = new HybridMemorySystem({
  working_memory_size: 20,
  episodic_ttl_days: 30,
  semantic_categories: ["preference", "medical", "profile"],
});

// Add memories (auto-classified)
await memory.add("user_123", "sess_001", "I prefer dark mode"); // â†’ Semantic
await memory.add("user_123", "sess_001", "Order #12345 is delayed"); // â†’ Working
await memory.add("user_123", "sess_001", "I'm learning TypeScript this month"); // â†’ Episodic

// Retrieve all relevant memories
const memories = await memory.retrieve("What are my preferences?", "user_123", "sess_002");
console.log(memories);
// {
//   working: [],  // New session, no working memory
//   episodic: ["I'm learning TypeScript this month"],
//   semantic: ["I prefer dark mode"]
// }
```

---

## Hybrid Strategies

### Strategy 1: Promote to Long-Term

**Start with working memory, promote if accessed multiple times**

```typescript
async function trackMemoryAccess(userId: string, sessionId: string, content: string) {
  const accessKey = `access:${userId}:${hashContent(content)}`;
  const accessCount = await redis.incr(accessKey);
  await redis.expire(accessKey, 86400); // 24 hour window

  if (accessCount >= 3) {
    // Accessed 3+ times â†’ promote to episodic memory
    await memory.storeEpisodic(userId, content, 30);
    console.log(`Promoted to episodic: "${content}"`);
  }
}
```

### Strategy 2: Downgrade to Working

**If episodic memory is rarely accessed, stop storing it long-term**

```typescript
async function auditEpisodicMemory(userId: string) {
  const memories = await vectorDB.query(
    `SELECT id, content, last_accessed FROM episodic_memory WHERE user_id = '${userId}'`
  );

  for (const mem of memories) {
    const daysSinceAccess =
      (Date.now() - new Date(mem.last_accessed).getTime()) / (1000 * 60 * 60 * 24);

    if (daysSinceAccess > 60) {
      // Not accessed in 60 days â†’ delete
      await vectorDB.delete(mem.id);
      console.log(`Deleted unused episodic memory: "${mem.content}"`);
    }
  }
}
```

### Strategy 3: Smart Caching

**Cache frequently accessed semantic memories in Redis**

```typescript
async function getSemanticWithCache(userId: string, query: string) {
  const cacheKey = `semantic_cache:${userId}:${query}`;
  const cached = await redis.get(cacheKey);

  if (cached) {
    return JSON.parse(cached); // âš¡ 1ms latency
  }

  // Cache miss â†’ query vector DB
  const results = await vectorDB.search(query, userId); // ğŸŸ  50ms latency
  await redis.set(cacheKey, JSON.stringify(results), "EX", 3600); // Cache 1 hour

  return results;
}
```

---

## Performance Trade-offs

### Latency Comparison (per Query)

| Memory Type       | Retrieval Latency | Cost per Query |
|-------------------|-------------------|----------------|
| **Working**       | 0ms (in context)  | $0             |
| **+ Redis Cache** | 1-5ms             | $0.0001        |
| **+ Vector DB**   | 20-50ms           | $0.01-0.02     |
| **+ Graph DB**    | 50-100ms          | $0.05-0.10     |

**Recommendation**: Use working memory when possible, cache frequent semantic queries in Redis.

---

## Best Practices

### 1. Clear Memory Boundaries

```typescript
// âœ… Good: Explicit memory tier selection
await memory.addWorking(sessionId, "Order #12345"); // Session-specific
await memory.addEpisodic(userId, "Learning TypeScript", 30); // 30-day TTL
await memory.addSemantic(userId, "Allergic to peanuts"); // Permanent

// âŒ Bad: Implicit/automatic (hard to debug)
await memory.add(userId, content); // Which tier? Who knows!
```

### 2. Monitoring & Observability

```typescript
// Track memory usage metrics
console.log({
  working_memory_size: await redis.llen(`session:${sessionId}:messages`),
  episodic_memory_count: await vectorDB.count("episodic_memory", { user_id: userId }),
  semantic_memory_count: await vectorDB.count("semantic_memory", { user_id: userId }),
  total_cost_per_month: calculateCost(usage),
});
```

### 3. Graceful Degradation

```typescript
// Fallback if long-term memory is unavailable
try {
  const memories = await memory.retrieve(query, userId, sessionId);
} catch (error) {
  console.error("Memory retrieval failed:", error);
  // âœ… Fallback to working memory only
  return { working: await getWorkingMemory(sessionId) };
}
```

---

## Common Pitfalls

### 1. âŒ Over-Storing in Long-Term Memory

```typescript
// âŒ Bad: Storing everything in semantic memory
User: "I like coffee"
Agent: storeSemantic("likes_coffee", permanent: true) // Overkill!

// âœ… Good: Only store important facts
User: "I'm allergic to caffeine"
Agent: storeSemantic("allergy_caffeine", permanent: true) // Critical!
```

### 2. âŒ No TTL on Episodic Memory

```typescript
// âŒ Bad: Episodic memories never expire
await memory.addEpisodic(userId, "I'm traveling to Japan next week");
// 1 year later: Still stored, never accessed â†’ wasted cost

// âœ… Good: Set appropriate TTL
await memory.addEpisodic(userId, "I'm traveling to Japan next week", TTL: 14); // 2 weeks
```

### 3. âŒ Ignoring Cost

```typescript
// âŒ Bad: Using vector DB for every query
for (const query of userQueries) {
  await vectorDB.search(query); // 1000 queries Ã— $0.02 = $20!
}

// âœ… Good: Cache frequent queries
const cached = await redis.get(query);
if (!cached) {
  const results = await vectorDB.search(query);
  await redis.set(query, JSON.stringify(results), "EX", 3600);
}
```

---

## Related Topics

- **[4.1 Working Memory](./4.1.1-working-memory-concept.md)** - Short-term memory for current session
- **[4.2 Subgoal Memory](./4.2.1-hiagent-hierarchical-memory.md)** - Medium-term memory with compression
- **[4.3.1 Vector Databases](./4.3.1-vector-databases.md)** - Storage for long-term memory
- **[4.3.4 Cross-Session Retrieval](./4.3.4-cross-session-retrieval.md)** - Retrieving facts across sessions
- **[11.4 Cost Optimization](../../11-production/11.4.1-token-reduction.md)** - Reducing memory costs

---

## References

[^1]: "Memory Types - Mem0" - Mem0 Documentation (2024): https://docs.mem0.ai/v0x/core-concepts/memory-types

---

**Next**: [4.4 State Persistence & Checkpointing](./4.4.1-why-checkpoint.md) - Saving agent state for crash recovery and session resumption.

**Previous**: [4.3.4 Cross-Session Retrieval](./4.3.4-cross-session.md) - Maintaining context across multiple conversations.
