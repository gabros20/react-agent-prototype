# 4.4.2 What to Save: Messages, Phase, Subgoals, Memory

**Layer**: 4 - Memory & State  
**Sublayer**: 4.4 - State Persistence & Checkpointing  
**Audience**: Intermediate  
**Updated**: 2025-11-18

---

## Table of Contents

- [Overview](#overview)
- [Core State Components](#core-state-components)
- [What to Include](#what-to-include)
- [What to Exclude](#what-to-exclude)
- [State Serialization](#state-serialization)
- [Size Optimization](#size-optimization)
- [Security Considerations](#security-considerations)
- [Implementation Examples](#implementation-examples)
- [Production Patterns](#production-patterns)
- [Best Practices](#best-practices)
- [Common Pitfalls](#common-pitfalls)
- [Related Topics](#related-topics)
- [References](#references)

---

## Overview

**What to save** in a checkpoint determines whether your AI agent can **successfully resume execution** after interruption[^1]. Too little data → can't resume; too much data → slow and expensive.

**The Golden Rule**: Save **just enough** state to reconstruct the exact execution context, but **no more**.

**Essential Components**:
1. **Conversation History** (messages exchanged)
2. **Execution State** (current phase, step number)
3. **Working Memory** (extracted entities, facts)
4. **Subgoals & Progress** (task breakdown, completion status)
5. **Metadata** (timestamps, user context, config)

---

## Core State Components

### 1. Messages (Conversation History)

**What**: All messages exchanged between user and agent

**Why**: LLMs need full conversation context to generate coherent responses

**Example**:
```typescript
interface Message {
  role: "user" | "assistant" | "system";
  content: string;
  timestamp: string;
  id?: string;
}

const messages: Message[] = [
  { role: "system", content: "You are a helpful assistant", timestamp: "..." },
  { role: "user", content: "Help me plan a trip to Japan", timestamp: "..." },
  { role: "assistant", content: "I'd be happy to help! ...", timestamp: "..." },
];
```

**Size Consideration**: Average message = 100-500 tokens → 10 messages = 1,000-5,000 tokens

**Optimization**: Compress old messages (summarize after N messages)[^2]

---

### 2. Execution State (Phase & Step)

**What**: Current position in workflow execution

**Why**: Know where to resume (skip completed steps)

**Example**:
```typescript
interface ExecutionState {
  phase: "planning" | "executing" | "reviewing" | "complete";
  currentStep: number;
  totalSteps: number;
  stepHistory: string[]; // ["research", "analyze", "draft"]
  completedSteps: Set<string>;
}

const state: ExecutionState = {
  phase: "executing",
  currentStep: 5,
  totalSteps: 10,
  stepHistory: ["research", "analyze", "draft", "review", "edit"],
  completedSteps: new Set(["research", "analyze", "draft", "review"]),
};
```

---

### 3. Working Memory (Entities & Facts)

**What**: Extracted information from conversation

**Why**: Avoid re-extracting entities on every message[^3]

**Example**:
```typescript
interface WorkingMemory {
  entities: Map<string, any>; // Extracted entities
  facts: Array<{ subject: string; predicate: string; object: string }>;
  references: Map<string, string>; // "this page" → page_id
  lastUpdated: string;
}

const memory: WorkingMemory = {
  entities: new Map([
    ["destination", "Japan"],
    ["season", "spring"],
    ["budget", "$3000"],
  ]),
  facts: [
    { subject: "user", predicate: "prefers", object: "direct flights" },
    { subject: "user", predicate: "avoids", object: "crowded places" },
  ],
  references: new Map([
    ["this trip", "trip_12345"],
    ["the budget", "budget_reference"],
  ]),
  lastUpdated: "2025-11-18T10:30:00Z",
};
```

---

### 4. Subgoals & Progress

**What**: Task breakdown and completion status

**Why**: Resume multi-step workflows without re-planning[^4]

**Example**:
```typescript
interface Subgoal {
  id: string;
  description: string;
  status: "pending" | "in_progress" | "completed" | "failed";
  dependencies: string[]; // IDs of prerequisite subgoals
  result?: any;
  startedAt?: string;
  completedAt?: string;
}

const subgoals: Subgoal[] = [
  {
    id: "sg_1",
    description: "Research flights to Tokyo",
    status: "completed",
    dependencies: [],
    result: { flights: [...], cheapest: "$800" },
    startedAt: "2025-11-18T10:00:00Z",
    completedAt: "2025-11-18T10:05:00Z",
  },
  {
    id: "sg_2",
    description: "Book hotel in Tokyo",
    status: "in_progress",
    dependencies: ["sg_1"],
    startedAt: "2025-11-18T10:06:00Z",
  },
  {
    id: "sg_3",
    description: "Plan itinerary",
    status: "pending",
    dependencies: ["sg_1", "sg_2"],
  },
];
```

---

### 5. Metadata (Context & Config)

**What**: User context, session info, configuration

**Why**: Restore execution environment exactly

**Example**:
```typescript
interface Metadata {
  userId: string;
  sessionId: string;
  threadId: string;
  timestamp: string;
  agentVersion: string;
  config: {
    model: string;
    temperature: number;
    maxTokens: number;
    tools: string[];
  };
  userContext?: {
    timezone: string;
    language: string;
    preferences: Record<string, any>;
  };
}

const metadata: Metadata = {
  userId: "user_123",
  sessionId: "sess_456",
  threadId: "thread_789",
  timestamp: "2025-11-18T10:30:00Z",
  agentVersion: "v2.1.0",
  config: {
    model: "gpt-4o",
    temperature: 0.7,
    maxTokens: 2000,
    tools: ["web_search", "calculator", "file_manager"],
  },
  userContext: {
    timezone: "America/Los_Angeles",
    language: "en",
    preferences: { theme: "dark", notifications: true },
  },
};
```

---

## What to Include

### ✅ Always Include

1. **Conversation Messages**
   - All user/assistant exchanges
   - System prompts (if dynamic)
   - Tool call results

2. **Current Phase/Step**
   - Where in workflow execution
   - Which steps completed
   - Next step to execute

3. **Extracted Entities**
   - Named entities (people, places, dates)
   - User preferences
   - Referenced objects ("this", "that")

4. **Critical Metadata**
   - User ID, session ID, thread ID
   - Timestamp
   - Agent configuration

5. **Pending Actions**
   - Actions awaiting approval
   - Scheduled tasks
   - Incomplete subgoals

---

### ✅ Often Include

6. **Subgoal Hierarchy**
   - Task breakdown structure
   - Dependencies between subgoals
   - Completion status

7. **Tool Call History**
   - Which tools were called
   - With what parameters
   - What they returned

8. **Error History**
   - Previous errors encountered
   - Retry counts
   - Recovery actions taken

9. **User Context**
   - Timezone, language, preferences
   - Previous session links
   - Long-term memory references

---

### ⚠️ Sometimes Include

10. **Intermediate Results**
    - Only if expensive to recompute
    - Compress/summarize if large
    - Consider caching separately

11. **Retrieved Documents**
    - If RAG was performed
    - Store document IDs, not full content
    - Retrieve again on resume if needed

12. **Model Responses**
    - Full LLM responses
    - Reasoning traces (if using o1/o3)
    - Only for debugging/audit trail

---

## What to Exclude

### ❌ Never Include

1. **API Keys / Secrets**
   - Use environment variables
   - Never serialize credentials

2. **Large Binary Data**
   - Images, videos, audio files
   - Store references (URLs, file paths)
   - Retrieve on resume

3. **Computed Values**
   - If can be recalculated quickly (<100ms)
   - Token counts, simple math
   - Derived state

4. **Transient UI State**
   - Scroll position, UI animations
   - Temporary loading states
   - Frontend-only state

5. **Logs**
   - Debug logs should go to logging system
   - Not in checkpoint (except error summary)

---

### ❌ Avoid Including

6. **Full Documents** (RAG)
   - Store document IDs + similarity scores
   - Re-retrieve on resume

7. **Circular References**
   - Can't serialize
   - Flatten structure first

8. **Function Instances**
   - Can't serialize functions
   - Store function name/parameters instead

9. **Non-Deterministic State**
   - Random seeds (unless explicitly saved)
   - Current time (use snapshot time)

---

## State Serialization

### Serialization Format

**JSON** (most common, human-readable):
```typescript
interface Checkpoint {
  version: string; // Schema version (for migration)
  checkpointId: string;
  timestamp: string;
  threadId: string;
  state: {
    messages: Message[];
    execution: ExecutionState;
    memory: WorkingMemory;
    subgoals: Subgoal[];
    metadata: Metadata;
  };
}

// Serialize
const checkpoint: Checkpoint = {
  version: "2.0",
  checkpointId: "ckpt_12345",
  timestamp: new Date().toISOString(),
  threadId: "thread_789",
  state: {
    messages,
    execution: state,
    memory,
    subgoals,
    metadata,
  },
};

const json = JSON.stringify(checkpoint);
await fs.writeFile("checkpoint.json", json);
```

**Size**: JSON is verbose but compresses well (gzip: 60-80% reduction)

---

### Handling Non-Serializable Types

**Problem**: Maps, Sets, Dates, Functions can't be JSON.stringify'd

**Solution**: Custom replacer/reviver

```typescript
// Custom serializer
function serialize(obj: any): string {
  return JSON.stringify(obj, (key, value) => {
    // Handle Map
    if (value instanceof Map) {
      return {
        __type: "Map",
        entries: Array.from(value.entries()),
      };
    }
    // Handle Set
    if (value instanceof Set) {
      return {
        __type: "Set",
        values: Array.from(value),
      };
    }
    // Handle Date
    if (value instanceof Date) {
      return {
        __type: "Date",
        iso: value.toISOString(),
      };
    }
    return value;
  });
}

// Custom deserializer
function deserialize(json: string): any {
  return JSON.parse(json, (key, value) => {
    if (value && value.__type === "Map") {
      return new Map(value.entries);
    }
    if (value && value.__type === "Set") {
      return new Set(value.values);
    }
    if (value && value.__type === "Date") {
      return new Date(value.iso);
    }
    return value;
  });
}

// Usage
const json = serialize(memory); // Handles Map, Set, Date
const restored = deserialize(json); // Reconstructs objects
```

---

## Size Optimization

### Compression Techniques

**1. Message Summarization** (after N messages)[^5]
```typescript
async function compressMessages(messages: Message[]): Promise<Message[]> {
  if (messages.length <= 10) return messages;

  // Keep first 3 (system + initial context)
  const kept = messages.slice(0, 3);

  // Summarize middle messages
  const middle = messages.slice(3, -3);
  const summary = await summarizeMessages(middle);

  // Keep last 3 (recent context)
  const recent = messages.slice(-3);

  return [
    ...kept,
    {
      role: "system",
      content: `[Summary of ${middle.length} messages: ${summary}]`,
      timestamp: new Date().toISOString(),
    },
    ...recent,
  ];
}
```

**Benefit**: 10:1 compression ratio typical[^6]

---

**2. Delta Encoding** (store only changes)
```typescript
interface DeltaCheckpoint {
  baseCheckpointId: string;
  changes: {
    messages?: { added: Message[] }; // Only new messages
    execution?: Partial<ExecutionState>; // Only changed fields
    memory?: { added: any[]; removed: string[] }; // Entity diffs
  };
}

// Save only what changed since last checkpoint
const delta: DeltaCheckpoint = {
  baseCheckpointId: "ckpt_12344",
  changes: {
    messages: { added: [newMessage] },
    execution: { currentStep: 6 }, // Only step changed
  },
};
```

**Benefit**: 80-90% size reduction for incremental checkpoints

---

**3. Reference External Data**
```typescript
// ❌ Bad: Store full document content
const checkpoint = {
  retrievedDocuments: [
    { id: "doc_1", content: "...10,000 characters..." },
    { id: "doc_2", content: "...10,000 characters..." },
  ],
};

// ✅ Good: Store references only
const checkpoint = {
  retrievedDocumentIds: ["doc_1", "doc_2"],
  retrievalParams: { query: "...", topK: 5 },
};

// On resume: re-retrieve documents
const docs = await vectorDB.retrieve(checkpoint.retrievalParams);
```

**Benefit**: 99% size reduction for large documents

---

## Security Considerations

### 1. Encrypt Sensitive Data

```typescript
import crypto from "crypto";

function encryptField(value: string, key: Buffer): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv("aes-256-gcm", key, iv);
  const encrypted = Buffer.concat([cipher.update(value, "utf8"), cipher.final()]);
  const authTag = cipher.getAuthTag();
  return Buffer.concat([iv, authTag, encrypted]).toString("base64");
}

// Encrypt sensitive fields before saving
const checkpoint = {
  userId: "user_123",
  creditCard: encryptField(user.creditCard, encryptionKey), // Encrypted
  preferences: user.preferences, // Not sensitive, no encryption
};
```

---

### 2. Redact PII (Personally Identifiable Information)

```typescript
function redactPII(checkpoint: Checkpoint): Checkpoint {
  // Redact from messages
  const redacted = {
    ...checkpoint,
    state: {
      ...checkpoint.state,
      messages: checkpoint.state.messages.map((msg) => ({
        ...msg,
        content: msg.content
          .replace(/\b\d{3}-\d{2}-\d{4}\b/g, "[SSN]") // SSN
          .replace(/\b\d{16}\b/g, "[CARD]") // Credit card
          .replace(/\b[\w.-]+@[\w.-]+\.\w+\b/g, "[EMAIL]"), // Email
      })),
    },
  };

  return redacted;
}
```

---

### 3. Access Control

```typescript
// Add owner/permissions to checkpoint
interface SecureCheckpoint extends Checkpoint {
  owner: string;
  permissions: {
    read: string[]; // User IDs allowed to read
    write: string[]; // User IDs allowed to modify
  };
}

// Verify access before loading
async function loadCheckpoint(
  checkpointId: string,
  userId: string
): Promise<Checkpoint | null> {
  const checkpoint = await db.getCheckpoint(checkpointId);

  if (!checkpoint.permissions.read.includes(userId)) {
    throw new Error("Access denied");
  }

  return checkpoint;
}
```

---

## Implementation Examples

### Complete Checkpoint System

```typescript
import { Pool } from "pg";

interface CompleteCheckpoint {
  // Identity
  id: string;
  threadId: string;
  userId: string;
  timestamp: string;

  // State
  messages: Message[];
  execution: ExecutionState;
  memory: WorkingMemory;
  subgoals: Subgoal[];
  metadata: Metadata;

  // Tracking
  parentCheckpointId?: string; // For delta encoding
  version: string;
  compressed: boolean;
}

class CheckpointManager {
  private db: Pool;

  constructor(connectionString: string) {
    this.db = new Pool({ connectionString });
  }

  async save(checkpoint: Omit<CompleteCheckpoint, "id" | "timestamp">): Promise<string> {
    const id = `ckpt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const timestamp = new Date().toISOString();

    // Compress messages if needed
    const messages =
      checkpoint.messages.length > 20
        ? await compressMessages(checkpoint.messages)
        : checkpoint.messages;

    // Serialize state
    const stateJson = serialize({
      messages,
      execution: checkpoint.execution,
      memory: checkpoint.memory,
      subgoals: checkpoint.subgoals,
      metadata: checkpoint.metadata,
    });

    // Store in database
    await this.db.query(
      `INSERT INTO checkpoints (id, thread_id, user_id, timestamp, state, version)
       VALUES ($1, $2, $3, $4, $5, $6)`,
      [id, checkpoint.threadId, checkpoint.userId, timestamp, stateJson, checkpoint.version]
    );

    return id;
  }

  async load(checkpointId: string): Promise<CompleteCheckpoint | null> {
    const result = await this.db.query(
      "SELECT * FROM checkpoints WHERE id = $1",
      [checkpointId]
    );

    if (result.rows.length === 0) return null;

    const row = result.rows[0];
    const state = deserialize(row.state);

    return {
      id: row.id,
      threadId: row.thread_id,
      userId: row.user_id,
      timestamp: row.timestamp,
      version: row.version,
      compressed: state.messages.some((m: Message) =>
        m.content.startsWith("[Summary")
      ),
      ...state,
    };
  }

  async loadLatest(threadId: string): Promise<CompleteCheckpoint | null> {
    const result = await this.db.query(
      `SELECT * FROM checkpoints 
       WHERE thread_id = $1 
       ORDER BY timestamp DESC 
       LIMIT 1`,
      [threadId]
    );

    if (result.rows.length === 0) return null;

    return this.load(result.rows[0].id);
  }

  async cleanup(olderThan: Date): Promise<number> {
    const result = await this.db.query(
      "DELETE FROM checkpoints WHERE timestamp < $1",
      [olderThan.toISOString()]
    );

    return result.rowCount || 0;
  }
}

// Usage
const manager = new CheckpointManager(process.env.DATABASE_URL!);

// Save checkpoint
const checkpointId = await manager.save({
  threadId: "thread_789",
  userId: "user_123",
  messages,
  execution: state,
  memory,
  subgoals,
  metadata,
  version: "2.0",
});

// Load checkpoint
const checkpoint = await manager.load(checkpointId);
if (checkpoint) {
  // Resume execution with restored state
  await resumeWorkflow(checkpoint);
}

// Cleanup old checkpoints (run daily)
const deleted = await manager.cleanup(new Date(Date.now() - 30 * 24 * 60 * 60 * 1000));
console.log(`Deleted ${deleted} old checkpoints`);
```

---

## Production Patterns

### 1. Tiered Storage

**Store different data at different frequencies**:

```typescript
// High-frequency (every step): Minimal state
await quickCheckpoint.save({
  step: currentStep,
  lastMessage: messages[messages.length - 1],
});

// Medium-frequency (every 5 steps): Working memory
await regularCheckpoint.save({
  step: currentStep,
  messages: messages.slice(-10), // Last 10 messages
  memory: workingMemory,
});

// Low-frequency (end of phase): Complete state
await fullCheckpoint.save({
  messages,
  execution: fullState,
  memory: workingMemory,
  subgoals,
  metadata,
});
```

---

### 2. Checkpoint Versioning

**Handle schema changes gracefully**:

```typescript
interface CheckpointV1 {
  version: "1.0";
  messages: string[]; // Old format: just content strings
}

interface CheckpointV2 {
  version: "2.0";
  messages: Message[]; // New format: structured objects
}

type AnyCheckpoint = CheckpointV1 | CheckpointV2;

function migrate(checkpoint: AnyCheckpoint): CheckpointV2 {
  if (checkpoint.version === "1.0") {
    // Migrate v1 → v2
    return {
      version: "2.0",
      messages: checkpoint.messages.map((content) => ({
        role: "user", // Assume user messages in v1
        content,
        timestamp: new Date().toISOString(),
      })),
    };
  }
  return checkpoint;
}

// Always migrate on load
const raw = await db.getCheckpoint(id);
const checkpoint = migrate(raw);
```

---

## Best Practices

### 1. Include Schema Version

```typescript
// ✅ Always include version for future-proofing
const checkpoint = {
  version: "2.1.0",
  // ...rest of state
};
```

### 2. Validate Before Saving

```typescript
import { z } from "zod";

const CheckpointSchema = z.object({
  version: z.string(),
  threadId: z.string(),
  messages: z.array(z.object({ role: z.string(), content: z.string() })),
  // ...
});

// Validate before saving
const validated = CheckpointSchema.parse(checkpoint);
await save(validated);
```

### 3. Test Serialization Roundtrip

```typescript
// Test that serialize → deserialize preserves data
const original = { memory: new Map([["key", "value"]]) };
const json = serialize(original);
const restored = deserialize(json);

expect(restored.memory.get("key")).toBe("value");
```

---

## Common Pitfalls

### 1. ❌ Saving Unserializable Objects

```typescript
// ❌ Bad: Can't serialize function
await checkpoint.save({
  callback: () => console.log("done"),
});

// ✅ Good: Save function name/params
await checkpoint.save({
  callbackName: "onComplete",
  callbackParams: { messageId: "123" },
});
```

### 2. ❌ Forgetting Timestamps

```typescript
// ❌ Bad: No way to know when checkpoint was created
await checkpoint.save({ messages });

// ✅ Good: Always include timestamp
await checkpoint.save({
  messages,
  timestamp: new Date().toISOString(),
});
```

### 3. ❌ Including Sensitive Data

```typescript
// ❌ Bad: Saving API key in checkpoint
await checkpoint.save({
  apiKey: process.env.OPENAI_API_KEY,
});

// ✅ Good: Load API key from environment on resume
await checkpoint.save({
  apiKeyName: "OPENAI_API_KEY", // Reference only
});
```

---

## Related Topics

- **[4.4.1 Why Checkpoint](./4.4.1-why-checkpoint.md)** - Understanding the benefits of checkpointing
- **[4.4.3 When to Checkpoint](./4.4.3-when-to-checkpoint.md)** - Optimal checkpointing frequency
- **[4.4.4 How to Resume](./4.4.4-how-to-resume.md)** - Loading and continuing from checkpoints
- **[4.4.5 Implementation Patterns](./4.4.5-implementation.md)** - Database storage and JSON serialization
- **[4.1.2 Entity Extraction](./4.1.2-entity-extraction.md)** - Extracting entities for working memory

---

## References

[^1]: "Mastering LangGraph State Management in 2025" - Sparkco AI (2025): https://sparkco.ai/blog/mastering-langgraph-state-management-in-2025
[^2]: "Building Agents with LangGraph Course #5: Persistence & Streaming" - Youssef Hosni (2025): https://youssefh.substack.com/p/building-agents-with-langgraph-course-bd2
[^3]: "Agent Persistence - Koog" - Koog Documentation (2025): https://docs.koog.ai/agent-persistence/
[^4]: "Unlocking Complex Workflows: LangGraphPersistence for Stateful, Multi-Agent LLMs" - Prasun Mishra (2024): https://prasun-mishra.medium.com/unlocking-complex-workflows-langgraphpersistence-for-stateful-multi-agent-llms
[^5]: "Context Engineering - Short-Term Memory Management with Sessions from OpenAI Agents SDK" - OpenAI Cookbook (2025): https://cookbook.openai.com/examples/agents_sdk/session_memory
[^6]: "Mem0: Building Production-Ready AI Agents with Scalable Long-Term Memory" - arXiv (2025): https://arxiv.org/html/2504.19413v1

---

**Next**: [4.4.3 When to Checkpoint](./4.4.3-when-to-checkpoint.md) - Learn optimal checkpoint timing and frequency.

**Previous**: [4.4.1 Why Checkpoint](./4.4.1-why-checkpoint.md) - Understanding the benefits of crash recovery and state persistence.
