# 1.2.4 System Prompts: Output Format Specification

## Overview

Output format specification tells the AI HOW to structure its responses—whether as JSON, markdown, tables, code blocks, or custom formats. Clear format specifications make LLM outputs predictable, parseable, and production-ready. In 2024-2025, structured outputs with JSON Schema have become the gold standard for reliable AI integration.

**Key Evolution**: From "respond in JSON" (unreliable) → JSON Schema validation (guaranteed structure).

**Current Date**: November 17, 2025

## Why Format Specification Matters

### Problem: Unpredictable Outputs

**Without format specification**:
```
User: "Extract product info from this description"
AI: "Sure! The product is a MacBook Pro with M3 chip, it costs $2999, 
     and comes in Space Gray color with 36GB RAM."
```
❌ **Unparseable**: Free-form text, can't extract fields reliably

**With format specification**:
```
System: "Return JSON with keys: name, price, specs, color"
AI: {"name": "MacBook Pro", "price": 2999, "specs": {"chip": "M3", 
     "ram": "36GB"}, "color": "Space Gray"}
```
✅ **Structured**: Easy to parse, validate, and use in code

## Format Types

### 1. JSON (Most Common)

**Basic JSON Request**:
```
Return your response as valid JSON with these fields:
- name: string
- age: number
- skills: array of strings
```

**Problem**: No guarantee it's valid JSON or has correct types.

**Solution: JSON Schema** (2024+ Standard):
```json
{
  "type": "object",
  "properties": {
    "name": {"type": "string"},
    "age": {"type": "number", "minimum": 0},
    "skills": {
      "type": "array",
      "items": {"type": "string"}
    }
  },
  "required": ["name", "age"]
}
```

**Models with Native Support** (2025):
- GPT-4o with `response_format` + `json_schema`
- Claude 3.5 with schema validation
- Gemini 2.0 with response schemas
- Open source: vLLM, LM Studio with JSON constraints

### 2. Markdown

**Common for documentation, explanations, formatted text.**

```
Format your response as markdown:
- Use ## for section headers
- Use ` for inline code
- Use ``` for code blocks
- Use **bold** for emphasis
- Use - for bullet lists
```

**Example Output**:
```markdown
## Analysis Results

The function has **3 issues**:

1. Missing null check
2. Inefficient loop
3. No error handling

```javascript
// Fixed version
function process(data) {
  if (!data) return null;
  ...
}
```
```

### 3. Tables

**For comparisons, data grids, structured comparisons.**

```
Format as markdown table with columns: Feature, Model A, Model B

| Feature | Model A | Model B |
|---------|---------|---------|
| Cost | $100 | $50 |
| Speed | Fast | Slow |
```

### 4. Code Blocks

**For code generation, script outputs.**

```
Return only the code, no explanations. Use proper syntax highlighting:

```typescript
// Your code here
```
```

### 5. Custom Formats

**XML, YAML, CSV, or domain-specific formats.**

```xml
<response>
  <status>success</status>
  <data>
    <user id="123">John</user>
  </data>
</response>
```

## Modern Approach: Structured Outputs (2024-2025)

### The Evolution

**2022-2023: Prompt-Based** (Unreliable)
```
"Return JSON with name and age fields"
→ Sometimes works, often fails or returns invalid JSON
```

**2024: JSON Mode** (Better)
```
response_format: { type: "json_object" }
→ Guarantees valid JSON, but not specific schema
```

**2025: JSON Schema** (Best)
```
response_format: { 
  type: "json_schema",
  json_schema: {schema: {...}}
}
→ Guarantees JSON matching exact schema
```

### Implementation (Your Codebase)

**Current Approach** (AI SDK v6):
```typescript
// From orchestrator.ts
model: openai("gpt-4o-mini", { structuredOutputs: true })
```

✅ **Excellent**: Uses structured outputs feature

**Example Usage**:
```typescript
import { z } from 'zod';
import { generateObject } from 'ai';

// Define schema with Zod
const PageSchema = z.object({
  id: z.string(),
  name: z.string(),
  slug: z.string(),
  sectionCount: z.number(),
  lastModified: z.string().datetime()
});

// Generate with guaranteed structure
const result = await generateObject({
  model: openai("gpt-4o-mini", { structuredOutputs: true }),
  schema: PageSchema,
  prompt: "Analyze this page and extract metadata"
});

// result.object is typed and validated
console.log(result.object.sectionCount); // TypeScript knows this is number
```

### Advanced Schema Patterns

**Nested Objects**:
```typescript
const ProductSchema = z.object({
  name: z.string(),
  price: z.number().positive(),
  specs: z.object({
    color: z.string(),
    size: z.enum(["S", "M", "L", "XL"]),
    features: z.array(z.string())
  }),
  inStock: z.boolean()
});
```

**Conditional Fields**:
```typescript
const TaskSchema = z.object({
  type: z.enum(["create", "update", "delete"]),
  target: z.string(),
  data: z.optional(z.record(z.any())), // Only for create/update
  confirmation: z.optional(z.boolean()) // Only for delete
});
```

**Enum Constraints**:
```typescript
const ClassificationSchema = z.object({
  category: z.enum(["bug", "feature", "question", "documentation"]),
  priority: z.enum(["low", "medium", "high", "critical"]),
  confidence: z.number().min(0).max(1)
});
```

## Format Specification Patterns

### Pattern 1: Prefix Markers

```
**CRITICAL: Response Format**

ALL responses MUST follow this structure:

Thought: [Your reasoning]
Action: [Tool name]
Action Input: [Tool parameters as JSON]
Observation: [Tool result]

Final Answer: [User-facing response]

Example:
Thought: I need to find the about page
Action: cms_findResource
Action Input: {"query": "about", "type": "page"}
Observation: Found page-123
Final Answer: Located the About page successfully.
```

**Your Codebase Uses This**:
```xml
Think step-by-step:
1. Analyze the question...
2. Execute ONE tool...
3. Observe the result...

Include "FINAL_ANSWER:" prefix when you have a complete response
```

### Pattern 2: Section Templates

```
Structure your response in these sections:

## Summary
[1-2 sentence overview]

## Analysis
[Detailed findings with bullet points]

## Recommendations
1. [First action]
2. [Second action]

## Code Example
```language
[Example code if relevant]
```
```

### Pattern 3: JSON Template

```
Return JSON matching this template:

{
  "status": "success" | "error" | "pending",
  "data": {
    // Your extracted data here
  },
  "confidence": 0-1,
  "reasoning": "Brief explanation"
}

IMPORTANT: Return ONLY the JSON, no additional text.
```

### Pattern 4: Conditional Formatting

```
Format your response based on task type:

IF task is code review:
  - Use ## for sections
  - Use ❌ for issues
  - Use ✅ for good patterns
  - Include code blocks with fixes

IF task is data extraction:
  - Return JSON only
  - No explanations
  - Include confidence scores

IF task is explanation:
  - Use conversational markdown
  - Include examples
  - Keep under 3 paragraphs
```

## Real-World Examples

### Example 1: Code Review Bot

**System Prompt**:
```
**OUTPUT FORMAT:**

Structure code reviews as markdown:

### [File Name]

#### Issues Found

**[Severity]**: [Issue Description]
- Location: Line X
- Problem: [What's wrong]
- Impact: [Why it matters]
- Fix:
```language
// Suggested fix
```

#### Positive Patterns

- ✅ [Good practice observed]

### Summary

- Total Issues: X
- Critical: X, Major: X, Minor: X
- Overall Assessment: [APPROVE | REQUEST_CHANGES | COMMENT]
```

**Example Output**:
```markdown
### user-service.ts

#### Issues Found

**CRITICAL**: SQL Injection Vulnerability
- Location: Line 45
- Problem: User input directly interpolated into SQL query
- Impact: Attackers can execute arbitrary SQL
- Fix:
```typescript
// Use parameterized queries
const result = await db.query(
  'SELECT * FROM users WHERE id = ?', 
  [userId]
);
```

#### Positive Patterns

- ✅ Good error handling with try-catch blocks
- ✅ TypeScript types properly defined

### Summary

- Total Issues: 3
- Critical: 1, Major: 1, Minor: 1
- Overall Assessment: REQUEST_CHANGES
```

### Example 2: Data Extraction Agent

**System Prompt**:
```typescript
// Define schema
const ExtractionSchema = z.object({
  entities: z.array(z.object({
    type: z.enum(["person", "organization", "location", "date"]),
    value: z.string(),
    confidence: z.number().min(0).max(1)
  })),
  sentiment: z.enum(["positive", "negative", "neutral"]),
  summary: z.string().max(200),
  metadata: z.object({
    language: z.string(),
    wordCount: z.number(),
    complexity: z.enum(["simple", "moderate", "complex"])
  })
});

// Use in generation
const result = await generateObject({
  model: openai("gpt-4o-mini", { structuredOutputs: true }),
  schema: ExtractionSchema,
  prompt: `Extract information from: "${text}"`
});
```

**Example Output**:
```json
{
  "entities": [
    {"type": "person", "value": "Elon Musk", "confidence": 0.95},
    {"type": "organization", "value": "Tesla", "confidence": 0.98},
    {"type": "date", "value": "2024-03-15", "confidence": 0.90}
  ],
  "sentiment": "positive",
  "summary": "Article discusses Tesla's new electric vehicle launch...",
  "metadata": {
    "language": "en",
    "wordCount": 1250,
    "complexity": "moderate"
  }
}
```

### Example 3: Your CMS Agent (Enhanced)

**Current Format** (from react.xml):
```xml
**EXAMPLE SESSION:**

User: "Add a hero section to the about page"

Thought: I need to find the about page first
Action: cms_findResource
Action Input: {"query": "about", "resourceType": "page"}
Observation: Found page-abc123

...

FINAL_ANSWER: ✅ Successfully added Hero section to About page
```

**Enhancement with Structured Output**:
```typescript
// Define agent response schema
const AgentResponseSchema = z.object({
  thoughts: z.array(z.object({
    reasoning: z.string(),
    toolSelected: z.string(),
    expectedOutcome: z.string()
  })),
  actions: z.array(z.object({
    tool: z.string(),
    parameters: z.record(z.any()),
    result: z.any(),
    success: z.boolean()
  })),
  finalAnswer: z.object({
    status: z.enum(["success", "partial", "failed"]),
    message: z.string(),
    summary: z.string(),
    nextSteps: z.optional(z.array(z.string()))
  })
});

// Use for complex multi-step tasks
const response = await generateObject({
  model: openai("gpt-4o-mini", { structuredOutputs: true }),
  schema: AgentResponseSchema,
  prompt: `Execute: ${userRequest}`
});
```

## Format Validation & Error Handling

### Client-Side Validation

```typescript
import { z } from 'zod';

// Schema defines expected format
const ResponseSchema = z.object({
  answer: z.string(),
  confidence: z.number().min(0).max(1),
  sources: z.array(z.string().url())
});

// Generate with schema
const result = await generateObject({
  model: openai("gpt-4o-mini", { structuredOutputs: true }),
  schema: ResponseSchema,
  prompt
});

// result.object is already validated!
// TypeScript knows the exact type
console.log(result.object.confidence); // number
console.log(result.object.sources); // string[]
```

### Fallback Formatting

```typescript
async function generateWithFallback(prompt: string) {
  try {
    // Try structured output first
    return await generateObject({
      model: openai("gpt-4o-mini", { structuredOutputs: true }),
      schema: MySchema,
      prompt
    });
  } catch (error) {
    // Fallback to text generation with format instructions
    const text = await generateText({
      model: openai("gpt-4o-mini"),
      prompt: `${prompt}\n\nReturn JSON with fields: ${Object.keys(MySchema.shape).join(', ')}`
    });
    
    // Manual parsing and validation
    const parsed = JSON.parse(text.text);
    return MySchema.parse(parsed);
  }
}
```

### Format Error Messages

```
**IF OUTPUT FORMAT IS VIOLATED:**

Do NOT respond with: "Error: Invalid format"

Instead, self-correct:
1. Identify what was wrong
2. Generate correctly formatted response
3. Include note: "Note: Corrected format from previous attempt"

Example:
Incorrect first attempt: "The answer is 42"
Correct retry:
{
  "answer": 42,
  "confidence": 0.95,
  "reasoning": "Calculated from..."
}
Note: Corrected to match required JSON schema
```

## Testing Format Specifications

### The 3-Test Framework

**1. Happy Path Test**:
```typescript
const result = await generateObject({
  schema: ProductSchema,
  prompt: "Extract: MacBook Pro M3, $2999, Space Gray"
});

// Verify structure
assert(result.object.name === "MacBook Pro M3");
assert(typeof result.object.price === "number");
assert(result.object.price === 2999);
```

**2. Edge Case Test**:
```typescript
// Missing optional fields
const result = await generateObject({
  schema: ProductSchema,
  prompt: "Extract: Generic laptop" // No price, color
});

// Should still work with defaults/nulls
assert(result.object.name === "Generic laptop");
assert(result.object.price === null || result.object.price === 0);
```

**3. Invalid Input Test**:
```typescript
// Invalid data should be caught by schema
const schema = z.object({
  age: z.number().positive()
});

const result = await generateObject({
  schema,
  prompt: "Extract age: -5"
});

// Model should correct invalid data or throw validation error
// (Depends on your error handling strategy)
```

## Key Takeaways

**What is Output Format Specification**:
- Defines HOW AI structures responses
- From simple "use JSON" to full JSON Schema validation
- Makes outputs predictable, parseable, production-ready

**Evolution (2022-2025)**:
- 2022: Prompt-based ("respond in JSON") - unreliable
- 2024: JSON mode (valid JSON, no schema) - better
- 2025: JSON Schema (guaranteed structure) - best

**Your Codebase**:
- ✅ Uses `structuredOutputs: true` with AI SDK v6
- ✅ Has clear format in ReAct loop (Thought/Action/Observation)
- Could enhance: Use Zod schemas for complex multi-step tasks

**Format Types**:
1. **JSON** (with schema) - Most reliable for structured data
2. **Markdown** - Best for human-readable content
3. **Tables** - Good for comparisons
4. **Code blocks** - For generated code
5. **Custom** - Domain-specific formats (XML, YAML, CSV)

**Best Practices**:
- Use JSON Schema for critical data extraction
- Define schemas with Zod/TypeScript for type safety
- Provide examples of expected format
- Validate outputs client-side
- Have fallback strategies for format errors

**Implementation**:
```typescript
// Modern approach (2025)
import { generateObject } from 'ai';
import { z } from 'zod';

const schema = z.object({
  // Your structure
});

const result = await generateObject({
  model: openai("gpt-4o-mini", { structuredOutputs: true }),
  schema,
  prompt
});

// result.object is typed and validated ✅
```

**Common Anti-Patterns**:
- ❌ Vague: "respond in JSON format"
- ❌ No validation: Assuming JSON is valid
- ❌ Over-specifying: 50-field schemas for simple tasks
- ❌ No fallback: Single point of failure

**Testing Framework**:
1. Happy path (normal case)
2. Edge cases (missing optional fields)
3. Invalid inputs (schema violations)

## Practical Exercise

Enhance format specifications for:

**Exercise 1**: Your CMS Agent
```typescript
// Create schema for agent responses
const AgentTaskSchema = z.object({
  // Define structure for:
  // - Planning phase
  // - Execution steps
  // - Validation results
  // - Final status
});

// Use in orchestrator
```

**Exercise 2**: Multi-Step Workflow
```typescript
// Define schema for complex workflow
const WorkflowSchema = z.object({
  steps: z.array(z.object({
    name: z.string(),
    status: z.enum(["pending", "in_progress", "completed", "failed"]),
    output: z.any(),
    error: z.optional(z.string())
  })),
  overall: z.object({
    completed: z.number(),
    failed: z.number(),
    success: z.boolean()
  })
});
```

**Exercise 3**: Format Testing
```
Test your format specifications:
1. Generate 10 outputs
2. Validate all match schema
3. Check edge cases (missing fields, invalid types)
4. Measure schema violation rate
```

## Navigation

- [← Previous: 1.2.3 Rules & Constraints](./1.2.3-rules-constraints.md)
- [↑ Back to Knowledge Base TOC](../../AI_KNOWLEDGE_BASE_TOC.md)
- [→ Next: 1.2.5 Modular Prompt Architecture](./1.2.5-modular-architecture.md)

---

*Part of Layer 1: Prompt Engineering - Making LLM outputs predictable and parseable*
