# 1.3.1 Prompt Templates: Template Engines & Variable Injection

## Overview

Template engines transform static prompt strings into dynamic, context-aware instructions by enabling variable substitution, conditional logic, and iterative structures. Instead of manually concatenating strings, you use a templating language to create reusable prompt patterns that adapt to different contexts, user inputs, and runtime conditions.

**Key Insight** (2024-2025): Modern LLM frameworks have standardized on template engines from web development (Jinja2, Handlebars, Mustache, Liquid) rather than inventing new prompt-specific syntaxes.

**Current Date**: November 17, 2025

## Why Template Engines Matter

### Problem: String Concatenation Hell

**Without Templates** (manual string building):
```typescript
let prompt = "You are an AI assistant.";

if (workingMemory) {
  prompt += "\n\nWORKING MEMORY:\n" + workingMemory;
}

prompt += "\n\nAVAILABLE TOOLS: " + tools.length + " tools\n";

for (const tool of tools) {
  prompt += "- " + tool.name + ": " + tool.description + "\n";
}

if (examples.length > 0) {
  prompt += "\n\nEXAMPLES:\n";
  for (const example of examples) {
    prompt += example.formatted + "\n";
  }
}

prompt += "\n\nRULES:\n";
for (const rule of rules) {
  prompt += "- " + rule + "\n";
}
```

**Problems**:
- ❌ Difficult to read and maintain
- ❌ Error-prone (missing newlines, spacing issues)
- ❌ Hard to visualize final output
- ❌ No separation of content and logic
- ❌ Tedious conditional handling

**With Templates** (declarative approach):
```handlebars
You are an AI assistant.

{{#if workingMemory}}
WORKING MEMORY:
{{{workingMemory}}}
{{/if}}

AVAILABLE TOOLS: {{toolCount}} tools
{{#each tools}}
- {{name}}: {{description}}
{{/each}}

{{#if examples}}
EXAMPLES:
{{#each examples}}
{{{formatted}}}
{{/each}}
{{/if}}

RULES:
{{#each rules}}
- {{this}}
{{/each}}
```

**Benefits**:
- ✅ Clear, readable structure
- ✅ Separation of content and logic
- ✅ Easy to visualize output
- ✅ Consistent formatting
- ✅ Reusable across contexts

## Popular Template Engines (2024-2025)

### 1. Jinja2 (Python Standard)

**Used by**: Microsoft Semantic Kernel (Python), IBM Watsonx, Instructor, PromptLayer, Vellum

**Syntax**:
```jinja2
You are {{agent_name}}, an autonomous AI assistant.

{% if context %}
CONTEXT:
{{ context }}
{% endif %}

AVAILABLE TOOLS: {{ tools|length }} tools
{% for tool in tools %}
- {{ tool.name }}: {{ tool.description }}
{% endfor %}

{% if environment == "production" %}
EXTRA VALIDATION: Always double-check destructive operations.
{% endif %}
```

**Key Features**:
- `{{ variable }}` - Variable substitution
- `{% if condition %}...{% endif %}` - Conditionals
- `{% for item in list %}...{% endfor %}` - Loops
- `{{ value|filter }}` - Filters (e.g., `|length`, `|upper`, `|default`)
- `{# comment #}` - Comments (don't consume tokens)
- Template inheritance and includes

**Python Example** (Semantic Kernel 2025):
```python
from semantic_kernel import Kernel
from semantic_kernel.prompt_template import PromptTemplateConfig

# Define Jinja2 template
template = """
You are {{agent_name}}, specialized in {{domain}}.

{% if user_context %}
USER CONTEXT:
{{ user_context }}
{% endif %}

TASK: {{task}}

{% if examples %}
EXAMPLES:
{% for example in examples %}
Input: {{ example.input }}
Output: {{ example.output }}
{% endfor %}
{% endif %}
"""

# Create kernel and configure
kernel = Kernel()
prompt_config = PromptTemplateConfig(
    template=template,
    template_format="jinja2"
)

# Render with context
context = {
    "agent_name": "DataAgent",
    "domain": "data analysis",
    "task": "Analyze sales trends",
    "user_context": "Q4 2024 data",
    "examples": [
        {"input": "monthly revenue", "output": "Generated chart"},
        {"input": "top products", "output": "Listed top 10"}
    ]
}

rendered = prompt_config.render(kernel, context)
```

**When to Use Jinja2**:
- ✅ Python-based LLM applications
- ✅ Complex conditional logic required
- ✅ Need powerful filters and transformations
- ✅ Template inheritance patterns
- ✅ Microsoft/IBM ecosystem

### 2. Handlebars (JavaScript/TypeScript Standard)

**Used by**: Your codebase, .NET Semantic Kernel, many Node.js frameworks

**Syntax**:
```handlebars
You are an autonomous AI assistant using the ReAct pattern.

{{#if workingMemory}}
WORKING MEMORY:
{{{workingMemory}}}
{{/if}}

AVAILABLE TOOLS: {{toolCount}} tools
{{toolsFormatted}}

{{#each criticalRules}}
{{@index}}. {{this}}
{{/each}}

{{#unless isReadOnly}}
DESTRUCTIVE OPERATIONS:
- Deletion requires user confirmation
{{/unless}}
```

**Key Features**:
- `{{variable}}` - HTML-escaped substitution
- `{{{variable}}}` - Unescaped (raw) substitution
- `{{#if condition}}...{{/if}}` - Conditionals
- `{{#each array}}...{{/each}}` - Iteration
- `{{#unless condition}}...{{/unless}}` - Negative conditional
- `{{@index}}`, `{{@key}}` - Special variables in loops
- Custom helpers for complex logic

**TypeScript Example** (Your Codebase Pattern):
```typescript
import Handlebars from 'handlebars';

// Define template
const template = `
You are {{agentName}}, an autonomous AI assistant.

{{#if workingMemory}}
WORKING MEMORY:
{{{workingMemory}}}
{{/if}}

AVAILABLE TOOLS: {{toolCount}} tools
{{#each tools}}
- {{name}}: {{description}}
  Parameters: {{json parameters}}
{{/each}}

{{#if (gt toolCount 10)}}
NOTE: Many tools available - use search to find relevant ones.
{{/if}}
`;

// Register custom helper
Handlebars.registerHelper('json', (obj) => {
  return JSON.stringify(obj, null, 2);
});

Handlebars.registerHelper('gt', (a, b) => a > b);

// Compile template
const compiledTemplate = Handlebars.compile(template);

// Render with context
const rendered = compiledTemplate({
  agentName: 'CMS Agent',
  workingMemory: 'User recently accessed: page-123',
  toolCount: 15,
  tools: [
    { 
      name: 'getPage', 
      description: 'Retrieve page content',
      parameters: { slug: 'string', fetchMode: 'lightweight|full' }
    }
  ]
});
```

**Your Current Usage** (`server/prompts/react.xml`):
```xml
<agent>
You are an autonomous AI assistant using the ReAct pattern.

{{{workingMemory}}}

**AVAILABLE TOOLS:** {{toolCount}} tools
{{toolsFormatted}}

**SESSION INFO:**
- Session ID: {{sessionId}}
- Date: {{currentDate}}
</agent>
```

**Enhancement Opportunities**:
```typescript
// Extract to separate template file
// prompts/react.hbs
const reactTemplate = `
You are an autonomous AI assistant using the ReAct pattern.

{{#if workingMemory}}
**WORKING MEMORY:**
{{{workingMemory}}}
{{/if}}

**CORE LOOP:**
Think → Act → Observe → Repeat

{{#if isProduction}}
**PRODUCTION MODE:**
- Extra validation enabled
- Audit logging active
{{/if}}

**AVAILABLE TOOLS:** {{toolCount}} tools
{{toolsFormatted}}

{{#each criticalRules}}
{{@index}}. {{{this}}}
{{/each}}
`;

// Load and compile
import fs from 'fs';
import path from 'path';

const templatePath = path.join(__dirname, 'prompts', 'react.hbs');
const templateSource = fs.readFileSync(templatePath, 'utf-8');
const template = Handlebars.compile(templateSource);

// Use in orchestrator
const prompt = template({
  workingMemory: context.workingMemory,
  toolCount: tools.length,
  toolsFormatted: formatTools(tools),
  criticalRules: [
    'THINK before acting',
    'EXECUTE immediately',
    'NEVER auto-confirm deletions'
  ],
  isProduction: process.env.NODE_ENV === 'production'
});
```

**When to Use Handlebars**:
- ✅ TypeScript/JavaScript LLM applications
- ✅ Your codebase already uses it
- ✅ .NET projects (via Semantic Kernel)
- ✅ Need raw HTML/XML injection (`{{{...}}}`)
- ✅ Simple, clean syntax preferred

### 3. Mustache (Minimal, Logic-less)

**Used by**: Portkey (LLM platform), legacy systems, minimalist projects

**Syntax**:
```mustache
You are {{agent_name}}.

{{#has_context}}
CONTEXT:
{{context}}
{{/has_context}}

TOOLS:
{{#tools}}
- {{name}}: {{description}}
{{/tools}}

{{^is_read_only}}
You can perform write operations.
{{/is_read_only}}
```

**Key Features**:
- `{{variable}}` - Variable substitution
- `{{#section}}...{{/section}}` - Sections (if truthy, iterate if array)
- `{{^section}}...{{/section}}` - Inverted sections (if falsy)
- `{{! comment}}` - Comments
- Logic-less philosophy (no complex conditionals)

**Portkey Example** (2024):
```typescript
// Portkey prompt template
const template = `
You are an AI {{role}}.

{{#features}}
- {{name}}: {{enabled}}
{{/features}}

{{#user_tier}}
TIER: {{tier}}
{{#is_premium}}
Premium features enabled.
{{/is_premium}}
{{/user_tier}}
`;

// Data
const data = {
  role: "assistant",
  features: [
    { name: "Search", enabled: true },
    { name: "Analysis", enabled: false }
  ],
  user_tier: {
    tier: "premium",
    is_premium: true
  }
};
```

**When to Use Mustache**:
- ✅ Minimal dependencies required
- ✅ Logic-less templates preferred
- ✅ Simple variable substitution
- ✅ Portkey platform users
- ✅ Need language-agnostic templates

### 4. Liquid (Shopify Template Language)

**Used by**: MAIAR platform (2025), Shopify-based systems

**Syntax**:
```liquid
You are {{ agent_name }}.

{% if context %}
CONTEXT:
{{ context }}
{% endif %}

TOOLS: {{ tools.size }} available
{% for tool in tools %}
- {{ tool.name }}: {{ tool.description | truncate: 100 }}
{% endfor %}

{% unless read_only %}
WRITE OPERATIONS ENABLED
{% endunless %}

{{ "Generated at: " | append: current_time }}
```

**Key Features**:
- `{{ variable }}` - Variable substitution
- `{% if condition %}...{% endif %}` - Conditionals
- `{% for item in array %}...{% endfor %}` - Loops
- `{% unless condition %}...{% endunless %}` - Negative conditional
- `{{ value | filter }}` - Filters (e.g., `|truncate`, `|upcase`, `|append`)
- Familiar to Shopify developers

**MAIAR Example** (2025):
```typescript
// MAIAR Liquid template for prompts
const template = `
You are {{ agent.name }}, specialized in {{ agent.domain }}.

{% if context.user_history %}
RECENT ACTIVITY:
{% for activity in context.user_history limit: 5 %}
- {{ activity.timestamp | date: "%Y-%m-%d" }}: {{ activity.action }}
{% endfor %}
{% endif %}

CAPABILITIES:
{% for capability in agent.capabilities %}
- {{ capability.name }}{% if capability.is_beta %} (BETA){% endif %}
{% endfor %}

{% if environment == "production" %}
PRODUCTION MODE: Extra validation active
{% endif %}
`;
```

**When to Use Liquid**:
- ✅ MAIAR platform users
- ✅ Shopify ecosystem familiarity
- ✅ Rich filter library needed
- ✅ E-commerce AI applications

### 5. PromptL (Specialized LLM Language)

**Used by**: Latitude (2024), specialized prompt engineering tools

**Purpose-Built Features**:
- Native LLM concepts (roles, messages, tools)
- First-class function calling syntax
- Built-in token counting
- LLM-specific validations

**Example Concept**:
```promptl
@role system
You are {{ agent_name }}.

@if has_context
@context {{ user_context }}
@endif

@tools
  @function get_page
    @param slug: string
    @param mode: "lightweight" | "full"
  @endfunction
@endtools

@examples
  @example
    User: Get homepage
    Assistant: @call get_page("home", "lightweight")
  @endexample
@endexamples

@constraints
  - max_tokens: {{ max_response_tokens }}
  - temperature: {{ temperature }}
@endconstraints
```

**When to Use PromptL**:
- ✅ Latitude platform users
- ✅ Need LLM-native abstractions
- ✅ First-class tool definitions
- ✅ Experimental/cutting-edge projects

## Variable Injection Patterns

### 1. Simple Substitution

**Jinja2**:
```jinja2
Agent: {{agent_name}}
Task: {{task}}
```

**Handlebars**:
```handlebars
Agent: {{agentName}}
Task: {{task}}
```

**Output**:
```
Agent: CMS Agent
Task: Create new page
```

### 2. Conditional Injection

**Only include content if variable exists**:

**Jinja2**:
```jinja2
{% if user_context %}
USER CONTEXT:
{{ user_context }}
{% endif %}
```

**Handlebars**:
```handlebars
{{#if userContext}}
USER CONTEXT:
{{userContext}}
{{/if}}
```

**Benefit**: Cleaner prompts without empty sections

### 3. Loop Injection

**Inject dynamic lists**:

**Jinja2**:
```jinja2
AVAILABLE TOOLS: {{ tools|length }} tools
{% for tool in tools %}
- {{ tool.name }}: {{ tool.description }}
  {% if tool.parameters %}
  Parameters: {% for param in tool.parameters %}{{ param.name }} ({{ param.type }}){% if not loop.last %}, {% endif %}{% endfor %}
  {% endif %}
{% endfor %}
```

**Handlebars**:
```handlebars
AVAILABLE TOOLS: {{toolCount}} tools
{{#each tools}}
- {{name}}: {{description}}
  {{#if parameters}}
  Parameters: {{#each parameters}}{{name}} ({{type}}){{#unless @last}}, {{/unless}}{{/each}}
  {{/if}}
{{/each}}
```

### 4. Raw Injection (Unescaped)

**For pre-formatted content**:

**Jinja2** (auto-escapes by default):
```jinja2
{{ raw_content }}  <!-- Escaped -->
{{ raw_content|safe }}  <!-- Unescaped -->
```

**Handlebars**:
```handlebars
{{escaped_content}}  <!-- Escaped -->
{{{raw_content}}}    <!-- Unescaped -->
```

**Your Codebase**:
```handlebars
{{{workingMemory}}}  <!-- Raw injection, preserves formatting -->
```

**Use Case**: Working memory already formatted, preserve exact structure

### 5. Default Values

**Provide fallbacks**:

**Jinja2**:
```jinja2
Agent: {{ agent_name|default("Default Agent") }}
Max Tokens: {{ max_tokens|default(4000) }}
```

**Handlebars** (via helper):
```typescript
Handlebars.registerHelper('default', (value, defaultValue) => {
  return value !== undefined ? value : defaultValue;
});
```

```handlebars
Agent: {{default agentName "Default Agent"}}
Max Tokens: {{default maxTokens 4000}}
```

### 6. Filters and Transformations

**Jinja2 Built-in Filters**:
```jinja2
{{ agent_name|upper }}  <!-- UPPERCASE -->
{{ description|truncate(100) }}  <!-- Limit length -->
{{ tools|length }}  <!-- Count -->
{{ price|round(2) }}  <!-- Round decimal -->
{{ text|wordcount }}  <!-- Count words -->
```

**Handlebars Custom Helpers**:
```typescript
Handlebars.registerHelper('upper', (str) => str.toUpperCase());
Handlebars.registerHelper('truncate', (str, len) => 
  str.length > len ? str.substring(0, len) + '...' : str
);
Handlebars.registerHelper('json', (obj) => JSON.stringify(obj, null, 2));
```

```handlebars
{{upper agentName}}
{{truncate description 100}}
{{json toolParameters}}
```

## Production Implementation

### TypeScript/Node.js (Handlebars)

```typescript
// prompts/template-engine.ts
import Handlebars from 'handlebars';
import fs from 'fs';
import path from 'path';

// Register custom helpers
Handlebars.registerHelper('json', (obj) => JSON.stringify(obj, null, 2));
Handlebars.registerHelper('gt', (a, b) => a > b);
Handlebars.registerHelper('default', (value, defaultValue) => 
  value !== undefined ? value : defaultValue
);

// Template loader
export class PromptTemplateEngine {
  private templates = new Map<string, HandlebarsTemplateDelegate>();
  private templateDir: string;
  
  constructor(templateDir: string) {
    this.templateDir = templateDir;
  }
  
  loadTemplate(name: string): void {
    const templatePath = path.join(this.templateDir, `${name}.hbs`);
    const source = fs.readFileSync(templatePath, 'utf-8');
    this.templates.set(name, Handlebars.compile(source));
  }
  
  render(name: string, context: any): string {
    if (!this.templates.has(name)) {
      this.loadTemplate(name);
    }
    const template = this.templates.get(name)!;
    return template(context);
  }
  
  renderString(source: string, context: any): string {
    const template = Handlebars.compile(source);
    return template(context);
  }
}

// Usage
const engine = new PromptTemplateEngine('./server/prompts');

const prompt = engine.render('react', {
  workingMemory: context.getWorkingMemory(),
  toolCount: tools.length,
  toolsFormatted: formatTools(tools),
  sessionId: session.id,
  currentDate: new Date().toISOString(),
  isProduction: process.env.NODE_ENV === 'production'
});
```

### Python (Jinja2)

```python
# prompts/template_engine.py
from jinja2 import Environment, FileSystemLoader, select_autoescape
from pathlib import Path

class PromptTemplateEngine:
    def __init__(self, template_dir: str):
        self.env = Environment(
            loader=FileSystemLoader(template_dir),
            autoescape=select_autoescape(),
            trim_blocks=True,
            lstrip_blocks=True
        )
        
        # Register custom filters
        self.env.filters['json'] = lambda obj: json.dumps(obj, indent=2)
    
    def render(self, template_name: str, context: dict) -> str:
        template = self.env.get_template(f"{template_name}.j2")
        return template.render(**context)
    
    def render_string(self, source: str, context: dict) -> str:
        template = self.env.from_string(source)
        return template.render(**context)

# Usage
engine = PromptTemplateEngine('./prompts')

prompt = engine.render('react', {
    'agent_name': 'CMS Agent',
    'working_memory': context.get_working_memory(),
    'tools': tools,
    'session_id': session.id,
    'is_production': os.getenv('ENV') == 'production'
})
```

## Best Practices

### 1. Separate Templates from Code

**❌ Bad** (inline templates):
```typescript
const prompt = `You are ${agentName}...`;
```

**✅ Good** (external template files):
```typescript
const prompt = engine.render('react', { agentName });
```

### 2. Use Conditionals for Environment

```handlebars
{{#if isProduction}}
PRODUCTION MODE: Extra validation enabled
{{else}}
DEVELOPMENT MODE: Debug logging active
{{/if}}
```

### 3. Preserve Formatting with Raw Injection

```handlebars
{{{workingMemory}}}  <!-- Preserves newlines, formatting -->
```

### 4. Provide Sensible Defaults

```handlebars
Agent: {{default agentName "Default Agent"}}
Temperature: {{default temperature 0.7}}
```

### 5. Comment for Token Efficiency

**Jinja2**:
```jinja2
{# This comment won't be in the rendered output #}
```

**Handlebars**:
```handlebars
{{!-- This comment is stripped during compilation --}}
```

## Key Takeaways

**What are Template Engines**:
- Transform static strings into dynamic prompts
- Enable variable substitution, conditionals, loops
- Separate content from logic

**Why They Matter** (2024-2025):
- Modern LLM frameworks standardized on web template engines
- Jinja2, Handlebars, Liquid dominate production systems
- Purpose-built engines (PromptL) emerging

**Popular Choices**:
1. **Jinja2** - Python standard (Microsoft, IBM, Instructor)
2. **Handlebars** - JavaScript/TypeScript (.NET, your codebase)
3. **Mustache** - Minimal, logic-less (Portkey)
4. **Liquid** - Shopify-based (MAIAR platform)
5. **PromptL** - LLM-native (Latitude, specialized)

**Your Codebase**:
- Already uses Handlebars (`{{{workingMemory}}}`, `{{toolCount}}`)
- Enhancement: Extract to separate `.hbs` files
- Benefit: Version control, reusability, testing

**Variable Injection Patterns**:
- Simple substitution: `{{variable}}`
- Conditional: `{{#if condition}}...{{/if}}`
- Loops: `{{#each array}}...{{/each}}`
- Raw injection: `{{{unescaped}}}`
- Defaults: `{{default variable fallback}}`
- Filters: `{{variable|filter}}`

**Implementation**:
```typescript
// 1. Create template engine
const engine = new PromptTemplateEngine('./prompts');

// 2. Load template
const prompt = engine.render('react', context);

// 3. Use with LLM
const response = await generateText({ prompt });
```

## Navigation

- [← Previous: 1.2.5 Modular Prompt Architecture](./1.2.5-modular-architecture.md)
- [↑ Back to Knowledge Base TOC](../../AI_KNOWLEDGE_BASE_TOC.md)
- [→ Next: 1.3.2 Conditional Sections & Control Flow](./1.3.2-conditional-sections.md)

---

*Part of Layer 1: Prompt Engineering - Dynamic prompts with template engines*
