# 1.3.2 Conditional Sections & Control Flow

## TL;DR

Conditional sections enable prompts to adapt dynamically based on runtime context—user permissions, environment, model capabilities, or task complexity; instead of maintaining multiple prompt variants, single adaptive templates use control flow (if/else, loops, switches) to include/exclude sections based on context.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-03
- **Prerequisites**: [1.3.1 Template Engines](./1.3.1-template-engines.md)
- **Grounded In**: Production AI Engineering, Context-Aware Prompt Design

## Table of Contents

- [Overview](#overview)
- [The Problem: Multiple Prompt Variants](#the-problem-multiple-prompt-variants)
- [Core Concept](#core-concept)
- [Implementation Patterns](#implementation-patterns)
- [When to Use This Pattern](#when-to-use-this-pattern)
- [Production Best Practices](#production-best-practices)
- [Key Takeaways](#key-takeaways)
- [References](#references)

## Overview

**Conditional sections** enable prompts to adapt dynamically based on runtime context—user permissions, environment (dev/prod), model capabilities, task complexity, or available resources. Instead of maintaining multiple prompt variants, you use control flow logic within a single template.

**Key Insight** (2024-2025): Production-grade prompts are context-aware, not one-size-fits-all. Conditional logic is essential for building adaptive AI agents.

**Common Conditional Triggers**:

| Trigger | Example |
|---------|---------|
| **Environment** | Show debug info in dev, validation in prod |
| **Permissions** | Show only tools user can access |
| **Model** | Adapt instructions to model capabilities |
| **Task Type** | Show relevant examples for current task |
| **Complexity** | Adjust guidance depth for task difficulty |

**Date Verified**: 2025-12-03

## The Problem: Multiple Prompt Variants

### The Classic Challenge

Without conditionals, you maintain separate prompts for each scenario:

```typescript
// ❌ Multiple variants: Combinatorial explosion
const promptDev = `You are an AI agent. DEBUG MODE ACTIVE...`;
const promptProd = `You are an AI agent. PRODUCTION MODE: Extra validation...`;
const promptReadOnly = `You are an AI agent. READ-ONLY MODE...`;
const promptAdmin = `You are an AI agent. ADMIN MODE: Full access...`;

// Complex selection logic
let prompt;
if (env === 'production') {
  if (user.isAdmin) {
    prompt = promptAdmin;
  } else if (user.isReadOnly) {
    prompt = promptReadOnly;
  } else {
    prompt = promptProd;
  }
} else {
  prompt = promptDev;
}
```

**Problems**:

- ❌ **Duplication**: Core instructions repeated in each variant
- ❌ **Hard to maintain**: Update one, must update all others
- ❌ **Combinatorial explosion**: N permissions × M environments
- ❌ **No reusability**: Each variant is standalone

### Why This Matters

- Single source of truth reduces errors
- Easier to test one template vs many
- Context-awareness improves UX
- Reduces prompt management overhead

## Core Concept

### Single Adaptive Template

```handlebars
You are an AI agent specialized in content management.

{{#if isDevelopment}}
**DEBUG MODE:** Verbose logging enabled.
{{else}}
**PRODUCTION MODE:** Extra validation required.
{{/if}}

{{#if user.isAdmin}}
**ADMIN ACCESS:** Full capabilities including:
- Delete operations
- Bulk modifications
- System configuration
{{else if user.canWrite}}
**WRITE ACCESS:** Standard capabilities including:
- Create pages
- Update content
- Delete own content (requires confirmation)
{{else}}
**READ-ONLY ACCESS:** Limited to:
- View content
- Search operations
{{/if}}

{{#if hasWorkingMemory}}
**WORKING MEMORY:**
{{{workingMemory}}}
{{/if}}
```

**Benefits**:

- ✅ Single source of truth
- ✅ Easy to maintain
- ✅ Scales to complex logic
- ✅ Context-aware behavior

## Implementation Patterns

### Pattern 1: Environment-Based Instructions

**Use Case**: Different behavior for dev/staging/production

```handlebars
You are an autonomous AI assistant.

{{#if (eq environment "production")}}
**PRODUCTION MODE:**
- Extra validation enabled for all operations
- Audit logging active
- Rate limiting: 100 requests/minute
- Fail-safe: Always ask before destructive operations
{{else if (eq environment "staging")}}
**STAGING MODE:**
- Validation enabled
- Test data: Safe to experiment
- Rate limiting: 1000 requests/minute
{{else}}
**DEVELOPMENT MODE:**
- Debug logging enabled
- No rate limiting
- Experimental features available
{{/if}}
```

**Context Building**:

```typescript
const context = {
  environment: process.env.NODE_ENV,
  isProduction: process.env.NODE_ENV === 'production'
};
```

### Pattern 2: Permission-Based Capabilities

**Use Case**: Show only tools/features user can access

```handlebars
**AVAILABLE CAPABILITIES:**

{{#if permissions.canRead}}
- **READ:** View pages, sections, collections
{{/if}}

{{#if permissions.canWrite}}
- **WRITE:** Create and update content
{{/if}}

{{#if permissions.canDelete}}
- **DELETE:** Remove content (requires confirmation)
{{/if}}

{{#if permissions.canAdmin}}
- **ADMIN:** Manage users, configure system
{{/if}}

{{#unless permissions.canWrite}}
**NOTE:** You have read-only access. Suggest edits but cannot execute write operations.
{{/unless}}

**TOOLS:** {{tools.length}} available
{{#each tools}}
{{#if (hasPermission @root.permissions this.requiredPermission)}}
- {{name}}: {{description}}
{{/if}}
{{/each}}
```

**Benefit**: Prompts automatically reflect user's actual capabilities.

### Pattern 3: Model-Specific Instructions

**Use Case**: Adapt to model capabilities

```handlebars
You are an AI assistant powered by {{modelName}}.

{{#if (eq modelFamily "o1")}}
**REASONING MODEL ACTIVE:**
- You have extended thinking time for complex problems
- Break down tasks into reasoning steps
- Show your chain-of-thought naturally
- No need for explicit "think step-by-step" prompts
{{else if (eq modelFamily "gpt-4")}}
**STANDARD MODEL:**
- Use chain-of-thought prompting for complex tasks
- Think step-by-step when needed
- Balance speed and accuracy
{{else}}
**FAST MODEL:**
- Prioritize speed over deep reasoning
- Use for simple, well-defined tasks
- Escalate complex problems to more capable models
{{/if}}

{{#if supportsStructuredOutputs}}
**STRUCTURED OUTPUTS ENABLED:**
All tool calls will use JSON Schema validation.
{{/if}}

{{#if supportsFunctionCalling}}
**FUNCTION CALLING AVAILABLE:**
Use native function calling for tool execution.
{{else}}
**TEXT-BASED TOOLS:**
Format tool calls as: Action: [tool_name]
Action Input: [parameters]
{{/if}}
```

### Pattern 4: Task Complexity Adaptation

**Use Case**: Adjust guidance based on task difficulty

```handlebars
TASK: {{task}}

{{#if (gt taskComplexity 7)}}
**HIGH COMPLEXITY TASK:**
1. Break down into sub-tasks
2. Execute incrementally
3. Validate each step before proceeding
4. Expect multiple rounds of tool usage
5. Synthesize results at the end

**SUGGESTED APPROACH:**
- Plan: List all required information/actions
- Execute: One tool at a time, observe results
- Adapt: Adjust plan based on observations
- Verify: Double-check critical results
{{else if (gt taskComplexity 4)}}
**MODERATE COMPLEXITY:**
- Think through the approach first
- Use 2-3 tool calls to gather information
- Provide clear, structured response
{{else}}
**SIMPLE TASK:**
- Execute directly
- Minimal explanation needed
- Quick, focused response
{{/if}}
```

### Pattern 5: Context-Aware Examples

**Use Case**: Show relevant examples based on task type

```handlebars
**EXAMPLES:**

{{#if (eq taskType "search")}}
**EXAMPLE - Search Task:**
User: Find pages about React
Thought: I need to use the fuzzy search tool
Action: searchResources
Action Input: { "query": "React", "type": "page" }
Observation: Found 3 pages: [list]
Response: I found 3 pages about React: [summarized results]
{{/if}}

{{#if (eq taskType "creation")}}
**EXAMPLE - Creation Task:**
User: Create a new page titled "Getting Started"
Thought: I need to check if slug exists, then create
Action: getPage
Action Input: { "slug": "getting-started", "fetchMode": "lightweight" }
Observation: Error: Page not found
Thought: Slug is available, I can create the page
Action: createPage
Action Input: { "title": "Getting Started", "slug": "getting-started" }
Observation: Page created successfully
{{/if}}

{{#if (eq taskType "deletion")}}
**EXAMPLE - Deletion Task:**
User: Delete the old blog post
Thought: I need to identify the page and get confirmation
Action: findResource
Action Input: { "query": "old blog post", "type": "page" }
Observation: Found page-456: "Old Blog Post"
Response: I found "Old Blog Post" (page-456). Are you sure you want to delete it?
{{/if}}
```

### Pattern 6: Graceful Degradation

**Use Case**: Handle missing context gracefully

```handlebars
{{#if workingMemory}}
**WORKING MEMORY:**
{{{workingMemory}}}
{{else}}
**FRESH SESSION:** No prior context available. Ask clarifying questions if needed.
{{/if}}

{{#if userPreferences}}
**USER PREFERENCES:**
- Language: {{userPreferences.language}}
- Verbosity: {{userPreferences.verbosity}}
- Format: {{userPreferences.outputFormat}}
{{else}}
**DEFAULT PREFERENCES:** Using standard English, moderate verbosity, markdown format.
{{/if}}

{{#if (gt tools.length 0)}}
**TOOLS AVAILABLE:** {{tools.length}} tools
{{toolsFormatted}}
{{else}}
**NO TOOLS:** You can only provide informational responses.
{{/if}}
```

## When to Use This Pattern

### ✅ Use Conditional Sections When

1. **Multiple environments** - Dev/staging/prod variations
2. **User permissions** - Different access levels
3. **Model variations** - Different model capabilities
4. **Task types** - Context-specific examples
5. **Optional features** - Graceful handling of missing context

### ❌ Use Separate Templates When

1. **Fundamentally different** - Agents with no shared content
2. **Very simple prompts** - No conditionals needed
3. **Performance critical** - Template parsing overhead matters
4. **Clear separation** - Variants never share logic

### Decision Matrix

| Your Situation | Recommended Approach |
|----------------|----------------------|
| Same core with variations | Conditional sections |
| Completely different agents | Separate templates |
| 2-3 simple flags | Conditional sections |
| Complex inheritance | Modular + conditionals |

## Production Best Practices

### 1. Register Custom Helpers

```typescript
// Comparison helpers
Handlebars.registerHelper('eq', (a, b) => a === b);
Handlebars.registerHelper('ne', (a, b) => a !== b);
Handlebars.registerHelper('gt', (a, b) => a > b);
Handlebars.registerHelper('gte', (a, b) => a >= b);
Handlebars.registerHelper('lt', (a, b) => a < b);
Handlebars.registerHelper('lte', (a, b) => a <= b);

// Logical helpers
Handlebars.registerHelper('and', (a, b) => a && b);
Handlebars.registerHelper('or', (a, b) => a || b);
Handlebars.registerHelper('not', (a) => !a);

// Utility helpers
Handlebars.registerHelper('includes', (array, item) =>
  Array.isArray(array) && array.includes(item)
);

Handlebars.registerHelper('hasPermission', (userPerms, requiredPerm) => {
  if (!requiredPerm) return true;
  return userPerms && userPerms.includes(requiredPerm);
});
```

### 2. Build Rich Context

```typescript
interface PromptContext {
  environment: 'development' | 'staging' | 'production';
  user: {
    permissions: string[];
    isAdmin: boolean;
    isReadOnly: boolean;
    isNewUser: boolean;
  };
  task: {
    type: 'search' | 'creation' | 'update' | 'deletion';
    complexity: number;
  };
  model: {
    family: 'gpt-4' | 'o1' | 'claude';
    supportsStructuredOutputs: boolean;
  };
  tools: Tool[];
  workingMemory?: string;
}

const context: PromptContext = {
  environment: process.env.NODE_ENV as any,
  user: {
    permissions: user.permissions,
    isAdmin: user.permissions.includes('admin'),
    isReadOnly: !user.permissions.includes('write'),
    isNewUser: user.createdAt > Date.now() - 7 * 24 * 60 * 60 * 1000
  },
  task: { type: 'search', complexity: 5 },
  model: { family: 'gpt-4', supportsStructuredOutputs: true },
  tools: availableTools,
  workingMemory: memory.serialize()
};
```

### 3. Test Conditional Branches

```typescript
describe('Prompt Conditionals', () => {
  test('should show production warnings in prod env', () => {
    const prompt = engine.render('react', { environment: 'production' });
    expect(prompt).toContain('PRODUCTION MODE');
    expect(prompt).toContain('Extra validation');
  });

  test('should hide admin tools for non-admin users', () => {
    const prompt = engine.render('react', {
      user: { isAdmin: false, permissions: ['read', 'write'] },
      tools: [
        { name: 'getPage', requiredPermission: 'read' },
        { name: 'configureSystem', requiredPermission: 'admin' }
      ]
    });
    expect(prompt).toContain('getPage');
    expect(prompt).not.toContain('configureSystem');
  });

  test('should show task-specific examples', () => {
    const prompt = engine.render('react', { task: { type: 'search' } });
    expect(prompt).toContain('EXAMPLE - Search Task');
    expect(prompt).not.toContain('EXAMPLE - Creation Task');
  });
});
```

### Common Pitfalls

**❌ Over-nested conditionals**:

```handlebars
{{#if a}}{{#if b}}{{#if c}}...{{/if}}{{/if}}{{/if}}
```

Better: Flatten with computed flags in context.

**❌ Missing else branches**:

Silent failures when condition is false.

**❌ Untested branches**:

Production discovers broken conditionals.

**❌ Complex logic in templates**:

Move complex logic to context building, keep templates simple.

## Key Takeaways

1. **Single template, multiple behaviors** - Conditionals enable adaptive prompts
2. **Build rich context** - Pre-compute flags for cleaner templates
3. **Register helpers** - eq, gt, and, or for flexible conditions
4. **Test all branches** - Every conditional path needs a test
5. **Graceful degradation** - Always handle missing context

**Quick Implementation Checklist**:

- [ ] Register comparison helpers (eq, gt, lt)
- [ ] Register logical helpers (and, or, not)
- [ ] Build context builder class
- [ ] Add computed flags to context
- [ ] Write tests for each conditional branch
- [ ] Handle all falsy/missing cases

## References

1. **Handlebars** (2025). "Block Helpers and Conditionals". https://handlebarsjs.com/guide/block-helpers.html
2. **Jinja2** (2025). "Control Structures". https://jinja.palletsprojects.com/en/3.1.x/templates/#list-of-control-structures
3. **Microsoft** (2025). "Semantic Kernel Prompt Functions". https://learn.microsoft.com/en-us/semantic-kernel/concepts/prompts/
4. **Anthropic** (2025). "Context-Aware Prompt Design". Anthropic Documentation.

**Related Topics**:

- [1.3.1 Template Engines](./1.3.1-template-engines.md)
- [1.3.3 Versioning & Caching](./1.3.3-versioning-caching.md)
- [1.2.5 Modular Architecture](./1.2.5-modular-architecture.md)

**Layer Index**: [Layer 1: Prompt Engineering](../AI_KNOWLEDGE_BASE_TOC.md#layer-1-prompt-engineering)
