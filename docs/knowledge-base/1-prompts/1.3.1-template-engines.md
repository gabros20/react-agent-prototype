# 1.3.1 Template Engines & Variable Injection

## TL;DR

Template engines (Jinja2, Handlebars, Mustache, Liquid) transform static prompt strings into dynamic, context-aware instructions through variable substitution, conditionals, and loops; they're the industry standard for production LLM applications, with Jinja2 dominating Python and Handlebars leading JavaScript/TypeScript ecosystems.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-03
- **Prerequisites**: [1.2.5 Modular Architecture](./1.2.5-modular-architecture.md)
- **Grounded In**: Microsoft Semantic Kernel, PromptLayer, Vercel AI SDK, LangChain Prompt Templates

## Table of Contents

- [Overview](#overview)
- [The Problem: String Concatenation Hell](#the-problem-string-concatenation-hell)
- [Core Concept](#core-concept)
- [Implementation Patterns](#implementation-patterns)
- [When to Use This Pattern](#when-to-use-this-pattern)
- [Production Best Practices](#production-best-practices)
- [Key Takeaways](#key-takeaways)
- [References](#references)

## Overview

**Template engines** transform static prompt strings into dynamic, context-aware instructions by enabling variable substitution, conditional logic, and iterative structures. Instead of manually concatenating strings, you use a templating language to create reusable prompt patterns.

**Key Insight** (2024-2025): Modern LLM frameworks standardized on web development template engines (Jinja2, Handlebars, Mustache, Liquid) rather than inventing prompt-specific syntaxes.

**Ecosystem Breakdown**:

| Engine | Language | Used By |
|--------|----------|---------|
| **Jinja2** | Python | Semantic Kernel, Watsonx, Instructor, PromptLayer |
| **Handlebars** | JavaScript/TypeScript | .NET Semantic Kernel, many Node.js frameworks |
| **Mustache** | Multi-language | Portkey, legacy systems |
| **Liquid** | Ruby/JS | MAIAR platform, Shopify ecosystem |

**Date Verified**: 2025-12-03

## The Problem: String Concatenation Hell

### The Classic Challenge

Without templates, prompt building becomes error-prone and hard to maintain:

```typescript
// ❌ String concatenation hell
let prompt = "You are an AI assistant.";

if (workingMemory) {
  prompt += "\n\nWORKING MEMORY:\n" + workingMemory;
}

prompt += "\n\nAVAILABLE TOOLS: " + tools.length + " tools\n";

for (const tool of tools) {
  prompt += "- " + tool.name + ": " + tool.description + "\n";
}

if (examples.length > 0) {
  prompt += "\n\nEXAMPLES:\n";
  for (const example of examples) {
    prompt += example.formatted + "\n";
  }
}
```

**Problems**:

- ❌ **Difficult to read**: Logic mixed with content
- ❌ **Error-prone**: Missing newlines, spacing issues
- ❌ **Hard to visualize**: Can't see final output structure
- ❌ **No separation**: Content and logic intertwined
- ❌ **Tedious**: Verbose conditional handling

### Why This Matters

- Templates enable non-technical users to edit prompts
- Clear structure makes debugging easier
- Consistent formatting across all prompts
- Reusable patterns reduce duplication

## Core Concept

### Template vs String Concatenation

**With Templates** (declarative approach):

```handlebars
You are an AI assistant.

{{#if workingMemory}}
WORKING MEMORY:
{{{workingMemory}}}
{{/if}}

AVAILABLE TOOLS: {{toolCount}} tools
{{#each tools}}
- {{name}}: {{description}}
{{/each}}

{{#if examples}}
EXAMPLES:
{{#each examples}}
{{{formatted}}}
{{/each}}
{{/if}}

RULES:
{{#each rules}}
- {{this}}
{{/each}}
```

**Benefits**:

- ✅ Clear, readable structure
- ✅ Separation of content and logic
- ✅ Easy to visualize output
- ✅ Consistent formatting
- ✅ Reusable across contexts

### Common Template Features

| Feature | Jinja2 | Handlebars | Mustache |
|---------|--------|------------|----------|
| Variable | `{{ var }}` | `{{var}}` | `{{var}}` |
| Raw (unescaped) | `{{ var\|safe }}` | `{{{var}}}` | `{{{var}}}` |
| Conditional | `{% if %}...{% endif %}` | `{{#if}}...{{/if}}` | `{{#section}}...{{/section}}` |
| Loop | `{% for %}...{% endfor %}` | `{{#each}}...{{/each}}` | `{{#list}}...{{/list}}` |
| Comment | `{# comment #}` | `{{!-- comment --}}` | `{{! comment}}` |

## Implementation Patterns

### Pattern 1: Jinja2 (Python Standard)

**Use Case**: Python LLM applications, Microsoft/IBM ecosystem

```jinja2
You are {{agent_name}}, an autonomous AI assistant.

{% if context %}
CONTEXT:
{{ context }}
{% endif %}

AVAILABLE TOOLS: {{ tools|length }} tools
{% for tool in tools %}
- {{ tool.name }}: {{ tool.description }}
{% endfor %}

{% if environment == "production" %}
EXTRA VALIDATION: Always double-check destructive operations.
{% endif %}
```

**Python Usage**:

```python
from jinja2 import Environment, FileSystemLoader

env = Environment(loader=FileSystemLoader('./prompts'))
template = env.get_template('react.j2')

prompt = template.render(
    agent_name='CMS Agent',
    context=user_context,
    tools=available_tools,
    environment='production'
)
```

**Pros**:

- ✅ Python ecosystem standard
- ✅ Powerful filters (`|length`, `|upper`, `|default`)
- ✅ Template inheritance
- ✅ Auto-escaping

**Cons**:

- ❌ Python-only (mostly)
- ❌ More complex syntax

### Pattern 2: Handlebars (JavaScript/TypeScript)

**Use Case**: TypeScript/Node.js applications, your codebase

```handlebars
You are an autonomous AI assistant using the ReAct pattern.

{{#if workingMemory}}
**WORKING MEMORY:**
{{{workingMemory}}}
{{/if}}

**AVAILABLE TOOLS:** {{toolCount}} tools
{{#each tools}}
- {{name}}: {{description}}
  {{#if parameters}}
  Parameters: {{json parameters}}
  {{/if}}
{{/each}}

{{#if (gt toolCount 10)}}
NOTE: Many tools available - use search to find relevant ones.
{{/if}}
```

**TypeScript Usage**:

```typescript
import Handlebars from 'handlebars';

// Register custom helpers
Handlebars.registerHelper('json', (obj) => JSON.stringify(obj, null, 2));
Handlebars.registerHelper('gt', (a, b) => a > b);

// Compile template
const template = Handlebars.compile(templateSource);

// Render with context
const prompt = template({
  workingMemory: context.memory,
  toolCount: tools.length,
  tools: tools.map(t => ({
    name: t.name,
    description: t.description,
    parameters: t.parameters
  }))
});
```

**Pros**:

- ✅ JavaScript/TypeScript native
- ✅ Raw injection with `{{{}}}`
- ✅ Custom helpers
- ✅ Precompilation for speed

**Cons**:

- ❌ Logic-less (limited built-in conditions)
- ❌ Requires helpers for complex logic

### Pattern 3: Mustache (Minimal, Logic-less)

**Use Case**: Simple templates, cross-language compatibility

```mustache
You are {{agent_name}}.

{{#has_context}}
CONTEXT:
{{context}}
{{/has_context}}

TOOLS:
{{#tools}}
- {{name}}: {{description}}
{{/tools}}

{{^is_read_only}}
You can perform write operations.
{{/is_read_only}}
```

**Key Features**:

- `{{variable}}` - Variable substitution
- `{{#section}}...{{/section}}` - Truthy/iterable sections
- `{{^section}}...{{/section}}` - Inverted (falsy) sections
- Logic-less philosophy

**Pros**:

- ✅ Minimal syntax
- ✅ Language-agnostic
- ✅ Easy to learn

**Cons**:

- ❌ No complex conditionals
- ❌ No filters/transformations

### Pattern 4: TypeScript Template Engine Class

**Use Case**: Production applications with caching and validation

```typescript
import Handlebars from 'handlebars';
import fs from 'fs';
import path from 'path';

// Register helpers
Handlebars.registerHelper('json', (obj) => JSON.stringify(obj, null, 2));
Handlebars.registerHelper('gt', (a, b) => a > b);
Handlebars.registerHelper('default', (value, defaultValue) =>
  value !== undefined ? value : defaultValue
);

export class PromptTemplateEngine {
  private templates = new Map<string, HandlebarsTemplateDelegate>();
  private templateDir: string;

  constructor(templateDir: string) {
    this.templateDir = templateDir;
  }

  loadTemplate(name: string): void {
    const templatePath = path.join(this.templateDir, `${name}.hbs`);
    const source = fs.readFileSync(templatePath, 'utf-8');
    this.templates.set(name, Handlebars.compile(source));
  }

  render(name: string, context: any): string {
    if (!this.templates.has(name)) {
      this.loadTemplate(name);
    }
    const template = this.templates.get(name)!;
    return template(context);
  }

  renderString(source: string, context: any): string {
    const template = Handlebars.compile(source);
    return template(context);
  }
}

// Usage
const engine = new PromptTemplateEngine('./server/prompts');

const prompt = engine.render('react', {
  workingMemory: context.getWorkingMemory(),
  toolCount: tools.length,
  toolsFormatted: formatTools(tools),
  sessionId: session.id,
  currentDate: new Date().toISOString(),
  isProduction: process.env.NODE_ENV === 'production'
});
```

## When to Use This Pattern

### ✅ Use Template Engines When

1. **Dynamic prompts** - Content changes based on context
2. **Multiple environments** - Dev/staging/prod variations
3. **Team collaboration** - Non-engineers edit prompts
4. **Complex prompts** - Conditionals, loops, multiple sections
5. **Production systems** - Need consistent, maintainable prompts

### ❌ Use Simple Strings When

1. **Static prompts** - No dynamic content
2. **Quick prototypes** - Minimal setup needed
3. **Single variable** - Just one substitution
4. **Performance critical** - No template parsing overhead

### Engine Selection Guide

| Your Situation | Recommended Engine |
|----------------|-------------------|
| Python LLM app | Jinja2 |
| TypeScript/Node.js | Handlebars |
| Cross-language | Mustache |
| Shopify/e-commerce | Liquid |
| Minimal dependencies | Mustache |

## Production Best Practices

### 1. Separate Templates from Code

```typescript
// ❌ Bad: Inline templates
const prompt = `You are ${agentName}...`;

// ✅ Good: External template files
const prompt = engine.render('react', { agentName });
```

**Why**: Version control, collaboration, debugging.

### 2. Use Raw Injection for Pre-formatted Content

```handlebars
{{!-- Escaped (HTML entities) --}}
{{content}}

{{!-- Raw/unescaped (preserves formatting) --}}
{{{workingMemory}}}
```

**When**: Working memory, pre-formatted tool output, HTML/XML content.

### 3. Provide Sensible Defaults

```handlebars
Agent: {{default agentName "Default Agent"}}
Temperature: {{default temperature 0.7}}
```

**Why**: Prevents undefined errors, documents expected values.

### 4. Comments Don't Consume Tokens

```handlebars
{{!-- This comment won't be in the rendered output --}}
```

```jinja2
{# This comment is stripped during rendering #}
```

**Why**: Document templates without increasing prompt cost.

### 5. Validate Templates at Build Time

```typescript
// Test that all templates compile without errors
describe('Prompt Templates', () => {
  const templates = ['react', 'assistant', 'cms-agent'];

  templates.forEach(name => {
    test(`${name} template compiles`, () => {
      expect(() => engine.loadTemplate(name)).not.toThrow();
    });

    test(`${name} renders with minimal context`, () => {
      const result = engine.render(name, { toolCount: 0, tools: [] });
      expect(result).toBeDefined();
      expect(result.length).toBeGreaterThan(0);
    });
  });
});
```

### Common Pitfalls

**❌ Missing raw injection**:

```handlebars
{{workingMemory}}  <!-- Escapes HTML, breaks formatting -->
{{{workingMemory}}} <!-- Preserves original formatting -->
```

**❌ Undefined variables**:

No fallback for missing context values causes silent failures.

**❌ Template in code**:

Embedding large templates in source files hurts maintainability.

**❌ No caching**:

Recompiling templates on every request wastes CPU.

## Key Takeaways

1. **Industry standard** - Jinja2 (Python), Handlebars (JS/TS)
2. **Separation of concerns** - Content separate from logic
3. **Raw injection** - Use `{{{...}}}` for pre-formatted content
4. **External files** - Keep templates in separate `.hbs`/`.j2` files
5. **Cache templates** - Compile once, reuse many times

**Quick Implementation Checklist**:

- [ ] Choose engine (Jinja2 for Python, Handlebars for TS)
- [ ] Create template directory structure
- [ ] Register custom helpers (json, default, conditionals)
- [ ] Build template engine class with caching
- [ ] Write tests for template compilation
- [ ] Document variable requirements per template

## References

1. **Jinja2** (2025). "Template Designer Documentation". https://jinja.palletsprojects.com/
2. **Handlebars** (2025). "Handlebars.js Documentation". https://handlebarsjs.com/
3. **Mustache** (2025). "Mustache Manual". https://mustache.github.io/mustache.5.html
4. **Microsoft** (2025). "Semantic Kernel Prompt Templates". https://learn.microsoft.com/en-us/semantic-kernel/concepts/prompts/
5. **PromptLayer** (2025). "Prompt Templates with Jinja2". https://blog.promptlayer.com/prompt-templates-with-jinja2-2/

**Related Topics**:

- [1.2.5 Modular Architecture](./1.2.5-modular-architecture.md)
- [1.3.2 Conditional Sections](./1.3.2-conditional-sections.md)
- [1.3.3 Versioning & Caching](./1.3.3-versioning-caching.md)

**Layer Index**: [Layer 1: Prompt Engineering](../AI_KNOWLEDGE_BASE_TOC.md#layer-1-prompt-engineering)
