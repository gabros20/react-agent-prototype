# 1.2.5 System Prompts: Modular Prompt Architecture

## Overview

Modular prompt architecture treats prompts as composable, reusable components rather than monolithic blocks of text. Like building with LEGO bricks, you create specialized modules that can be combined, swapped, and reused across different contexts. This approach scales from prototype to production, enabling versioning, testing, and maintenance of complex prompt systems.

**Key Insight** (2024-2025): Treat prompts as code—modular, versioned, tested, and composable.

**Current Date**: November 17, 2025

## Why Modular Architecture

### Problem: Monolithic Prompts Don't Scale

**Monolithic Approach** (single giant prompt):
```xml
You are an AI assistant. You help with content management. You can create, 
read, update, and delete pages. You must think before acting. You should 
use tools efficiently. When creating pages, check if slug exists first. 
When deleting, ask for confirmation. For searches, use fuzzy matching. 
Always return JSON. Be concise but thorough. If you encounter errors, 
explain them clearly. Use working memory for context. Remember the user's 
previous requests...

[500 more lines of mixed concerns]
```

**Problems**:
- ❌ Hard to update (change one thing, risk breaking others)
- ❌ Can't reuse parts across different agents
- ❌ Difficult to test individual components
- ❌ No version control per concern
- ❌ Prompt becomes unmaintainable at scale

**Modular Approach**:
```typescript
const systemPrompt = compose([
  roleModule,           // "You are an autonomous AI assistant"
  capabilitiesModule,   // List of available tools
  rulesModule,          // Safety and operational rules
  formatModule,         // Output format specification
  contextModule,        // Working memory injection
  examplesModule        // Few-shot demonstrations
]);
```

**Benefits**:
- ✅ Update one module without affecting others
- ✅ Reuse modules across multiple agents
- ✅ Test each module independently
- ✅ Version control per concern
- ✅ Maintainable and scalable

## Modular Architecture Patterns

### Pattern 1: Layer-Based Composition

**Conceptual Layers**:
```
┌─────────────────────────────────────┐
│ Layer 1: Core Identity              │  (Role, persona)
├─────────────────────────────────────┤
│ Layer 2: Capabilities               │  (What you can do)
├─────────────────────────────────────┤
│ Layer 3: Rules & Constraints        │  (How you must behave)
├─────────────────────────────────────┤
│ Layer 4: Output Format              │  (Response structure)
├─────────────────────────────────────┤
│ Layer 5: Context                    │  (Dynamic data)
├─────────────────────────────────────┤
│ Layer 6: Examples                   │  (Few-shot demonstrations)
└─────────────────────────────────────┘
```

**Implementation**:
```typescript
// Define modules
const modules = {
  role: `You are an autonomous AI assistant using the ReAct pattern.`,
  
  capabilities: `
Your capabilities include:
- Content management (pages, sections, collections)
- Fuzzy resource search
- Multi-step task execution
  `,
  
  rules: `
**CRITICAL RULES:**
1. THINK before acting
2. EXECUTE immediately
3. NEVER auto-confirm deletions
  `,
  
  format: `
**OUTPUT FORMAT:**
Thought: [reasoning]
Action: [tool]
Action Input: [parameters]
Observation: [result]
  `,
  
  context: (workingMemory) => `
**WORKING MEMORY:**
${workingMemory}
  `,
  
  examples: `
**EXAMPLE SESSION:**
[demonstration]
  `
};

// Compose final prompt
function buildPrompt(workingMemory: string): string {
  return [
    modules.role,
    modules.capabilities,
    modules.rules,
    modules.format,
    modules.context(workingMemory),
    modules.examples
  ].join('\n\n');
}
```

### Pattern 2: Tag-Based Modules

**Structure with semantic tags**:
```xml
<role>
You are an autonomous AI assistant using the ReAct pattern.
</role>

<capabilities>
- Content management tools
- Search functionality
- Multi-step planning
</capabilities>

<rules priority="critical">
1. NEVER auto-confirm deletions
2. ALWAYS show reasoning
</rules>

<format>
Thought: [reasoning]
Action: [tool]
</format>

<context dynamic="true">
{{workingMemory}}
</context>
```

**Benefits**:
- Clear boundaries between modules
- Easy to parse and extract
- Self-documenting structure
- Can programmatically manipulate

### Pattern 3: Function-Based Modules

**Modules as functions that return prompt strings**:
```typescript
// Module definition
type PromptModule = (context: Context) => string;

// Core modules
const roleModule: PromptModule = (ctx) => `
You are ${ctx.agentName}, an autonomous AI assistant.
`;

const toolsModule: PromptModule = (ctx) => `
**AVAILABLE TOOLS:** ${ctx.tools.length} tools

${ctx.tools.map(t => `- ${t.name}: ${t.description}`).join('\n')}
`;

const rulesModule: PromptModule = (ctx) => {
  const rules = [...ctx.coreRules];
  if (ctx.environment === 'production') {
    rules.push('- EXTRA VALIDATION: Always double-check destructive operations');
  }
  return `**RULES:**\n${rules.join('\n')}`;
};

// Compose
const buildPrompt = (ctx: Context): string => {
  return [
    roleModule(ctx),
    toolsModule(ctx),
    rulesModule(ctx)
  ].filter(Boolean).join('\n\n');
};
```

### Pattern 4: Registry Pattern

**Central module registry for reusability**:
```typescript
// Module registry
class PromptModuleRegistry {
  private modules = new Map<string, PromptModule>();
  
  register(name: string, module: PromptModule) {
    this.modules.set(name, module);
  }
  
  get(name: string): PromptModule | undefined {
    return this.modules.get(name);
  }
  
  compose(moduleNames: string[], context: Context): string {
    return moduleNames
      .map(name => this.get(name))
      .filter(Boolean)
      .map(module => module!(context))
      .join('\n\n');
  }
}

// Usage
const registry = new PromptModuleRegistry();

// Register reusable modules
registry.register('role:agent', roleAgentModule);
registry.register('role:assistant', roleAssistantModule);
registry.register('tools:cms', cmsToolsModule);
registry.register('rules:safety', safetyRulesModule);
registry.register('rules:quality', qualityRulesModule);

// Build different agent types
const cmsAgent = registry.compose([
  'role:agent',
  'tools:cms',
  'rules:safety',
  'rules:quality'
], context);

const readOnlyAgent = registry.compose([
  'role:assistant',
  'tools:cms',
  'rules:safety'
], context);
```

## Your Codebase Example

**Current Approach** (`server/prompts/react.xml`):
```xml
<agent>
You are an autonomous AI assistant using the ReAct pattern.

{{{workingMemory}}}

**CORE LOOP:**
Think → Act → Observe → Repeat

**CRITICAL RULES:**
1. THINK before acting
2. EXECUTE immediately
...

**EXAMPLE SESSION:**
[examples]

**AVAILABLE TOOLS:** {{toolCount}} tools
{{toolsFormatted}}
</agent>
```

**Analysis**:
✅ **Already modular in spirit**:
- Clear sections (role, loop, rules, examples, tools)
- Variable injection (`{{{workingMemory}}}`, `{{toolCount}}`)
- Handlebars templating

**Enhancement: Explicit Modularity**:
```typescript
// prompts/modules/index.ts
export const modules = {
  role: `You are an autonomous AI assistant using the ReAct pattern.`,
  
  workingMemory: (memory: string) => memory ? `
**WORKING MEMORY:**
${memory}
  ` : '',
  
  coreLoop: `
**CORE LOOP:**
Think → Act → Observe → Repeat until completion

Think step-by-step:
1. Analyze the question and identify what information/actions you need
2. Execute ONE tool at a time with the appropriate input
3. Observe the result and integrate it into your reasoning
4. Continue until you have enough information or the task is complete
5. When done, provide a final answer
  `,
  
  criticalRules: `
**CRITICAL RULES:**
1. **THINK before acting** - Explain your reasoning for each step
2. **EXECUTE immediately** - Don't ask unnecessary clarifying questions
3. **CHAIN operations** - Complete multi-step tasks in one conversation turn
4. **OBSERVE results** - Use tool outputs to inform your next action
5. **RECURSE when needed** - Continue until the task is fully complete
  `,
  
  destructiveOps: `
**DESTRUCTIVE OPERATIONS:**
- Deletion tools require user confirmation
- NEVER auto-confirm deletions
- Always wait for explicit user approval
  `,
  
  contentRetrieval: `
**CONTENT RETRIEVAL STRATEGIES:**
This CMS uses granular content fetching for token efficiency:
1. Lightweight First (saves 40-96% tokens)
2. Full Fetch (when needed)
  `,
  
  exampleSession: `
**EXAMPLE SESSION:**
[Your full example here]
  `,
  
  tools: (toolCount: number, toolsFormatted: string) => `
**AVAILABLE TOOLS:** ${toolCount} tools

${toolsFormatted}
  `,
  
  sessionInfo: (sessionId: string, currentDate: string) => `
**SESSION INFO:**
- Session ID: ${sessionId}
- Date: ${currentDate}
  `
};

// Compose final prompt
export function buildReActPrompt(context: {
  workingMemory?: string;
  toolCount: number;
  toolsFormatted: string;
  sessionId: string;
  currentDate: string;
}): string {
  return [
    modules.role,
    modules.workingMemory(context.workingMemory || ''),
    modules.coreLoop,
    modules.criticalRules,
    modules.destructiveOps,
    modules.contentRetrieval,
    modules.exampleSession,
    modules.tools(context.toolCount, context.toolsFormatted),
    modules.sessionInfo(context.sessionId, context.currentDate)
  ].filter(Boolean).join('\n\n');
}
```

## Advanced Modular Patterns

### 1. Conditional Module Loading

**Load modules based on context**:
```typescript
function buildPrompt(context: Context): string {
  const modules = [
    roleModule(context),
    capabilitiesModule(context)
  ];
  
  // Add rules based on environment
  if (context.environment === 'production') {
    modules.push(strictRulesModule(context));
  } else {
    modules.push(lenientRulesModule(context));
  }
  
  // Add tools based on permissions
  if (context.user.canDelete) {
    modules.push(destructiveToolsModule(context));
  }
  
  // Add examples for new users
  if (context.user.isNewUser) {
    modules.push(detailedExamplesModule(context));
  }
  
  return modules.join('\n\n');
}
```

### 2. Module Versioning

**Track and manage prompt versions**:
```typescript
interface VersionedModule {
  name: string;
  version: string;
  content: PromptModule;
  changelog: string;
}

const roleModuleV1: VersionedModule = {
  name: 'role',
  version: '1.0.0',
  content: (ctx) => `You are an AI assistant.`,
  changelog: 'Initial version'
};

const roleModuleV2: VersionedModule = {
  name: 'role',
  version: '2.0.0',
  content: (ctx) => `You are an autonomous AI assistant using the ReAct pattern.`,
  changelog: 'Added ReAct framework specification'
};

// Version registry
class ModuleVersionRegistry {
  getModule(name: string, version: string): VersionedModule {
    // Lookup by name + version
  }
  
  getLatest(name: string): VersionedModule {
    // Get latest version
  }
}

// Use specific version
const prompt = buildPrompt({
  modules: [
    { name: 'role', version: '2.0.0' },
    { name: 'tools', version: '1.5.0' }
  ],
  context
});
```

### 3. Module Inheritance

**Extend base modules for variants**:
```typescript
// Base agent module
const baseAgentModule = {
  role: `You are an AI assistant.`,
  rules: `1. Be helpful\n2. Be accurate`
};

// CMS agent extends base
const cmsAgentModule = {
  ...baseAgentModule,
  role: `${baseAgentModule.role} You specialize in content management.`,
  rules: `${baseAgentModule.rules}\n3. Never auto-confirm deletions`,
  tools: `[CMS-specific tools]`
};

// Read-only agent extends base
const readOnlyAgentModule = {
  ...baseAgentModule,
  role: `${baseAgentModule.role} You can only read data, not modify it.`,
  rules: `${baseAgentModule.rules}\n3. Decline any write operations`
};
```

### 4. Dynamic Module Injection

**Inject modules at runtime based on user input**:
```typescript
async function handleUserQuery(query: string, context: Context) {
  const modules = [roleModule, capabilitiesModule];
  
  // Detect user intent
  const intent = await detectIntent(query);
  
  // Inject relevant modules
  if (intent === 'code_review') {
    modules.push(codeReviewRulesModule);
    modules.push(codeReviewFormatModule);
  } else if (intent === 'data_extraction') {
    modules.push(extractionRulesModule);
    modules.push(jsonFormatModule);
  }
  
  const prompt = modules.map(m => m(context)).join('\n\n');
  
  return await generateResponse(prompt, query);
}
```

### 5. Module Caching

**Cache compiled prompts for performance**:
```typescript
class PromptCache {
  private cache = new Map<string, string>();
  
  getOrBuild(
    key: string, 
    builder: () => string
  ): string {
    if (!this.cache.has(key)) {
      this.cache.set(key, builder());
    }
    return this.cache.get(key)!;
  }
  
  invalidate(key: string) {
    this.cache.delete(key);
  }
}

// Usage
const cache = new PromptCache();

const prompt = cache.getOrBuild(
  `agent:${agentType}:v${version}`,
  () => buildPrompt(context)
);
```

## Testing Modular Prompts

### Unit Testing Individual Modules

```typescript
import { describe, test, expect } from 'vitest';

describe('roleModule', () => {
  test('should include agent name', () => {
    const output = roleModule({ agentName: 'TestAgent' });
    expect(output).toContain('TestAgent');
  });
  
  test('should mention ReAct pattern', () => {
    const output = roleModule({ agentName: 'TestAgent' });
    expect(output).toContain('ReAct');
  });
});

describe('rulesModule', () => {
  test('should include critical rules', () => {
    const output = rulesModule({});
    expect(output).toContain('THINK before acting');
    expect(output).toContain('NEVER auto-confirm');
  });
  
  test('should add production rules in prod environment', () => {
    const output = rulesModule({ environment: 'production' });
    expect(output).toContain('EXTRA VALIDATION');
  });
});
```

### Integration Testing Module Composition

```typescript
describe('buildPrompt', () => {
  test('should compose all modules', () => {
    const context = {
      agentName: 'CMS Agent',
      tools: [{ name: 'getPage', description: 'Get page' }],
      environment: 'development'
    };
    
    const prompt = buildPrompt(context);
    
    // Verify all modules present
    expect(prompt).toContain('You are CMS Agent');
    expect(prompt).toContain('AVAILABLE TOOLS');
    expect(prompt).toContain('CRITICAL RULES');
  });
  
  test('should inject dynamic context', () => {
    const prompt = buildPrompt({
      workingMemory: 'User recently accessed: page-123'
    });
    
    expect(prompt).toContain('page-123');
  });
});
```

### A/B Testing Module Variants

```typescript
// Test two rule variants
const results = await abTest({
  variantA: buildPrompt({ rules: strictRulesModule }),
  variantB: buildPrompt({ rules: lenientRulesModule }),
  testQueries: [
    'Delete all pages',
    'Update homepage',
    'Create new section'
  ],
  metrics: ['accuracy', 'user_satisfaction', 'safety']
});

console.log(`Winner: ${results.winner}`);
console.log(`Confidence: ${results.confidence}`);
```

## Production Best Practices

### 1. Module Documentation

```typescript
/**
 * Role Module - Defines agent identity and expertise
 * 
 * @version 2.0.0
 * @category Core
 * @stability stable
 * 
 * @param context - Agent context including name and specialization
 * @returns Formatted role definition prompt segment
 * 
 * @example
 * ```typescript
 * const role = roleModule({ agentName: 'CMS Agent' });
 * // Output: "You are CMS Agent, an autonomous AI assistant..."
 * ```
 */
export function roleModule(context: RoleContext): string {
  return `You are ${context.agentName}, an autonomous AI assistant.`;
}
```

### 2. Module Validation

```typescript
interface ModuleValidator {
  validate(module: PromptModule, context: Context): ValidationResult;
}

class TokenLimitValidator implements ModuleValidator {
  constructor(private maxTokens: number) {}
  
  validate(module: PromptModule, context: Context): ValidationResult {
    const output = module(context);
    const tokenCount = estimateTokens(output);
    
    return {
      valid: tokenCount <= this.maxTokens,
      message: tokenCount > this.maxTokens 
        ? `Module exceeds token limit: ${tokenCount}/${this.maxTokens}`
        : 'OK'
    };
  }
}

// Use in composition
function buildValidatedPrompt(context: Context): string {
  const validators = [
    new TokenLimitValidator(1000),
    new RequiredFieldsValidator(['role', 'rules'])
  ];
  
  const modules = [roleModule, rulesModule, toolsModule];
  
  for (const module of modules) {
    for (const validator of validators) {
      const result = validator.validate(module, context);
      if (!result.valid) {
        throw new Error(`Module validation failed: ${result.message}`);
      }
    }
  }
  
  return modules.map(m => m(context)).join('\n\n');
}
```

### 3. Module Monitoring

```typescript
class ModuleMetrics {
  trackModuleUsage(moduleName: string, context: Context) {
    metrics.increment('prompt.module.used', {
      module: moduleName,
      environment: context.environment
    });
  }
  
  trackModulePerformance(moduleName: string, duration: number) {
    metrics.histogram('prompt.module.generation_time', duration, {
      module: moduleName
    });
  }
  
  trackModuleErrors(moduleName: string, error: Error) {
    metrics.increment('prompt.module.errors', {
      module: moduleName,
      error: error.message
    });
  }
}
```

## Key Takeaways

**What is Modular Prompt Architecture**:
- Treat prompts as composable, reusable components
- Break monolithic prompts into focused modules
- Enable versioning, testing, and maintenance at scale

**Why It Matters** (2024-2025):
- **Scalability**: From prototype to production
- **Maintainability**: Update one module without breaking others
- **Reusability**: Share modules across multiple agents
- **Testability**: Unit test individual components
- **Versioning**: Track changes per concern

**Modular Patterns**:
1. **Layer-Based**: Stack modules by responsibility
2. **Tag-Based**: Use semantic XML/HTML tags
3. **Function-Based**: Modules as functions returning strings
4. **Registry**: Central module library with composition

**Your Codebase**:
- Already modular in spirit (clear sections, variable injection)
- Uses Handlebars templating (`{{{workingMemory}}}`)
- Enhancement: Extract modules to separate files
- Benefit: Easier to version, test, and reuse

**Advanced Patterns**:
- **Conditional loading**: Load modules based on context
- **Versioning**: Track module versions with changelog
- **Inheritance**: Extend base modules for variants
- **Dynamic injection**: Add modules based on intent
- **Caching**: Cache compiled prompts for performance

**Production Best Practices**:
- Document each module (purpose, version, examples)
- Validate modules (token limits, required fields)
- Monitor usage (metrics, performance, errors)
- Test modules (unit tests, integration tests, A/B tests)
- Version control (semantic versioning, changelog)

**Implementation Guide**:
```typescript
// 1. Define modules
const modules = {
  role: (ctx) => `...`,
  rules: (ctx) => `...`,
  tools: (ctx) => `...`
};

// 2. Compose
function buildPrompt(ctx: Context): string {
  return Object.values(modules)
    .map(m => m(ctx))
    .filter(Boolean)
    .join('\n\n');
}

// 3. Use
const prompt = buildPrompt(context);
const response = await generateText({ prompt });
```

**Testing Strategy**:
- Unit test: Each module independently
- Integration test: Full composition
- A/B test: Module variants
- Monitor: Usage, performance, errors

## Practical Exercise

Build modular prompts for:

**Exercise 1**: Extract Your Modules
```typescript
// Take your current react.xml prompt
// Extract into separate modules:
// - roleModule
// - coreLoopModule
// - rulesModule
// - examplesModule
// - toolsModule
// - sessionInfoModule

// Implement buildReActPrompt() function
```

**Exercise 2**: Module Versioning
```typescript
// Create v2 of rulesModule with:
// - Additional safety checks
// - Error recovery procedures
// - Quality assurance steps

// Implement version selection
const prompt = buildPrompt({
  modules: [
    { name: 'rules', version: '2.0.0' }
  ]
});
```

**Exercise 3**: Module Testing
```typescript
// Write unit tests for:
// 1. Each module (verify output contains expected content)
// 2. Module composition (verify correct ordering)
// 3. Dynamic injection (verify context-based loading)
// 4. Token limits (verify modules stay within limits)
```

## Navigation

- [← Previous: 1.2.4 Output Format Specification](./1.2.4-output-format.md)
- [↑ Back to Knowledge Base TOC](../../AI_KNOWLEDGE_BASE_TOC.md)
- [→ Next: 1.3.1 Template Engines & Variable Injection](./1.3.1-template-engines.md)

---

*Part of Layer 1: Prompt Engineering - Scaling prompts from prototype to production*
