# 1.2.5 Modular Prompt Architecture

## TL;DR

Modular prompt architecture treats prompts as composable, reusable components rather than monolithic text—like building with LEGO bricks; this enables versioning, testing, and maintenance at scale, with 2025 best practices emphasizing function-based modules, registries for reusability, and separate files for each concern.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-03
- **Prerequisites**: [1.2.1 Role Definition](./1.2.1-role-definition.md) through [1.2.4 Output Format](./1.2.4-output-format.md)
- **Grounded In**: Microsoft Semantic Kernel, LangChain Prompt Templates, Production AI Engineering Practices

## Table of Contents

- [Overview](#overview)
- [The Problem: Monolithic Prompts](#the-problem-monolithic-prompts)
- [Core Concept](#core-concept)
- [Implementation Patterns](#implementation-patterns)
- [When to Use This Pattern](#when-to-use-this-pattern)
- [Production Best Practices](#production-best-practices)
- [Key Takeaways](#key-takeaways)
- [References](#references)

## Overview

**Modular prompt architecture** treats prompts as composable, reusable components rather than monolithic blocks of text. Like building with LEGO bricks, you create specialized modules that can be combined, swapped, and reused across different contexts.

**Key Insight** (2024-2025): Treat prompts as code—modular, versioned, tested, and composable.

**Key Research Findings** (2024-2025):

- **Maintainability**: Update one module without breaking others
- **Reusability**: Share modules across multiple agents
- **Testability**: Unit test individual components
- **Versioning**: Track changes per concern
- **Best practice**: Layer-based composition with 5-6 standard layers

**Date Verified**: 2025-12-03

## The Problem: Monolithic Prompts

### The Classic Challenge

Monolithic prompts become unmaintainable as they grow:

```xml
<!-- ❌ Monolithic: 500+ lines of mixed concerns -->
You are an AI assistant. You help with content management. You can create,
read, update, and delete pages. You must think before acting. You should
use tools efficiently. When creating pages, check if slug exists first.
When deleting, ask for confirmation. For searches, use fuzzy matching.
Always return JSON. Be concise but thorough. If you encounter errors,
explain them clearly. Use working memory for context. Remember the user's
previous requests...

[500 more lines of mixed concerns]
```

**Problems**:

- ❌ **Hard to update**: Change one thing, risk breaking others
- ❌ **Can't reuse**: Each agent needs separate prompt
- ❌ **Difficult to test**: No isolation of concerns
- ❌ **No version control**: Can't track what changed
- ❌ **Unmaintainable**: Grows into spaghetti text

### Why This Matters

As AI applications scale:
- Multiple agents need shared capabilities
- Teams need to collaborate on prompts
- Testing requires isolation
- Compliance requires audit trails
- Changes need safe rollback

## Core Concept

### The Modular Approach

```typescript
// ✅ Modular: Composable components
const systemPrompt = compose([
  roleModule,           // "You are an autonomous AI assistant"
  capabilitiesModule,   // List of available tools
  rulesModule,          // Safety and operational rules
  formatModule,         // Output format specification
  contextModule,        // Working memory injection
  examplesModule        // Few-shot demonstrations
]);
```

### Standard Layers

```
┌─────────────────────────────────────┐
│ Layer 1: Core Identity              │  (Role, persona)
├─────────────────────────────────────┤
│ Layer 2: Capabilities               │  (What you can do)
├─────────────────────────────────────┤
│ Layer 3: Rules & Constraints        │  (How you must behave)
├─────────────────────────────────────┤
│ Layer 4: Output Format              │  (Response structure)
├─────────────────────────────────────┤
│ Layer 5: Context                    │  (Dynamic data)
├─────────────────────────────────────┤
│ Layer 6: Examples                   │  (Few-shot demonstrations)
└─────────────────────────────────────┘
```

## Implementation Patterns

### Pattern 1: Function-Based Modules

**Use Case**: Maximum flexibility with TypeScript type safety

```typescript
// Module type definition
type PromptModule = (context: Context) => string;

// Define modules
const roleModule: PromptModule = (ctx) => `
You are ${ctx.agentName}, an autonomous AI assistant using the ReAct pattern.
`;

const toolsModule: PromptModule = (ctx) => `
**AVAILABLE TOOLS:** ${ctx.tools.length} tools

${ctx.tools.map(t => `- ${t.name}: ${t.description}`).join('\n')}
`;

const rulesModule: PromptModule = (ctx) => {
  const rules = [...ctx.coreRules];
  if (ctx.environment === 'production') {
    rules.push('- EXTRA VALIDATION: Double-check destructive operations');
  }
  return `**RULES:**\n${rules.join('\n')}`;
};

// Compose final prompt
function buildPrompt(ctx: Context): string {
  return [
    roleModule(ctx),
    toolsModule(ctx),
    rulesModule(ctx)
  ].filter(Boolean).join('\n\n');
}
```

**Pros**:

- ✅ Full TypeScript type safety
- ✅ Conditional logic within modules
- ✅ Easy to test each function

**Cons**:

- ❌ Prompts embedded in code
- ❌ Non-technical users can't edit

### Pattern 2: Tag-Based Structure

**Use Case**: Clear boundaries with semantic meaning

```xml
<role>
You are an autonomous AI assistant using the ReAct pattern.
</role>

<capabilities>
- Content management tools
- Search functionality
- Multi-step planning
</capabilities>

<rules priority="critical">
1. NEVER auto-confirm deletions
2. ALWAYS show reasoning
</rules>

<format>
Thought: [reasoning]
Action: [tool]
</format>

<context dynamic="true">
{{workingMemory}}
</context>
```

**Pros**:

- ✅ Self-documenting structure
- ✅ Easy to parse programmatically
- ✅ Clear boundaries

**Cons**:

- ❌ More verbose
- ❌ XML parsing overhead

### Pattern 3: Registry Pattern

**Use Case**: Reusable modules across multiple agents

```typescript
// Module registry
class PromptModuleRegistry {
  private modules = new Map<string, PromptModule>();

  register(name: string, module: PromptModule) {
    this.modules.set(name, module);
  }

  get(name: string): PromptModule | undefined {
    return this.modules.get(name);
  }

  compose(moduleNames: string[], context: Context): string {
    return moduleNames
      .map(name => this.get(name))
      .filter(Boolean)
      .map(module => module!(context))
      .join('\n\n');
  }
}

// Usage
const registry = new PromptModuleRegistry();

// Register reusable modules
registry.register('role:agent', roleAgentModule);
registry.register('role:assistant', roleAssistantModule);
registry.register('tools:cms', cmsToolsModule);
registry.register('rules:safety', safetyRulesModule);
registry.register('rules:quality', qualityRulesModule);

// Build different agent types
const cmsAgent = registry.compose([
  'role:agent',
  'tools:cms',
  'rules:safety',
  'rules:quality'
], context);

const readOnlyAgent = registry.compose([
  'role:assistant',
  'tools:cms',
  'rules:safety'
], context);
```

**Pros**:

- ✅ Maximum reusability
- ✅ Namespace organization
- ✅ Easy to swap modules

**Cons**:

- ❌ More infrastructure
- ❌ Module discovery complexity

### Pattern 4: File-Based Modules

**Use Case**: Version control and team collaboration

```
prompts/
├── modules/
│   ├── role-agent.md
│   ├── role-assistant.md
│   ├── tools-cms.md
│   ├── rules-safety.md
│   ├── rules-quality.md
│   ├── format-react.md
│   └── examples-cms.md
├── agents/
│   ├── cms-agent.yaml       # Compose: role-agent + tools-cms + rules-*
│   └── read-only-agent.yaml # Compose: role-assistant + tools-cms
└── registry.json            # Module metadata
```

**cms-agent.yaml**:

```yaml
name: cms-agent
version: 2.1.0
modules:
  - role-agent
  - tools-cms
  - rules-safety
  - rules-quality
  - format-react
  - examples-cms
variables:
  - workingMemory
  - sessionId
  - currentDate
```

**Loader**:

```typescript
class FileBasedPromptBuilder {
  async buildPrompt(agentName: string, context: Context): Promise<string> {
    const config = await this.loadConfig(`agents/${agentName}.yaml`);

    const modules = await Promise.all(
      config.modules.map(name => this.loadModule(`modules/${name}.md`))
    );

    const combined = modules.join('\n\n');
    return this.renderTemplate(combined, context);
  }
}
```

**Pros**:

- ✅ Git-friendly
- ✅ Non-technical users can edit markdown
- ✅ Clear file organization

**Cons**:

- ❌ File I/O overhead
- ❌ More complex build process

## When to Use This Pattern

### ✅ Use Modular Architecture When

1. **Multiple agents** - Share common modules
2. **Team collaboration** - Multiple people editing prompts
3. **Production systems** - Need versioning and rollback
4. **Complex prompts** - More than 200 lines
5. **Testing requirements** - Need isolated unit tests

### ❌ Use Simple Prompts When

1. **Prototyping** - Quick experiments
2. **Single agent** - One-off use case
3. **Simple prompts** - Under 50 lines
4. **Solo developer** - No collaboration needs

### Decision Matrix

| Your Situation | Recommended Approach |
|----------------|----------------------|
| Prototype | Inline string |
| Single production agent | Tag-based structure |
| Multiple agents | Registry pattern |
| Large team | File-based modules |

## Production Best Practices

### 1. Module Documentation

```typescript
/**
 * Role Module - Defines agent identity and expertise
 *
 * @version 2.0.0
 * @category Core
 * @stability stable
 *
 * @param context - Agent context including name and specialization
 * @returns Formatted role definition prompt segment
 *
 * @example
 * ```typescript
 * const role = roleModule({ agentName: 'CMS Agent' });
 * // Output: "You are CMS Agent, an autonomous AI assistant..."
 * ```
 */
export function roleModule(context: RoleContext): string {
  return `You are ${context.agentName}, an autonomous AI assistant.`;
}
```

### 2. Module Validation

```typescript
class TokenLimitValidator {
  constructor(private maxTokens: number) {}

  validate(module: PromptModule, context: Context): ValidationResult {
    const output = module(context);
    const tokenCount = estimateTokens(output);

    return {
      valid: tokenCount <= this.maxTokens,
      message: tokenCount > this.maxTokens
        ? `Module exceeds limit: ${tokenCount}/${this.maxTokens}`
        : 'OK'
    };
  }
}

// Use in composition
function buildValidatedPrompt(context: Context): string {
  const validator = new TokenLimitValidator(1000);
  const modules = [roleModule, rulesModule, toolsModule];

  for (const module of modules) {
    const result = validator.validate(module, context);
    if (!result.valid) {
      throw new Error(`Module validation failed: ${result.message}`);
    }
  }

  return modules.map(m => m(context)).join('\n\n');
}
```

### 3. Module Testing

```typescript
import { describe, test, expect } from 'vitest';

describe('roleModule', () => {
  test('should include agent name', () => {
    const output = roleModule({ agentName: 'TestAgent' });
    expect(output).toContain('TestAgent');
  });

  test('should mention ReAct pattern', () => {
    const output = roleModule({ agentName: 'TestAgent' });
    expect(output).toContain('ReAct');
  });
});

describe('rulesModule', () => {
  test('should include critical rules', () => {
    const output = rulesModule({});
    expect(output).toContain('THINK before acting');
    expect(output).toContain('NEVER auto-confirm');
  });

  test('should add production rules in prod environment', () => {
    const output = rulesModule({ environment: 'production' });
    expect(output).toContain('EXTRA VALIDATION');
  });
});
```

### Common Pitfalls

**❌ Over-modularization**:

Breaking every sentence into a module. Keep modules at logical boundaries.

**❌ Circular dependencies**:

Module A imports B, B imports A. Use composition, not inheritance.

**❌ Implicit ordering**:

Modules that depend on being in specific order but don't document it.

**❌ Stale modules**:

Modules that are never updated when requirements change.

## Key Takeaways

1. **Prompts are code** - Treat them with same rigor (versioning, testing, review)
2. **5-6 standard layers** - Role, capabilities, rules, format, context, examples
3. **Function-based modules** - Best for TypeScript type safety
4. **Registry pattern** - Best for multi-agent reuse
5. **Test each module** - Unit tests prevent regressions

**Quick Implementation Checklist**:

- [ ] Identify logical module boundaries
- [ ] Create module interface/type
- [ ] Implement core modules (role, rules, tools)
- [ ] Build composition function
- [ ] Add module validation
- [ ] Write unit tests
- [ ] Document each module

## References

1. **Microsoft** (2025). "Semantic Kernel Prompt Templates". https://learn.microsoft.com/en-us/semantic-kernel/concepts/prompts/
2. **LangChain** (2025). "Prompt Templates Documentation". https://python.langchain.com/docs/modules/model_io/prompts/
3. **PromptLayer** (2025). "Prompt Templates with Jinja2". https://blog.promptlayer.com/prompt-templates-with-jinja2-2/
4. **Anthropic** (2025). "Claude Prompt Engineering Guide". Anthropic Documentation.
5. **OpenAI** (2025). "Best Practices for Prompt Engineering". Platform Documentation.

**Related Topics**:

- [1.2.1 Role Definition](./1.2.1-role-definition.md)
- [1.3.1 Template Engines](./1.3.1-template-engines.md)
- [1.3.3 Versioning & Caching](./1.3.3-versioning-caching.md)

**Layer Index**: [Layer 1: Prompt Engineering](../AI_KNOWLEDGE_BASE_TOC.md#layer-1-prompt-engineering)
