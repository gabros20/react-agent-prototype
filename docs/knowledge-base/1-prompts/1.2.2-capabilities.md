# 1.2.2 Capabilities Declaration in System Prompts

## TL;DR

Capabilities declaration explicitly tells the AI what it CAN do—tools, knowledge domains, and resources—and crucially, what it CANNOT do; explicit capability statements prevent hallucination by 15-30% and improve tool selection accuracy, ensuring AI provides honest "I can't do that" responses instead of fabricating abilities.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-03
- **Prerequisites**: [1.2.1 Role Definition](./1.2.1-role-definition.md)
- **Grounded In**: Anthropic Claude Guidelines, OpenAI Function Calling Best Practices, LangChain Tool Documentation

## Table of Contents

- [Overview](#overview)
- [The Problem: Implicit Capabilities](#the-problem-implicit-capabilities)
- [Core Concept](#core-concept)
- [Implementation Patterns](#implementation-patterns)
- [When to Use This Pattern](#when-to-use-this-pattern)
- [Production Best Practices](#production-best-practices)
- [Key Takeaways](#key-takeaways)
- [References](#references)

## Overview

**Capabilities declaration** explicitly states what tools, knowledge, and abilities an AI agent has access to. It complements role definition (WHO the AI is) by defining WHAT the AI can do.

**Key Principle**: If the AI knows what it can do, it won't try to do what it can't.

**Key Research Findings** (2024-2025):

- **Hallucination reduction**: Explicit capability boundaries reduce false claims by 15-30%
- **Tool selection**: Clear tool inventories improve selection accuracy by 25-40%
- **User trust**: Honest "I can't do that" responses increase user satisfaction by 20%
- **Best practice**: Auto-generate capability sections from tool metadata

**Date Verified**: 2025-12-03

## The Problem: Implicit Capabilities

### The Classic Challenge

Without explicit capability declaration, AI hallucinates abilities it doesn't have:

```
User: "Send an email to john@example.com"

Without Declaration:
AI: "I'll send that email now..."
Result: ❌ Failure - AI has no email tool, hallucinates success

With Declaration:
System: "You have tools: cms_getPage, cms_createPage
        (You cannot send emails or access external APIs)"
AI: "I don't have email capabilities. I can help with content
     management tasks. Would you like me to do something else?"
Result: ✅ Honest response, user redirected appropriately
```

**Problems**:

- ❌ **Hallucinated abilities**: AI claims it can do things it can't
- ❌ **Poor tool selection**: AI doesn't know which tool to use
- ❌ **User confusion**: Expectations don't match reality
- ❌ **No graceful degradation**: AI fails silently instead of suggesting alternatives
- ❌ **Trust erosion**: Users lose confidence when AI over-promises

### Why This Matters

- Prevents AI from claiming false abilities
- Improves tool selection and planning
- Sets clear user expectations
- Enables graceful degradation with alternatives

## Core Concept

### What is Capabilities Declaration?

A capability declaration defines:

1. **Available Tools**: What operations the AI can perform
2. **Knowledge Domains**: What information the AI has access to
3. **Explicit Limitations**: What the AI cannot do
4. **Conditional Abilities**: Context-dependent capabilities

### Declaration Components

```
CAPABILITIES = {
  Tools (what you can execute)
  + Knowledge (what you know about)
  + Limitations (what you cannot do)
  + Prerequisites (dependencies between capabilities)
}
```

### Benefits

| Benefit | Without Declaration | With Declaration |
|---------|---------------------|------------------|
| Hallucination | High (15-30%) | Low (<5%) |
| Tool selection | Trial-and-error | Informed decision |
| User expectations | Misaligned | Clear |
| Error handling | Silent failure | Graceful degradation |

## Implementation Patterns

### Pattern 1: Tool Inventory

**Use Case**: Agents with multiple tools need clear inventory

**Simple List**:

```
You have access to these tools:
- cms_getPage: Retrieve page by ID or slug
- cms_createPage: Create new page with sections
- cms_deletePage: Delete a page (requires confirmation)
- cms_addSection: Add section to existing page
- cms_updateContent: Modify section content
```

**Structured with Categories**:

```
You have access to these content management tools:

Page Operations:
- cms_getPage(pageId): Get page metadata and content
- cms_createPage(name, slug): Create new page
- cms_deletePage(pageId): Delete page (destructive)

Section Operations:
- cms_addSection(pageId, sectionDefId): Add section to page
- cms_updateSection(sectionId, content): Update section content
- cms_deleteSection(sectionId): Remove section from page

Search Operations:
- cms_findResource(query, type): Fuzzy search for pages/sections
```

**With Usage Guidance**:

```
cms_getPage(slug):
- Purpose: Retrieve page information
- When to use: User asks about specific page
- Returns: Page metadata + section IDs
- Note: Use cms_getSectionContent() for actual section content

cms_getSectionContent(sectionId):
- Purpose: Get content from specific section
- When to use: Need section details after getting page
- Returns: Full section content with all fields
- Note: More efficient than including content in getPage
```

**Pros**:

- ✅ Clear inventory of available operations
- ✅ Prevents hallucinated tool calls
- ✅ Helps with tool selection

**Cons**:

- ❌ Must be kept in sync with actual tools
- ❌ Can get long with many tools

### Pattern 2: Knowledge Domains

**Use Case**: Define expertise areas and boundaries

```
Your knowledge includes:

Content Management:
- Creating, reading, updating, deleting pages
- Section definitions and schemas
- Content modeling best practices

Web Development:
- HTML, CSS, JavaScript fundamentals
- React patterns and best practices
- TypeScript type systems

You do NOT have access to:
- Real-time data (stock prices, weather, news)
- User authentication systems
- External APIs or databases
- File system access beyond the CMS
```

**Pros**:

- ✅ Sets clear knowledge boundaries
- ✅ Reduces hallucination in unknown domains
- ✅ Guides user expectations

**Cons**:

- ❌ Hard to enumerate all knowledge
- ❌ May be overly restrictive

### Pattern 3: Capability Matrix

**Use Case**: Quick reference for can/cannot

```
| Capability | Available | Details |
|------------|-----------|---------|
| Read pages | ✅ Yes | Via cms_getPage |
| Create pages | ✅ Yes | Via cms_createPage |
| Delete pages | ✅ Yes | Requires user confirmation |
| Send emails | ❌ No | Not available in this system |
| Access database | ❌ No | All data via CMS API only |
| Browse web | ❌ No | No external internet access |
```

**Pros**:

- ✅ Visual quick reference
- ✅ Easy to scan
- ✅ Clear binary decisions

**Cons**:

- ❌ Lacks nuance for conditional capabilities
- ❌ Takes more tokens

### Pattern 4: Auto-Generated Capabilities

**Use Case**: Keep capabilities in sync with actual tools

```typescript
// Generate capability declaration from tool registry
function generateCapabilitiesPrompt(tools: Record<string, ToolMetadata>): string {
  const byCategory = groupBy(Object.values(tools), t => t.category);

  let prompt = "**YOUR CAPABILITIES:**\n\n";

  for (const [category, categoryTools] of Object.entries(byCategory)) {
    prompt += `${capitalize(category)} Operations:\n`;

    for (const tool of categoryTools) {
      const conf = tool.requiresConfirmation ? ' (requires confirmation)' : '';
      prompt += `- ${tool.name}: ${tool.description}${conf}\n`;
    }
    prompt += '\n';
  }

  return prompt;
}

// Use in prompt building
const capabilities = generateCapabilitiesPrompt(TOOL_METADATA);
const systemPrompt = `
You are an autonomous AI assistant.

${capabilities}

**AVAILABLE TOOLS:** {{toolCount}} tools
{{toolsFormatted}}
`;
```

**Pros**:

- ✅ Always in sync with actual tools
- ✅ Single source of truth
- ✅ Reduces maintenance burden

**Cons**:

- ❌ Requires tool metadata structure
- ❌ Additional build step

## When to Use This Pattern

### ✅ Use Capabilities Declaration When

1. **Agent has tools** - Any function-calling or tool-using agent
2. **Domain-bounded** - AI should stay within specific scope
3. **User-facing** - Users need to know what's possible
4. **Multi-capability** - More than 3-4 distinct abilities
5. **Safety-critical** - Must not claim unavailable abilities

### ❌ Minimal Declaration When

1. **Simple chat** - No tools, just conversation
2. **Single-purpose** - One obvious capability
3. **Experimental** - Still discovering what works
4. **Token-constrained** - Need minimal prompt size

### Decision Matrix

| Your Situation | Recommended Approach |
|----------------|----------------------|
| Tool-using agent | Full tool inventory + limitations |
| Domain chatbot | Knowledge domains + boundaries |
| Multi-purpose assistant | Capability matrix |
| Production system | Auto-generated from tool registry |

## Production Best Practices

### 1. Explicit Limitations Are Critical

```
What you CANNOT do:

External Access:
- Cannot browse the internet or access external APIs
- Cannot send emails, SMS, or push notifications
- Cannot make HTTP requests to external services

System Access:
- Cannot access file system outside CMS
- Cannot execute shell commands
- Cannot modify database directly

User Data:
- Cannot access user authentication or passwords
- Cannot view audit logs or system logs
- Cannot impersonate users

If user requests any of these, explain the limitation and suggest alternatives.
```

### 2. Graceful Degradation Pattern

```
When you lack a capability:

1. Acknowledge honestly:
   "I don't have the ability to [requested action]."

2. Explain why:
   "This system doesn't have email integration configured."

3. Suggest alternatives:
   "I can help you:
   - Create a page with the email content you'd send
   - Generate the email text for you to copy
   - Add a contact form to your website"

4. Stay helpful:
   "What would you like me to do instead?"
```

### 3. Test Your Declaration

**The 3-Question Test**:

1. **Capability Inventory**: "What can you help me with?"
   - Good: Clear list of capabilities by category
   - Bad: "I can help with many things!" (vague)

2. **Boundary Recognition**: "Can you send an email to our subscribers?"
   - Good: "I don't have email capabilities. I'm focused on content management."
   - Bad: "Sure, I'll send that email!" (hallucination)

3. **Alternative Suggestion**: "Schedule this page to publish next Monday"
   - Good: "I can't schedule future publishes, but I can create it as draft..."
   - Bad: "Okay, scheduled!" (false claim)

### Common Pitfalls

**❌ Missing "Cannot Do" section**:

Only listing what AI can do invites hallucination about unlisted abilities.

**❌ Stale capability lists**:

Manual lists that don't match actual tools cause confusion.

**❌ Over-claiming**:

```
"I can help with anything related to your website!"
```

Better: "I can help with content management: pages, sections, and collections."

**❌ No graceful degradation**:

AI says "I can't do that" without suggesting alternatives.

## Key Takeaways

1. **Explicit > Implicit** - Declare what AI can AND cannot do
2. **Auto-generate when possible** - Keep capabilities in sync with tools
3. **Include limitations** - Critical for preventing hallucination
4. **Provide alternatives** - Graceful degradation improves UX
5. **Test boundaries** - Verify AI respects its limitations

**Quick Implementation Checklist**:

- [ ] List all available tools with descriptions
- [ ] Group tools by category (pages, sections, search, etc.)
- [ ] Explicitly state what AI cannot do
- [ ] Implement graceful degradation pattern
- [ ] Auto-generate from tool metadata if possible
- [ ] Test with boundary questions

## References

1. **Anthropic** (2025). "Claude Tool Use Best Practices". Anthropic Documentation.
2. **OpenAI** (2025). "Function Calling Guide". Platform Documentation.
3. **LangChain** (2025). "Tool Documentation Patterns". LangChain Docs.
4. **Portkey** (2025). "Prompt Security and Guardrails". https://portkey.ai/blog/prompt-security-and-guardrails/
5. **Datadog** (2025). "LLM Guardrails Best Practices". https://www.datadoghq.com/blog/llm-guardrails-best-practices/

**Related Topics**:

- [1.2.1 Role Definition](./1.2.1-role-definition.md)
- [1.2.3 Rules & Constraints](./1.2.3-rules-constraints.md)
- [3.1.3 Tool Design Patterns](../3-agents/3.1.3-tool-design.md)

**Layer Index**: [Layer 1: Prompt Engineering](../AI_KNOWLEDGE_BASE_TOC.md#layer-1-prompt-engineering)
