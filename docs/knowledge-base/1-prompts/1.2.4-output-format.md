# 1.2.4 Output Format Specification in System Prompts

## TL;DR

Output format specification tells the AI HOW to structure responses—as JSON, markdown, tables, or custom formats; the 2024-2025 evolution from "respond in JSON" (unreliable) to JSON Schema validation (guaranteed structure) makes LLM outputs predictable, parseable, and production-ready with 100% schema compliance.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-03
- **Prerequisites**: [1.2.1 Role Definition](./1.2.1-role-definition.md), [1.2.2 Capabilities](./1.2.2-capabilities.md), [1.2.3 Rules & Constraints](./1.2.3-rules-constraints.md)
- **Grounded In**: OpenAI Structured Outputs, Anthropic Claude Tool Use, Vercel AI SDK v6, Zod Schema Validation

## Table of Contents

- [Overview](#overview)
- [The Problem: Unpredictable Outputs](#the-problem-unpredictable-outputs)
- [Core Concept](#core-concept)
- [Implementation Patterns](#implementation-patterns)
- [When to Use This Pattern](#when-to-use-this-pattern)
- [Production Best Practices](#production-best-practices)
- [Key Takeaways](#key-takeaways)
- [References](#references)

## Overview

**Output format specification** defines HOW the AI structures its responses—from simple text to validated JSON schemas. Clear format specs make outputs predictable, parseable, and production-ready.

**Key Evolution** (2022-2025):

| Era | Approach | Reliability |
|-----|----------|-------------|
| 2022-2023 | "Respond in JSON" | ~70% valid JSON |
| 2024 | JSON Mode (`response_format: json`) | 100% valid JSON, no schema |
| 2025 | JSON Schema (`structuredOutputs: true`) | 100% valid JSON + exact schema |

**Key Research Findings** (2024-2025):

- **Structured outputs guarantee schema compliance** - No more parsing errors
- **Zod integration** - TypeScript type safety from prompt to response
- **Native support** - GPT-4o, Claude 3.5, Gemini 2.0 all support schema validation
- **Best practice**: Define schemas with Zod, use `generateObject()` for reliable extraction

**Date Verified**: 2025-12-03

## The Problem: Unpredictable Outputs

### The Classic Challenge

Without format specification, LLM outputs are unpredictable:

```
User: "Extract product info from this description"

Without Format Spec:
AI: "Sure! The product is a MacBook Pro with M3 chip, it costs $2999,
     and comes in Space Gray color with 36GB RAM."
Result: ❌ Free-form text, can't extract fields reliably

With Format Spec (JSON Schema):
System: "Return JSON with keys: name, price, specs, color"
AI: {"name": "MacBook Pro", "price": 2999, "specs": {"chip": "M3",
     "ram": "36GB"}, "color": "Space Gray"}
Result: ✅ Structured, easy to parse and validate
```

**Problems**:

- ❌ **Unparseable responses**: Free-form text can't be programmatically processed
- ❌ **Type errors**: "price" might be string or number randomly
- ❌ **Missing fields**: AI might omit required data
- ❌ **Extra content**: Explanations mixed with data
- ❌ **Inconsistent structure**: Different format every time

### Why This Matters

- Production systems need predictable data structures
- Type mismatches break downstream systems
- Parsing errors require expensive retry logic
- Inconsistent output kills automation

## Core Concept

### Format Types

**1. JSON (Most Common)**

```typescript
const ProductSchema = z.object({
  name: z.string(),
  price: z.number().positive(),
  specs: z.object({
    color: z.string(),
    size: z.enum(["S", "M", "L", "XL"]),
    features: z.array(z.string())
  }),
  inStock: z.boolean()
});
```

**2. Markdown (Human-Readable)**

```
Format your response as markdown:
- Use ## for section headers
- Use ` for inline code
- Use ``` for code blocks
- Use **bold** for emphasis
```

**3. Tables (Comparisons)**

```
Format as markdown table with columns: Feature, Model A, Model B

| Feature | Model A | Model B |
|---------|---------|---------|
| Cost    | $100    | $50     |
| Speed   | Fast    | Slow    |
```

**4. Custom Formats (Domain-Specific)**

```
Thought: [reasoning]
Action: [tool_name]
Action Input: [parameters as JSON]
Observation: [result]
```

## Implementation Patterns

### Pattern 1: Zod Schema with AI SDK v6

**Use Case**: Type-safe JSON extraction in TypeScript

```typescript
import { z } from 'zod';
import { generateObject } from 'ai';
import { openai } from '@ai-sdk/openai';

// Define schema with Zod
const ProductSchema = z.object({
  name: z.string().describe('Product name'),
  price: z.number().positive().describe('Price in USD'),
  specs: z.object({
    color: z.string(),
    size: z.enum(['S', 'M', 'L', 'XL']),
    features: z.array(z.string())
  }),
  inStock: z.boolean()
});

// Generate with guaranteed structure
const result = await generateObject({
  model: openai('gpt-4o-mini', { structuredOutputs: true }),
  schema: ProductSchema,
  prompt: `Extract product info from: "${description}"`
});

// result.object is typed as z.infer<typeof ProductSchema>
console.log(result.object.price); // TypeScript knows this is number
```

**Pros**:

- ✅ 100% schema compliance guaranteed
- ✅ Full TypeScript type safety
- ✅ Validation at generation time

**Cons**:

- ❌ Requires AI SDK v6+
- ❌ Schema must fit model context

### Pattern 2: Prefix Markers (ReAct Format)

**Use Case**: Agent reasoning traces with parseable structure

```
**RESPONSE FORMAT:**

ALL responses MUST follow this structure:

Thought: [Your reasoning about what to do next]
Action: [Tool name to execute]
Action Input: [Tool parameters as JSON]
Observation: [Result from tool execution]

When task is complete:
FINAL_ANSWER: [User-facing response]

Example:
Thought: I need to find the about page first
Action: cms_findResource
Action Input: {"query": "about", "type": "page"}
Observation: Found page-123
FINAL_ANSWER: Located the About page successfully.
```

**Parsing**:

```typescript
function parseReActResponse(text: string) {
  const thoughtMatch = text.match(/Thought:\s*(.+)/);
  const actionMatch = text.match(/Action:\s*(.+)/);
  const actionInputMatch = text.match(/Action Input:\s*({.+})/s);
  const finalMatch = text.match(/FINAL_ANSWER:\s*(.+)/s);

  return {
    thought: thoughtMatch?.[1]?.trim(),
    action: actionMatch?.[1]?.trim(),
    actionInput: actionInputMatch?.[1] ? JSON.parse(actionInputMatch[1]) : null,
    finalAnswer: finalMatch?.[1]?.trim()
  };
}
```

**Pros**:

- ✅ Human-readable reasoning
- ✅ Works with any model
- ✅ Good for debugging

**Cons**:

- ❌ Requires regex parsing
- ❌ Can fail on edge cases

### Pattern 3: Section Templates

**Use Case**: Structured responses for reports/analysis

```
Structure your response in these sections:

## Summary
[1-2 sentence overview]

## Analysis
[Detailed findings with bullet points]

## Recommendations
1. [First action]
2. [Second action]

## Code Example
```language
[Example code if relevant]
```
```

**Pros**:

- ✅ Consistent structure
- ✅ Easy to navigate
- ✅ Human-readable

**Cons**:

- ❌ Less machine-parseable
- ❌ Variable section lengths

### Pattern 4: Enum Constraints

**Use Case**: Classification with controlled vocabulary

```typescript
const ClassificationSchema = z.object({
  category: z.enum(['bug', 'feature', 'question', 'documentation']),
  priority: z.enum(['low', 'medium', 'high', 'critical']),
  confidence: z.number().min(0).max(1)
});

const result = await generateObject({
  model: openai('gpt-4o-mini', { structuredOutputs: true }),
  schema: ClassificationSchema,
  prompt: `Classify this issue: "${issueText}"`
});

// result.object.category is typed as 'bug' | 'feature' | 'question' | 'documentation'
```

**Pros**:

- ✅ Controlled vocabulary
- ✅ Type-safe enums
- ✅ No unexpected values

**Cons**:

- ❌ Limited flexibility
- ❌ Must enumerate all options

## When to Use This Pattern

### ✅ Use Structured Outputs When

1. **Data extraction** - Parsing documents, forms, receipts
2. **Classification** - Categorizing content with fixed labels
3. **API integration** - Downstream systems need exact schema
4. **Automation** - No human review of output
5. **High volume** - Can't manually fix parsing errors

### ✅ Use Text Format When

1. **Explanations** - Human-readable content
2. **Creative tasks** - Writing, brainstorming
3. **Conversations** - Natural dialogue
4. **Debugging** - Need to see reasoning

### Decision Matrix

| Your Situation | Recommended Format |
|----------------|-------------------|
| Data extraction pipeline | JSON Schema (Zod) |
| Agent reasoning traces | Prefix markers (ReAct) |
| Documentation generation | Markdown with sections |
| Feature comparison | Markdown tables |
| Classification tasks | Enum-constrained JSON |

## Production Best Practices

### 1. Always Use Schema Validation

```typescript
// ❌ Don't trust unvalidated JSON
const response = await generateText({ prompt });
const data = JSON.parse(response.text); // Might fail!

// ✅ Use schema validation
const result = await generateObject({
  model: openai('gpt-4o-mini', { structuredOutputs: true }),
  schema: MySchema,
  prompt
});
// result.object is guaranteed valid
```

### 2. Include Field Descriptions

```typescript
const Schema = z.object({
  title: z.string().describe('Page title, max 60 characters'),
  slug: z.string().describe('URL-safe identifier, lowercase with hyphens'),
  status: z.enum(['draft', 'published']).describe('Publication status')
});
```

**Why**: Descriptions guide the model to produce better values.

### 3. Handle Optional Fields

```typescript
const Schema = z.object({
  required_field: z.string(),
  optional_field: z.string().optional(),
  nullable_field: z.string().nullable(),
  default_field: z.string().default('default value')
});
```

### 4. Test Format Compliance

```typescript
describe('Output Format', () => {
  test('should generate valid schema', async () => {
    const result = await generateObject({
      schema: ProductSchema,
      prompt: 'Extract: MacBook Pro M3, $2999, Space Gray'
    });

    expect(result.object.name).toBe('MacBook Pro M3');
    expect(typeof result.object.price).toBe('number');
    expect(result.object.price).toBe(2999);
  });

  test('should handle missing optional fields', async () => {
    const result = await generateObject({
      schema: ProductSchema,
      prompt: 'Extract: Generic laptop' // No price
    });

    expect(result.object.name).toBeDefined();
    expect(result.object.price).toBeNull(); // Optional
  });
});
```

### Common Pitfalls

**❌ Vague format instructions**:

```
"respond in JSON format"
```

Better: Provide exact schema with Zod.

**❌ No validation**:

Assuming JSON is valid without parsing/validating.

**❌ Over-complex schemas**:

50-field schemas for simple tasks increase error rates.

**❌ Missing fallback**:

No handling for schema violations.

## Key Takeaways

1. **2025 standard: JSON Schema** - Use `generateObject()` with Zod for guaranteed structure
2. **Format matches use case** - JSON for data, markdown for humans, prefix markers for agents
3. **Always validate** - Never trust unvalidated LLM output
4. **Describe fields** - Help the model with `.describe()`
5. **Test compliance** - Verify format in automated tests

**Quick Implementation Checklist**:

- [ ] Define schema with Zod
- [ ] Add field descriptions
- [ ] Use `generateObject()` for extraction
- [ ] Handle optional/nullable fields
- [ ] Test with edge cases
- [ ] Implement fallback for errors

## References

1. **OpenAI** (2025). "Structured Outputs Guide". https://platform.openai.com/docs/guides/structured-outputs
2. **Vercel** (2025). "AI SDK v6: generateObject". https://sdk.vercel.ai/docs/ai-sdk-core/generating-structured-data
3. **Anthropic** (2025). "Claude Tool Use and Structured Output". Anthropic Documentation.
4. **Zod** (2025). "TypeScript-first Schema Validation". https://zod.dev/
5. **Guardrails AI** (2025). "Schema Validation at Runtime". https://www.guardrailsai.com/docs

**Related Topics**:

- [1.2.1 Role Definition](./1.2.1-role-definition.md)
- [1.2.3 Rules & Constraints](./1.2.3-rules-constraints.md)
- [1.2.5 Modular Prompt Architecture](./1.2.5-modular-architecture.md)

**Layer Index**: [Layer 1: Prompt Engineering](../AI_KNOWLEDGE_BASE_TOC.md#layer-1-prompt-engineering)
