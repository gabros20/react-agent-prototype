# 5.3.3 BM25 Keyword Search

## TL;DR

BM25 is a probabilistic ranking function that scores documents based on query term frequency with saturation and length normalization—remaining a strong baseline for RAG with 76-85% recall, especially for exact term matching and domain-specific vocabulary.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-12
- **Prerequisites**: [5.3.1 Vector Search](./5.3.1-vector-search.md)
- **Grounded In**: BM25S Research (2024), OpenSearch Documentation, LlamaIndex Implementation

## Table of Contents

- [Overview](#overview)
- [The Problem](#the-problem-vector-search-limitations)
- [Core Concept](#core-concept)
- [Implementation Patterns](#implementation-patterns)
- [Research & Benchmarks](#research--benchmarks)
- [When to Use This Pattern](#when-to-use-this-pattern)
- [Production Best Practices](#production-best-practices)
- [Key Takeaways](#key-takeaways)
- [References](#references)

## Overview

BM25 (Best Matching 25) is a probabilistic information retrieval algorithm that extends TF-IDF with term frequency saturation and document length normalization. Despite the dominance of vector search, BM25 remains essential for exact term matching, technical vocabulary, and as a component of hybrid search systems.

The algorithm excels where vector search struggles: specific keywords, domain terminology, and cases where exact matching is more appropriate than semantic similarity.

**Key Research Findings** (2024-2025):

- **BM25S**: Achieves up to 500x speedup over traditional implementations via eager sparse scoring
- **Hybrid Advantage**: BM25 + Vector improves Recall@10 from 76.1% to 83.3%
- **Strong Baseline**: Studies show BM25 achieves lower perplexity than some neural retrievers on certain tasks

**Date Verified**: 2025-12-12

## The Problem: Vector Search Limitations

### The Classic Challenge

Vector search can miss exact keyword matches that are critically important:

```
Document: "The PostgreSQL database uses MVCC for concurrency control."

Query 1: "PostgreSQL MVCC"
Vector Search: May return MySQL docs (semantically similar)
BM25: ✅ Exact match on "PostgreSQL" and "MVCC"

Query 2: "Error code E-5021"
Vector Search: ❌ Embeddings don't capture specific codes
BM25: ✅ Exact string matching
```

**Vector Search Limitations**:

- ❌ Exact terms diluted in embedding space
- ❌ Rare technical terms poorly represented
- ❌ Codes, IDs, acronyms lose specificity
- ❌ Synonyms retrieved when exact match needed

### Why BM25 Still Matters

Use cases where BM25 excels:

- **Technical documentation**: "kubectl apply -f deployment.yaml"
- **Error messages**: Specific error codes and messages
- **Product names**: Exact brand/model matching
- **API references**: Method names, parameters

## Core Concept

### What is BM25?

BM25 scores documents based on three factors:

```
BM25 Score = Σ IDF(term) × TF_saturated(term, doc) × length_norm(doc)
              for each query term

Where:
- IDF: Rare terms get higher weight
- TF_saturated: Term frequency with diminishing returns
- length_norm: Longer docs penalized to avoid bias
```

### The BM25 Formula

```
                    (k1 + 1) × tf
score(D, Q) = Σ IDF(qi) × ─────────────────────────────────
              i           tf + k1 × (1 - b + b × |D|/avgdl)

Parameters:
- k1: Term frequency saturation (typically 1.2-2.0)
- b: Length normalization (typically 0.75)
- tf: Term frequency in document
- |D|: Document length
- avgdl: Average document length in corpus
```

### Visual Explanation

```
Term Frequency Saturation (k1 effect):
Score
  │     ┌─────────────── tf without saturation
  │    /
  │   /   ╭────────────── tf with saturation (k1=1.2)
  │  /  ╭─╯
  │ / ╭─╯
  │/╭─╯
  └──────────────────── Term Frequency
   1  2  3  4  5  6...

Key insight: Going from tf=1 to tf=2 matters more than tf=5 to tf=6
```

### Key Principles

1. **Saturation**: Repeated terms have diminishing returns (prevents keyword stuffing)
2. **Length Normalization**: Longer documents don't automatically score higher
3. **IDF Weighting**: Rare terms are more discriminative

## Implementation Patterns

### Pattern 1: BM25 with LlamaIndex

**Use Case**: Standard BM25 retrieval in RAG pipeline

```typescript
import { BM25Retriever } from 'llamaindex';

interface BM25Config {
  k1: number;  // Term frequency saturation (default: 1.2)
  b: number;   // Length normalization (default: 0.75)
  topK: number;
}

async function createBM25Retriever(
  documents: Document[],
  config: BM25Config = { k1: 1.2, b: 0.75, topK: 5 }
): Promise<BM25Retriever> {
  // Index documents
  const retriever = new BM25Retriever({
    documents,
    similarity_top_k: config.topK,
    // BM25 parameters
    k1: config.k1,
    b: config.b,
  });

  return retriever;
}

async function bm25Search(
  retriever: BM25Retriever,
  query: string
): Promise<SearchResult[]> {
  const results = await retriever.retrieve(query);

  return results.map((node) => ({
    id: node.node.id_,
    content: node.node.getContent(),
    score: node.score,
  }));
}
```

### Pattern 2: Pure TypeScript BM25

**Use Case**: Custom implementation for understanding or edge cases

```typescript
interface BM25Index {
  documents: string[];
  termFreqs: Map<string, Map<number, number>>; // term → docId → freq
  docLengths: number[];
  avgDocLength: number;
  idf: Map<string, number>;
}

function buildBM25Index(documents: string[]): BM25Index {
  const termFreqs = new Map<string, Map<number, number>>();
  const docLengths: number[] = [];
  let totalLength = 0;

  // Calculate term frequencies
  documents.forEach((doc, docId) => {
    const tokens = tokenize(doc);
    docLengths[docId] = tokens.length;
    totalLength += tokens.length;

    const termCounts = new Map<string, number>();
    for (const token of tokens) {
      termCounts.set(token, (termCounts.get(token) || 0) + 1);
    }

    for (const [term, count] of termCounts) {
      if (!termFreqs.has(term)) {
        termFreqs.set(term, new Map());
      }
      termFreqs.get(term)!.set(docId, count);
    }
  });

  // Calculate IDF for each term
  const N = documents.length;
  const idf = new Map<string, number>();
  for (const [term, docs] of termFreqs) {
    const df = docs.size;
    idf.set(term, Math.log((N - df + 0.5) / (df + 0.5) + 1));
  }

  return {
    documents,
    termFreqs,
    docLengths,
    avgDocLength: totalLength / documents.length,
    idf,
  };
}

function bm25Score(
  index: BM25Index,
  query: string,
  docId: number,
  k1: number = 1.2,
  b: number = 0.75
): number {
  const queryTerms = tokenize(query);
  const docLength = index.docLengths[docId];
  let score = 0;

  for (const term of queryTerms) {
    const idf = index.idf.get(term) || 0;
    const tf = index.termFreqs.get(term)?.get(docId) || 0;

    const numerator = tf * (k1 + 1);
    const denominator = tf + k1 * (1 - b + b * (docLength / index.avgDocLength));

    score += idf * (numerator / denominator);
  }

  return score;
}

function bm25Search(
  index: BM25Index,
  query: string,
  topK: number = 5
): Array<{ docId: number; score: number }> {
  const scores = index.documents.map((_, docId) =>
    ({ docId, score: bm25Score(index, query, docId) })
  );

  return scores
    .filter((r) => r.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, topK);
}
```

### Pattern 3: Elasticsearch BM25

**Use Case**: Production-grade BM25 with Elasticsearch

```typescript
async function elasticsearchBM25Search(
  client: ElasticsearchClient,
  query: string,
  options: { topK: number; index: string }
): Promise<SearchResult[]> {
  const response = await client.search({
    index: options.index,
    body: {
      size: options.topK,
      query: {
        match: {
          content: {
            query,
            operator: 'or',
            // BM25 is default in Elasticsearch
          },
        },
      },
      // Customize BM25 parameters in index settings
    },
  });

  return response.hits.hits.map((hit) => ({
    id: hit._id,
    content: hit._source.content,
    score: hit._score,
  }));
}

// Index settings to customize BM25
const indexSettings = {
  settings: {
    index: {
      similarity: {
        custom_bm25: {
          type: 'BM25',
          k1: 1.2,
          b: 0.75,
        },
      },
    },
  },
  mappings: {
    properties: {
      content: {
        type: 'text',
        similarity: 'custom_bm25',
      },
    },
  },
};
```

### Pattern 4: BM25 + Vector Hybrid

**Use Case**: Combining BM25 precision with vector semantics

```typescript
async function hybridBM25VectorSearch(
  query: string,
  options: {
    topK: number;
    bm25Weight: number;
    vectorWeight: number;
  }
): Promise<SearchResult[]> {
  // Run both searches in parallel
  const [bm25Results, vectorResults] = await Promise.all([
    bm25Search(query, { topK: options.topK * 2 }),
    vectorSearch(query, { topK: options.topK * 2 }),
  ]);

  // Normalize scores to [0, 1]
  const maxBM25 = Math.max(...bm25Results.map((r) => r.score));
  const maxVector = Math.max(...vectorResults.map((r) => r.score));

  const normalizedBM25 = bm25Results.map((r) => ({
    ...r,
    normalizedScore: r.score / maxBM25,
  }));

  const normalizedVector = vectorResults.map((r) => ({
    ...r,
    normalizedScore: r.score / maxVector,
  }));

  // Combine scores
  const combined = new Map<string, number>();

  for (const r of normalizedBM25) {
    combined.set(r.id, (combined.get(r.id) || 0) + r.normalizedScore * options.bm25Weight);
  }
  for (const r of normalizedVector) {
    combined.set(r.id, (combined.get(r.id) || 0) + r.normalizedScore * options.vectorWeight);
  }

  // Sort and return top-K
  return Array.from(combined.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, options.topK)
    .map(([id, score]) => ({ id, combinedScore: score }));
}
```

## Research & Benchmarks

### BM25 vs Vector Search

| Metric | BM25 | Vector | Hybrid |
|--------|------|--------|--------|
| **Recall@10** | 76.1% | 78.5% | **83.3%** |
| **MAP@10** | 62.4% | 65.2% | **70.2%** |
| **Latency** | 5-20ms | 10-50ms | 30-80ms |
| **Exact Match** | ✅ Excellent | ⚠️ May miss | ✅ Good |

### BM25S Performance (2024)

BM25S achieves up to **500x speedup** over traditional implementations:

| Implementation | Index Time (100K docs) | Query Time |
|----------------|------------------------|------------|
| rank_bm25 | 12.3s | 45ms |
| **BM25S** | **0.8s** | **0.1ms** |
| Elasticsearch | 8.5s | 5ms |

### Parameter Sensitivity

| k1 Value | Effect |
|----------|--------|
| 0.5-1.0 | Aggressive saturation, favors rare terms |
| **1.2** | **Default, balanced** |
| 1.5-2.0 | Higher weight for repeated terms |

| b Value | Effect |
|---------|--------|
| 0.0 | No length normalization |
| **0.75** | **Default, moderate normalization** |
| 1.0 | Full length normalization |

## When to Use This Pattern

### ✅ Use When:

1. **Exact Term Matching**
   - Technical terminology
   - Product names, codes, IDs

2. **Keyword-Heavy Queries**
   - Error messages, log searches
   - API documentation

3. **Baseline Comparison**
   - Always test vector search against BM25
   - Often surprised by BM25 performance

4. **Hybrid Systems**
   - Combine with vector for best results
   - BM25 catches what vectors miss

### ❌ Don't Use When:

1. **Semantic Queries**
   - "Find similar concepts"
   - Synonyms, paraphrases important

2. **Short Queries**
   - Single-word queries can be ambiguous
   - Vector search provides better disambiguation

3. **Cross-Lingual**
   - BM25 can't match across languages
   - Need vector embeddings

### Decision Matrix

| Query Type | BM25 | Vector | Recommendation |
|------------|------|--------|----------------|
| Exact keyword | ✅ | ⚠️ | BM25 or Hybrid |
| Concept search | ⚠️ | ✅ | Vector or Hybrid |
| Error codes | ✅ | ❌ | BM25 |
| Natural language | ⚠️ | ✅ | Vector or Hybrid |
| Technical docs | ✅ | ✅ | Hybrid |

## Production Best Practices

### 1. Use Default Parameters Initially

k1=1.2, b=0.75 work well for most cases:

```typescript
const DEFAULT_BM25_CONFIG = {
  k1: 1.2,
  b: 0.75,
};
```

### 2. Tokenization Matters

Proper tokenization significantly impacts BM25:

```typescript
function tokenize(text: string): string[] {
  return text
    .toLowerCase()
    .replace(/[^\w\s]/g, ' ')  // Remove punctuation
    .split(/\s+/)               // Split on whitespace
    .filter((t) => t.length > 1) // Remove single chars
    .filter((t) => !STOP_WORDS.has(t)); // Remove stop words
}
```

### 3. Combine with Vector Search

Hybrid search is almost always better:

```typescript
const HYBRID_CONFIG = {
  bm25Weight: 0.3,    // Keyword matching
  vectorWeight: 0.7,  // Semantic similarity
};
```

### 4. Consider Document Length

Adjust `b` parameter for your corpus:

```typescript
// For uniform length documents (code, logs)
{ b: 0.5 }

// For variable length documents (articles, docs)
{ b: 0.75 }

// For very long documents
{ b: 0.9 }
```

## Key Takeaways

1. **Still Relevant**: BM25 remains a strong baseline, often competitive with neural retrievers
2. **Exact Matching**: Excels where vector search struggles (codes, terms, IDs)
3. **Hybrid Wins**: BM25 + Vector improves recall by 5-10% over either alone
4. **Fast**: Sub-millisecond queries with proper implementation (BM25S)
5. **Default Parameters**: k1=1.2, b=0.75 work for most use cases

**Quick Implementation Checklist**:

- [ ] Implement BM25 with proper tokenization
- [ ] Use default k1=1.2, b=0.75 initially
- [ ] Test against your vector search baseline
- [ ] Consider hybrid approach for production
- [ ] Monitor which queries BM25 handles better

## References

1. **ResearchGate** (2024). "BM25S: Orders of Magnitude Faster Lexical Search". https://www.researchgate.net/publication/382065948_BM25S
2. **LlamaIndex** (2024). "BM25 Retriever Documentation". https://docs.llamaindex.ai/en/stable/examples/retrievers/bm25_retriever/
3. **Pinecone** (2024). "Introducing Cascading Retrieval: Unifying Dense and Sparse". https://www.pinecone.io/blog/cascading-retrieval/
4. **Zilliz** (2024). "Mastering BM25: Deep Dive into the Algorithm". https://zilliz.com/learn/mastering-bm25
5. **AI Bites** (2024). "TF-IDF and BM25 for RAG—A Complete Guide". https://www.ai-bites.net/tf-idf-and-bm25-for-rag

**Related Topics**:

- [5.3.1 Vector Search](./5.3.1-vector-search.md)
- [5.3.4 Reranking](./5.3.4-reranking.md)
- [5.3.5 Fusion Strategies](./5.3.5-fusion.md)

**Layer Index**: [Layer 5: RAG & Retrieval](../AI_KNOWLEDGE_BASE_TOC.md#layer-5-retrieval--rag)
