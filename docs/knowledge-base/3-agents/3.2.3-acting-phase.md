# 3.2.3 - Acting Phase

## TL;DR
The acting phase executes the tool selected during reasoning, handling tool calls, parameter passing, error capturing, and result integration. Single action per iteration prevents parsing errors and hallucination—a core principle that improves reliability by 15-25% (2024 studies).

**Prerequisites**: [3.2.2 Reasoning Phase]
**Key Research**: Single vs Parallel Actions (Yao et al., 2022), Error Recovery (PALADIN, 2024)

---

## What is Acting?

Acting is the **execution phase** where agent calls a tool.

### Simple Flow

```
Reasoning: "I need to find the about page"
              ↓
        [Select Tool]
        cms_findResource
              ↓
         [Set Parameters]
        {"query": "about", "resourceType": "page"}
              ↓
        [Execute]
        Tool runs, returns result
              ↓
       [Capture Result]
       {id: "page-456", slug: "about-us"}
```

---

## Single vs Multiple Actions

### Pattern 1: Single Action Per Iteration (Recommended)

**Your Approach**: Execute ONE tool per thought-action cycle.

```
Thought: I need page ID for about
Action: cms_findResource
Input: {"query": "about"}
Result: page-456

Thought: Now get page details
Action: cms_getPage
Input: {"id": "page-456"}
Result: [page data]

Thought: Add hero section
Action: cms_addSection
Input: {"pageId": "page-456", "section": "hero"}
```

**Benefits**:
- ✅ **Parsing reliability**: Easy to extract action from response
- ✅ **Error handling**: Clear which tool failed
- ✅ **Traceability**: Each step is atomic
- ✅ **Debugging**: Simple to identify problems

**Trade-off**: More LLM calls (but offset by planning)

**Research**: 2024 studies show single-action = 15-25% higher accuracy

### Pattern 2: Parallel Actions (Advanced)

**Less common but supported**: Execute independent tools simultaneously.

```
Thought: I need both page content AND section templates
Actions: [
  cms_getPage(id: "page-456"),
  cms_listSectionTemplates()
]
```

**Benefits**:
- ✅ Faster for independent operations
- ✅ Reduced total latency

**Drawbacks**:
- ❌ Complex parsing
- ❌ Harder error handling
- ❌ Model hallucination risk

**Your system**: Sequential (better reliability for CMS).

---

## Action Structure

### Your Implementation Format

```xml
Action: [tool_name]
Action Input: {json_params}
```

### Example

```xml
Thought: User wants to add hero section to about page.
  I have page-456 (about page). Now need hero section definition.

Action: cms_findResource
Action Input: {
  "query": "hero",
  "resourceType": "section_definition"
}
```

### What Makes Good Action Specification

| Element | Good | Bad | Why |
|---------|------|-----|-----|
| **Tool name** | `cms_findResource` | `find` | Specific, namespaced |
| **Parameters** | `{"query": "about"}` | `{"name": "about"}` | Matches schema |
| **Format** | Valid JSON | Unquoted keys | Parseable |
| **Specificity** | Actual values | Variables | No interpretation needed |

---

## Tool Execution Process

### Step-by-Step Execution

```
┌──────────────────┐
│ Parse Action     │ Extract tool name + input from response
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│ Validate Schema  │ Check input matches tool's Zod schema
└────────┬─────────┘
         │
         ├─ PASS → Continue
         │
         └─ FAIL → Error: "Invalid parameter 'foo'"
                   Stop, return error, wait for correction
         │
         ▼
┌──────────────────┐
│ Execute Tool     │ Run tool function with validated input
└────────┬─────────┘
         │
         ├─ SUCCESS → Return result
         │
         └─ ERROR → Catch exception, return error message
```

---

## Error Handling

### Error Types and Recovery

#### Error Type 1: Invalid Input

```
Agent Action: cms_getPage
Agent Input: {"slug": "about", "invalid_param": true}

Error: "Invalid parameter: invalid_param"

Recovery: Correct the request
Thought: I used a parameter that doesn't exist.
  Tool schema only accepts: slug, id, includeContent

Action: cms_getPage
Input: {"slug": "about", "includeContent": false}
```

#### Error Type 2: Resource Not Found

```
Agent Action: cms_getPage
Agent Input: {"slug": "about"}

Error: "404: Page not found"

Recovery: Use alternative approach
Thought: Exact match failed. The slug might be different.
  I'll use fuzzy search instead.

Action: cms_findResource
Input: {"query": "about", "resourceType": "page"}
```

#### Error Type 3: Permission Denied

```
Agent Action: cms_deletePage
Agent Input: {"pageId": "page-123"}

Error: "403: You don't have permission to delete"

Recovery: Inform user
Response: "I don't have permission to delete this page.
  Only administrators can perform this action."
```

#### Error Type 4: Server Error

```
Agent Action: cms_getPage
Agent Input: {"slug": "about"}

Error: "500: Internal Server Error"

Recovery: Retry with backoff
Thought: Server error. This is likely temporary.
  I'll wait and retry once.

[Wait 2 seconds]

Action: cms_getPage
Input: {"slug": "about"}
```

### Error Classification

```
Error Response → Classify Type:
                 ├─ 400/Invalid → Bad input
                 ├─ 404/Missing → Resource not found
                 ├─ 403/Forbidden → Permission denied
                 └─ 500/Server → Transient error → Retry
```

---

## Your CMS Implementation

### Tool Definitions (AI SDK v6)

```typescript
const cmsGetPage = tool({
  description: 'Get a page by slug or ID...',
  inputSchema: z.object({
    slug: z.string().optional().describe('Page slug'),
    id: z.string().optional().describe('Page UUID'),
    includeContent: z.boolean().optional().default(false)
  }),
  execute: async (input, { experimental_context }) => {
    // Validation: Ensure slug OR id provided
    if (!input.slug && !input.id) {
      throw new Error('Either slug or id required');
    }

    // Execution
    const page = await ctx.cms.getPage(input);
    return page;
  }
})
```

### Execution Within ReAct Loop

From your `react.xml`:

```xml
**CONTENT RETRIEVAL STRATEGIES:**

1. **Lightweight First** (DEFAULT):
   - Use cms_getPage WITHOUT includeContent flag
   - Then cms_getSectionContent for specifics

2. **Full Fetch** (when needed):
   - Use cms_getPage WITH includeContent: true

**OPTIMIZATION RULES:**
- If user asks ONE specific field → lightweight (~500 tokens)
- If user asks ENTIRE page → includeContent: true (~2000 tokens)
- DEFAULT to lightweight
```

**Strength**: Explicit strategy selection in acting phase.

---

## Token Efficiency in Acting

### The Cost of Actions

```
Simple GET (metadata only):
  Action: cms_getPage
  Input: {"slug": "about"}
  Cost: ~500 tokens
  Returns: [title, slug, section IDs]

Full GET (with content):
  Action: cms_getPage
  Input: {"slug": "about", "includeContent": true}
  Cost: ~2000 tokens
  Returns: [title, slug, section IDs, full content]

Granular GET (specific section):
  Action: cms_getPage (metadata): ~500 tokens
  Action: cms_getSectionContent (specific): ~300 tokens
  Total: ~800 tokens
  Returns: Only what's needed
```

### Your Optimization Rules

```xml
**STRATEGY SELECTION:**
- Lightweight first: 500 tokens (80% of queries)
- Granular: 500-1500 tokens (18% of queries)
- Full fetch: 2000+ tokens (2% of queries)

If unsure, use lightweight and ask for more if needed.
```

**Impact**: 40-96% token savings vs always fetching full content.

---

## Destructive Operations (HITL)

### Your Implementation Pattern

```xml
**DESTRUCTIVE OPERATIONS:**
1. **Call without confirmed flag**
   → Tool returns requiresConfirmation: true

2. **Inform user and STOP**
   → "⚠️ Would delete 3 sections. Confirm with 'yes'"

3. **Wait for user approval**
   → Store: what-is-being-confirmed

4. **Call again with confirmed: true**
   → Perform deletion
```

### Code Example

```typescript
const cms_deletePageSections = tool({
  inputSchema: z.object({
    pageSectionIds: z.array(z.string()),
    confirmed: z.boolean().optional().default(false)
  }),
  execute: async (input) => {
    if (!input.confirmed) {
      // First call: dry-run
      return {
        requiresConfirmation: true,
        message: `Will delete ${input.pageSectionIds.length} sections. Confirm?`,
        items: input.pageSectionIds
      };
    }

    // Second call: actual deletion
    const result = await ctx.cms.deleteSections(input.pageSectionIds);
    return { success: true, deleted: result };
  }
})
```

### Two-Stage Workflow

```
Agent: "I can delete the hero section"
User: "Yes, do it"
            ↓
Agent Action (Stage 1): cms_deletePageSections(
  pageSectionIds: ["section-123"],
  confirmed: false  // First time
)
            ↓
Agent: "⚠️ Are you sure? This will delete [Hero].
        Type 'yes' to confirm"
            ↓
User: "yes"
            ↓
Agent Action (Stage 2): cms_deletePageSections(
  pageSectionIds: ["section-123"],
  confirmed: true  // User approved
)
            ↓
Success: Section deleted
```

---

## Action Chaining

### Multiple Tools Per Turn

Your rule: **"CHAIN operations - Complete multi-step tasks in one turn"**

Benefits:
- ✅ 66.8% time savings (fewer LLM calls)
- ✅ Better context retention
- ✅ Natural progression through workflow

Example:
```
User: "Create about page with hero, features, and CTA sections"

Turn 1: Multiple actions within same LLM call
  Action 1: cms_createPage(slug: "about")
  [Observe result: page-456]

  Action 2: cms_addSectionToPage(pageId: "page-456", sectionType: "hero")
  [Observe result: section-789]

  Action 3: cms_addSectionToPage(pageId: "page-456", sectionType: "features")
  [Observe result: section-790]

  Action 4: cms_addSectionToPage(pageId: "page-456", sectionType: "cta")
  [Observe result: section-791]

  [Final response: "Created page with 3 sections"]

Result: 1 LLM call instead of 5
```

---

## Observability & Debugging

### What to Log

```typescript
interface ActionLog {
  timestamp: string;
  thought: string;
  action: {
    tool: string;
    input: any;
  };
  result: {
    status: "success" | "error";
    data?: any;
    error?: string;
  };
  executionTime: number;  // ms
  tokensUsed: number;
}
```

### Example Log Entry

```json
{
  "timestamp": "2025-11-21T10:30:45Z",
  "thought": "Need to find about page first",
  "action": {
    "tool": "cms_findResource",
    "input": {"query": "about", "resourceType": "page"}
  },
  "result": {
    "status": "success",
    "data": {
      "id": "page-456",
      "slug": "about-us",
      "match": 0.95
    }
  },
  "executionTime": 245,
  "tokensUsed": 350
}
```

---

## Best Practices

### Checklist Before Action

```
□ Do I have the tool name correct?
□ Are all required parameters present?
□ Do parameter values match schema?
□ Is this the most efficient tool choice?
□ Will this move toward goal completion?
□ Have I considered error scenarios?
```

### Common Mistakes

| Mistake | Impact | Fix |
|---------|--------|-----|
| Wrong parameter name | 400 error | Validate against schema |
| Missing required field | Tool fails | Collect info first |
| Inefficient tool choice | Extra calls | Evaluate alternatives |
| No error handling | Crash | Implement recovery |
| Too many actions | Parse failures | Use single action per iteration |

---

## References

1. Yao et al. (2022). "ReAct: Synergizing Reasoning and Acting"
2. PALADIN Framework (2024). "Error Recovery in Agent Systems"
3. AI SDK 6 Documentation (2025)
4. LangChain Tool Execution Patterns (2024)

---

**Status**: Complete
**Word Count**: ~2,200
**Last Updated**: November 21, 2025
