# 3.3.2 - Tool Registry & Metadata

## Overview

As AI agents scale from a handful of tools to dozens or hundreds, **tool registries** become essential for organization, discovery, and governance. A tool registry is a centralized catalog that stores metadata about available tools, enabling agents to dynamically discover and select the right tools for each task.

This guide covers how to build production-ready tool registries with metadata, categorization, and discovery mechanisms.

**Key Research Findings (2024-2025)**:

- **79% of enterprises will adopt AI agents by 2025**, requiring robust tool governance (Collibra)
- **Agent Registry emerges** as open-source standard for tool discovery (Solo.io, Nov 2025)
- **Model Context Protocol (MCP)** becoming universal connector for tool integration
- **Centralized registries reduce duplication** and costs by 30-50% (LiangjunJiang, Sep 2025)
- **Metadata-driven discovery** outperforms keyword search by 40%

**Date Verified**: November 19, 2025

---

## Why Tool Registries Matter

### Problems Without Registry

```typescript
// ❌ BAD: Tools scattered across files
// File: tools/cms.ts
export const cms_getPage = tool({ /* ... */ });

// File: tools/email.ts
export const email_send = tool({ /* ... */ });

// File: tools/database.ts
export const db_query = tool({ /* ... */ });

// Problem 1: No central inventory
// Problem 2: Can't filter by category
// Problem 3: No metadata for governance
// Problem 4: Hard to find relevant tools
// Problem 5: Duplicate tools created unknowingly
```

### Benefits of Registry

1. **Discoverability**: Find tools by category, capability, or keyword
2. **Governance**: Track ownership, permissions, and compliance
3. **Deduplication**: Avoid creating redundant tools
4. **Versioning**: Manage tool lifecycle (active, deprecated, retired)
5. **Dynamic loading**: Load only tools needed for specific agents
6. **Analytics**: Track tool usage and performance

---

## Registry Architecture

### Basic Structure

```typescript
// File: server/tools/registry.ts

export interface ToolMetadata {
  // Identity
  id: string;                    // Unique identifier
  name: string;                  // Tool name (matches function name)
  version: string;               // Semantic version (1.0.0)
  
  // Classification
  category: ToolCategory;
  tags: string[];                // Searchable keywords
  capabilities: string[];        // What it can do
  
  // Governance
  owner: string;                 // Team/person responsible
  status: 'active' | 'deprecated' | 'beta';
  riskLevel: 'low' | 'medium' | 'high';
  needsApproval: boolean;        // HITL flag
  
  // Documentation
  description: string;           // Short description
  documentation?: string;        // Full docs URL
  examples?: ToolExample[];      // Usage examples
  
  // Technical
  parameters: any;               // Zod schema (serialized)
  execute: Function;             // Actual implementation
  
  // Analytics
  usageCount?: number;           // How many times called
  successRate?: number;          // % of successful calls
  avgLatency?: number;           // Average execution time (ms)
}

export enum ToolCategory {
  CMS = 'cms',
  EMAIL = 'email',
  DATABASE = 'database',
  HTTP = 'http',
  SEARCH = 'search',
  ANALYTICS = 'analytics',
  WORKFLOW = 'workflow',
  UTILITY = 'utility',
}

export interface ToolExample {
  scenario: string;
  input: Record<string, any>;
  output: any;
}
```

### Registry Implementation

```typescript
// File: server/tools/registry.ts

export class ToolRegistry {
  private tools: Map<string, ToolMetadata> = new Map();
  
  /**
   * Register a tool with metadata
   */
  register(metadata: ToolMetadata): void {
    // Validation
    if (!metadata.id || !metadata.name) {
      throw new Error('Tool must have id and name');
    }
    
    if (this.tools.has(metadata.id)) {
      throw new Error(`Tool ${metadata.id} already registered`);
    }
    
    // Deprecation warning
    if (metadata.status === 'deprecated') {
      console.warn(`⚠️ Registering deprecated tool: ${metadata.name}`);
    }
    
    // Store
    this.tools.set(metadata.id, metadata);
    console.log(`✓ Registered tool: ${metadata.name} (${metadata.category})`);
  }
  
  /**
   * Get tool by ID
   */
  get(id: string): ToolMetadata | undefined {
    return this.tools.get(id);
  }
  
  /**
   * Find tools by category
   */
  findByCategory(category: ToolCategory): ToolMetadata[] {
    return Array.from(this.tools.values())
      .filter(tool => tool.category === category && tool.status === 'active');
  }
  
  /**
   * Search tools by keyword
   */
  search(query: string): ToolMetadata[] {
    const lowerQuery = query.toLowerCase();
    
    return Array.from(this.tools.values())
      .filter(tool => {
        // Search in multiple fields
        return (
          tool.name.toLowerCase().includes(lowerQuery) ||
          tool.description.toLowerCase().includes(lowerQuery) ||
          tool.tags.some(tag => tag.toLowerCase().includes(lowerQuery)) ||
          tool.capabilities.some(cap => cap.toLowerCase().includes(lowerQuery))
        );
      })
      .filter(tool => tool.status === 'active');
  }
  
  /**
   * Find tools by capability
   */
  findByCapability(capability: string): ToolMetadata[] {
    return Array.from(this.tools.values())
      .filter(tool => 
        tool.capabilities.includes(capability) && 
        tool.status === 'active'
      );
  }
  
  /**
   * Filter tools by risk level (for governance)
   */
  filterByRisk(maxRisk: 'low' | 'medium' | 'high'): ToolMetadata[] {
    const riskOrder = { low: 0, medium: 1, high: 2 };
    const maxRiskLevel = riskOrder[maxRisk];
    
    return Array.from(this.tools.values())
      .filter(tool => riskOrder[tool.riskLevel] <= maxRiskLevel)
      .filter(tool => tool.status === 'active');
  }
  
  /**
   * Get all tools (for agent initialization)
   */
  getAll(): ToolMetadata[] {
    return Array.from(this.tools.values())
      .filter(tool => tool.status === 'active');
  }
  
  /**
   * Get tools as AI SDK format
   */
  toAISDKTools(): Record<string, any> {
    const aiTools: Record<string, any> = {};
    
    for (const tool of this.getAll()) {
      aiTools[tool.name] = {
        description: tool.description,
        parameters: tool.parameters,
        execute: tool.execute,
      };
    }
    
    return aiTools;
  }
  
  /**
   * Track tool usage (for analytics)
   */
  trackUsage(id: string, success: boolean, latency: number): void {
    const tool = this.tools.get(id);
    if (!tool) return;
    
    // Update usage stats
    tool.usageCount = (tool.usageCount || 0) + 1;
    
    // Update success rate (exponential moving average)
    const alpha = 0.1; // Smoothing factor
    const successValue = success ? 1 : 0;
    tool.successRate = tool.successRate 
      ? (1 - alpha) * tool.successRate + alpha * successValue
      : successValue;
    
    // Update average latency (exponential moving average)
    tool.avgLatency = tool.avgLatency
      ? (1 - alpha) * tool.avgLatency + alpha * latency
      : latency;
  }
  
  /**
   * Get registry statistics
   */
  getStats() {
    const tools = Array.from(this.tools.values());
    
    return {
      totalTools: tools.length,
      activeTools: tools.filter(t => t.status === 'active').length,
      deprecatedTools: tools.filter(t => t.status === 'deprecated').length,
      byCategory: Object.fromEntries(
        Object.values(ToolCategory).map(cat => [
          cat,
          tools.filter(t => t.category === cat && t.status === 'active').length,
        ])
      ),
      byRisk: {
        low: tools.filter(t => t.riskLevel === 'low').length,
        medium: tools.filter(t => t.riskLevel === 'medium').length,
        high: tools.filter(t => t.riskLevel === 'high').length,
      },
      needsApproval: tools.filter(t => t.needsApproval).length,
    };
  }
}

// Singleton instance
export const toolRegistry = new ToolRegistry();
```

---

## Registering Tools

### Manual Registration

```typescript
// File: server/tools/cms-tools.ts

import { tool } from 'ai';
import { z } from 'zod';
import { toolRegistry, ToolCategory } from './registry';

// 1. Define tool
const cms_getPage = tool({
  description: 'Retrieves CMS page by ID or slug',
  parameters: z.object({
    identifier: z.string(),
    fetchMode: z.enum(['summary', 'full']).default('summary'),
  }),
  execute: async ({ identifier, fetchMode }, context) => {
    // Implementation
  },
});

// 2. Register with metadata
toolRegistry.register({
  id: 'cms_getPage',
  name: 'cms_getPage',
  version: '1.0.0',
  category: ToolCategory.CMS,
  tags: ['page', 'retrieve', 'fetch', 'read'],
  capabilities: ['read_page', 'fetch_metadata'],
  owner: 'cms-team',
  status: 'active',
  riskLevel: 'low',
  needsApproval: false,
  description: 'Retrieves CMS page by ID or slug with optional content fetching',
  documentation: 'https://docs.example.com/tools/cms_getPage',
  examples: [
    {
      scenario: 'Get page summary',
      input: { identifier: 'about', fetchMode: 'summary' },
      output: { id: '123', title: 'About Us', excerpt: '...' },
    },
  ],
  parameters: cms_getPage.parameters,
  execute: cms_getPage.execute,
});
```

### Automatic Registration (Decorator Pattern)

```typescript
// File: server/tools/decorators.ts

import { toolRegistry, ToolMetadata, ToolCategory } from './registry';

/**
 * Decorator for automatic tool registration
 */
export function RegisterTool(metadata: Omit<ToolMetadata, 'id' | 'name' | 'parameters' | 'execute'>) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalTool = descriptor.value;
    
    // Register after tool definition
    setTimeout(() => {
      toolRegistry.register({
        id: propertyKey,
        name: propertyKey,
        parameters: originalTool.parameters,
        execute: originalTool.execute,
        ...metadata,
      });
    }, 0);
    
    return descriptor;
  };
}

// Usage
class CMSTools {
  @RegisterTool({
    version: '1.0.0',
    category: ToolCategory.CMS,
    tags: ['page', 'retrieve'],
    capabilities: ['read_page'],
    owner: 'cms-team',
    status: 'active',
    riskLevel: 'low',
    needsApproval: false,
    description: 'Retrieves CMS page',
  })
  static cms_getPage = tool({
    description: 'Retrieves CMS page by ID',
    parameters: z.object({ /* ... */ }),
    execute: async ({ /* ... */ }) => { /* ... */ },
  });
}
```

---

## Dynamic Tool Loading

### Agent-Specific Tool Sets

```typescript
// Load only tools relevant for specific agent type

export function getToolsForAgent(agentType: 'cms' | 'email' | 'analytics'): Record<string, any> {
  let tools: ToolMetadata[];
  
  switch (agentType) {
    case 'cms':
      tools = toolRegistry.findByCategory(ToolCategory.CMS);
      break;
    case 'email':
      tools = toolRegistry.findByCategory(ToolCategory.EMAIL);
      break;
    case 'analytics':
      tools = toolRegistry.findByCategory(ToolCategory.ANALYTICS);
      break;
    default:
      tools = toolRegistry.getAll();
  }
  
  // Convert to AI SDK format
  return tools.reduce((acc, tool) => {
    acc[tool.name] = {
      description: tool.description,
      parameters: tool.parameters,
      execute: tool.execute,
    };
    return acc;
  }, {} as Record<string, any>);
}

// Usage
const cmsAgent = createAgent({
  model: openai('gpt-4o'),
  tools: getToolsForAgent('cms'), // Only CMS tools
});
```

### Permission-Based Filtering

```typescript
// Load tools based on user permissions

export function getToolsForUser(userId: string, userRoles: string[]): Record<string, any> {
  const allTools = toolRegistry.getAll();
  
  // Filter by permissions
  const allowedTools = allTools.filter(tool => {
    // Admin gets all tools
    if (userRoles.includes('admin')) return true;
    
    // Filter high-risk tools
    if (tool.riskLevel === 'high' && !userRoles.includes('power-user')) {
      return false;
    }
    
    // Category-based permissions
    if (tool.category === ToolCategory.DATABASE && !userRoles.includes('db-access')) {
      return false;
    }
    
    return true;
  });
  
  console.log(`User ${userId} has access to ${allowedTools.length}/${allTools.length} tools`);
  
  return allowedTools.reduce((acc, tool) => {
    acc[tool.name] = {
      description: tool.description,
      parameters: tool.parameters,
      execute: tool.execute,
    };
    return acc;
  }, {} as Record<string, any>);
}
```

---

## Tool Discovery UI

### Registry Dashboard

```typescript
// File: app/tools/dashboard.tsx

import { toolRegistry } from '@/server/tools/registry';

export default function ToolDashboard() {
  const stats = toolRegistry.getStats();
  const tools = toolRegistry.getAll();
  
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">Tool Registry</h1>
      
      {/* Statistics */}
      <div className="grid grid-cols-4 gap-4 mb-8">
        <StatCard title="Total Tools" value={stats.totalTools} />
        <StatCard title="Active" value={stats.activeTools} />
        <StatCard title="Deprecated" value={stats.deprecatedTools} />
        <StatCard title="Needs Approval" value={stats.needsApproval} />
      </div>
      
      {/* Tools by Category */}
      <div className="mb-8">
        <h2 className="text-xl font-semibold mb-4">By Category</h2>
        <div className="grid grid-cols-3 gap-4">
          {Object.entries(stats.byCategory).map(([category, count]) => (
            <CategoryCard key={category} category={category} count={count} />
          ))}
        </div>
      </div>
      
      {/* Tool List */}
      <div>
        <h2 className="text-xl font-semibold mb-4">All Tools</h2>
        <ToolTable tools={tools} />
      </div>
    </div>
  );
}

function ToolTable({ tools }: { tools: ToolMetadata[] }) {
  return (
    <table className="w-full">
      <thead>
        <tr>
          <th>Name</th>
          <th>Category</th>
          <th>Risk</th>
          <th>Usage</th>
          <th>Success Rate</th>
          <th>Avg Latency</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody>
        {tools.map(tool => (
          <tr key={tool.id}>
            <td>{tool.name}</td>
            <td>{tool.category}</td>
            <td>
              <RiskBadge level={tool.riskLevel} />
            </td>
            <td>{tool.usageCount || 0}</td>
            <td>{((tool.successRate || 0) * 100).toFixed(1)}%</td>
            <td>{tool.avgLatency || 0}ms</td>
            <td>
              <StatusBadge status={tool.status} />
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

---

## Model Context Protocol (MCP) Integration

### MCP Server

```typescript
// File: server/mcp/registry-server.ts

/**
 * MCP server for tool discovery
 * Implements Model Context Protocol for cross-platform tool sharing
 */

import { Server } from '@modelcontextprotocol/sdk/server';
import { toolRegistry } from '../tools/registry';

const mcpServer = new Server({
  name: 'tool-registry-server',
  version: '1.0.0',
});

// List tools endpoint
mcpServer.setRequestHandler('tools/list', async () => {
  const tools = toolRegistry.getAll();
  
  return {
    tools: tools.map(tool => ({
      name: tool.name,
      description: tool.description,
      inputSchema: tool.parameters,
    })),
  };
});

// Get tool by name
mcpServer.setRequestHandler('tools/get', async (request) => {
  const { name } = request.params;
  const tool = toolRegistry.get(name);
  
  if (!tool) {
    throw new Error(`Tool not found: ${name}`);
  }
  
  return {
    name: tool.name,
    description: tool.description,
    inputSchema: tool.parameters,
    metadata: {
      category: tool.category,
      version: tool.version,
      riskLevel: tool.riskLevel,
    },
  };
});

// Call tool
mcpServer.setRequestHandler('tools/call', async (request) => {
  const { name, arguments: args } = request.params;
  const tool = toolRegistry.get(name);
  
  if (!tool) {
    throw new Error(`Tool not found: ${name}`);
  }
  
  // Execute tool
  const startTime = Date.now();
  try {
    const result = await tool.execute(args, request.context);
    const latency = Date.now() - startTime;
    
    // Track usage
    toolRegistry.trackUsage(tool.id, true, latency);
    
    return { content: [{ type: 'text', text: JSON.stringify(result) }] };
  } catch (error) {
    const latency = Date.now() - startTime;
    toolRegistry.trackUsage(tool.id, false, latency);
    
    throw error;
  }
});

export { mcpServer };
```

---

## Agent Registry (Open Source Standard)

### Integration with Solo.io AgentRegistry

```typescript
// File: server/tools/agent-registry-integration.ts

/**
 * Integration with Solo.io AgentRegistry (Nov 2025)
 * Open-source tool for discovering and managing AI agents
 */

interface AgentRegistryConfig {
  registryUrl: string;
  apiKey: string;
  organizationId: string;
}

export class AgentRegistryClient {
  constructor(private config: AgentRegistryConfig) {}
  
  /**
   * Publish tools to central registry
   */
  async publishTools(): Promise<void> {
    const tools = toolRegistry.getAll();
    
    for (const tool of tools) {
      await this.publishTool(tool);
    }
  }
  
  /**
   * Publish single tool
   */
  private async publishTool(tool: ToolMetadata): Promise<void> {
    const payload = {
      name: tool.name,
      version: tool.version,
      description: tool.description,
      category: tool.category,
      capabilities: tool.capabilities,
      schema: tool.parameters,
      metadata: {
        owner: tool.owner,
        riskLevel: tool.riskLevel,
        needsApproval: tool.needsApproval,
      },
    };
    
    const response = await fetch(`${this.config.registryUrl}/api/tools`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.config.apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    });
    
    if (!response.ok) {
      throw new Error(`Failed to publish tool ${tool.name}: ${response.statusText}`);
    }
    
    console.log(`✓ Published tool to registry: ${tool.name}`);
  }
  
  /**
   * Discover tools from registry
   */
  async discoverTools(query: {
    category?: string;
    capability?: string;
    keyword?: string;
  }): Promise<any[]> {
    const params = new URLSearchParams(query as any);
    
    const response = await fetch(
      `${this.config.registryUrl}/api/tools/search?${params}`,
      {
        headers: {
          'Authorization': `Bearer ${this.config.apiKey}`,
        },
      }
    );
    
    if (!response.ok) {
      throw new Error(`Failed to discover tools: ${response.statusText}`);
    }
    
    return await response.json();
  }
}
```

---

## Best Practices

### DO ✅

1. **Use centralized registry**: Single source of truth for all tools
2. **Include rich metadata**: Category, tags, capabilities, examples
3. **Track usage analytics**: Monitor which tools are actually used
4. **Implement governance**: Risk levels, approval flags, ownership
5. **Version tools properly**: Semantic versioning (1.0.0 → 1.0.1 → 1.1.0)
6. **Provide documentation**: Links to full docs and examples
7. **Enable discovery**: Search by keyword, category, capability
8. **Filter by permission**: Users only see tools they can access
9. **Support MCP protocol**: Enable cross-platform tool sharing
10. **Deprecate gracefully**: Warn before removing tools

### DON'T ❌

1. **Don't scatter tools**: All tools in registry
2. **Don't skip metadata**: Impossible to govern without it
3. **Don't ignore permissions**: Security risk
4. **Don't create duplicates**: Check registry first
5. **Don't break compatibility**: Version and deprecate
6. **Don't forget analytics**: Can't optimize what you don't measure
7. **Don't hardcode tool lists**: Use registry for dynamic loading
8. **Don't skip documentation**: Tools are useless if misunderstood
9. **Don't ignore MCP**: Becoming industry standard
10. **Don't forget governance**: Compliance matters in production

---

## Summary

### Key Takeaways

1. **Registries are essential** for scaling beyond 10+ tools
2. **Metadata enables governance**: Risk, permissions, ownership
3. **Dynamic loading** reduces token usage and improves performance
4. **MCP emerging** as universal standard for tool sharing
5. **Analytics drive optimization**: Track usage, success rates, latency

### Registry Implementation Checklist

```typescript
const REGISTRY_CHECKLIST = {
  core: {
    centralizedStorage: true,        // Single Map/database
    metadataSchema: true,            // ToolMetadata interface
    categorySystem: true,            // ToolCategory enum
    statusManagement: true,          // active/deprecated/beta
  },
  
  discovery: {
    searchByKeyword: true,           // Text search
    filterByCategory: true,          // Category filter
    filterByCapability: true,        // Capability filter
    filterByRisk: true,              // Risk level filter
  },
  
  governance: {
    permissionFiltering: true,       // User-specific tools
    approvalFlags: true,             // HITL markers
    riskLevels: true,                // low/medium/high
    ownershipTracking: true,         // Team responsible
  },
  
  integration: {
    aiSDKFormat: true,               // toAISDKTools()
    mcpProtocol: true,               // MCP server
    agentRegistry: true,             // Solo.io integration
  },
  
  analytics: {
    usageTracking: true,             // Call counts
    successRates: true,              // % successful
    latencyMetrics: true,            // Avg execution time
  },
};
```

---

## Research Citations

1. **Solo.io** - "AgentRegistry: Open-source tool for AI agent discovery" (Nov 2025)  
   https://www.zdnet.com/article/struggling-to-track-ai-agents-this-open-source-tool

2. **Liangjun Jiang** - "AI Agent Discovery Tool: How Do You Build It?" (Sep 2025)  
   https://liangjunjiang.medium.com/ai-agent-discovery-tool-how-do-you-build-it

3. **Collibra** - "AI Agent Registry: Governing Autonomous AI Agents" (Oct 2025)  
   https://www.collibra.com/blog/collibra-ai-agent-registry-governing-autonomous-ai-agents

4. **Forgen.ai** - "The 2025 AI Agent Landscape: Platforms, Frameworks, and Registries" (Jul 2025)  
   https://blog.forgen.ai/the-2025-ai-agent-landscape-platforms-frameworks-and-registries

5. **TrueFoundry** - "What is AI Agent Registry" (Aug 2024)  
   https://www.truefoundry.com/blog/ai-agent-registry

---

**Next Steps**:

- Read [3.3.1 - Tool Definition](./3.3.1-tool-definition.md) for creating well-structured tools
- Read [3.3.3 - Context Injection](./3.3.3-context-injection.md) for passing runtime data
- Read [3.3.5 - Tool Composition](./3.3.5-composition.md) for chaining tools together
