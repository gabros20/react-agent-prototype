# 3.3.2 - Tool Registry

> **Layer**: Agent Architecture | **Topic**: Tool System
> **Version**: 2.0 | **Date Verified**: December 2025

---

## TL;DR

**Tool registries provide centralized management for tool discovery, governance, and dynamic loading.** As agents scale beyond 10+ tools, registries become essential for organization, permission filtering, and analytics tracking.

### Key Takeaways

- **Centralized catalog** prevents tool duplication and enables discovery
- **Metadata-driven governance** tracks ownership, risk levels, and permissions
- **Dynamic loading** reduces token usage by loading only relevant tools
- **MCP integration** enables cross-platform tool sharing
- **Usage analytics** reveal which tools need optimization

---

## Why It Matters

### The Problem

Without a registry, tools become unmanageable:

```
project/
├── tools/cms.ts          # 8 tools
├── tools/email.ts        # 5 tools
├── tools/database.ts     # 6 tools
├── tools/search.ts       # 4 tools
└── tools/utils.ts        # 7 tools

Problems:
• No central inventory → Which tools exist?
• No categorization → Which tools handle CMS?
• No governance → Who owns cms_deletePage?
• No permissions → Can this user delete pages?
• No analytics → Which tools fail most often?
```

### Research Evidence

| Finding | Source | Year |
|---------|--------|------|
| **79%** of enterprises will adopt AI agents by 2025 | Collibra | 2025 |
| Centralized registries reduce duplication by **30-50%** | LiangjunJiang | Sep 2025 |
| Metadata-driven discovery outperforms keyword search by **40%** | Industry research | 2025 |
| MCP becoming universal connector for tool integration | Anthropic | 2024-2025 |

---

## Core Concepts

### Registry Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                      TOOL REGISTRY                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  Metadata   │  │  Discovery  │  │  Analytics  │         │
│  │  Storage    │  │  & Search   │  │  Tracking   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
│        ↓                ↓                ↓                  │
│  ┌─────────────────────────────────────────────────┐       │
│  │               Tool Definitions                   │       │
│  │  • cms_getPage      • email_send                │       │
│  │  • cms_createPage   • search_query              │       │
│  │  • cms_updatePage   • db_query                  │       │
│  └─────────────────────────────────────────────────┘       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Metadata Schema

```typescript
interface ToolMetadata {
  // Identity
  id: string;                    // Unique identifier
  name: string;                  // Tool function name
  version: string;               // Semantic version (1.0.0)

  // Classification
  category: ToolCategory;        // cms, email, database, etc.
  tags: string[];                // Searchable keywords
  capabilities: string[];        // What it can do

  // Governance
  owner: string;                 // Team/person responsible
  status: 'active' | 'deprecated' | 'beta';
  riskLevel: 'low' | 'medium' | 'high';
  needsApproval: boolean;        // HITL flag

  // Documentation
  description: string;
  documentation?: string;        // Link to full docs
  examples?: ToolExample[];

  // Technical
  inputSchema: ZodSchema;        // Zod schema
  execute: Function;             // Implementation

  // Analytics
  usageCount?: number;
  successRate?: number;
  avgLatency?: number;
}

enum ToolCategory {
  CMS = 'cms',
  EMAIL = 'email',
  DATABASE = 'database',
  SEARCH = 'search',
  ANALYTICS = 'analytics',
  WORKFLOW = 'workflow',
  UTILITY = 'utility',
}
```

---

## Implementation Guide

### Step-by-Step

#### 1. Create the Registry Class

```typescript
// server/tools/registry.ts
export class ToolRegistry {
  private tools: Map<string, ToolMetadata> = new Map();

  register(metadata: ToolMetadata): void {
    if (!metadata.id || !metadata.name) {
      throw new Error('Tool must have id and name');
    }

    if (this.tools.has(metadata.id)) {
      throw new Error(`Tool ${metadata.id} already registered`);
    }

    if (metadata.status === 'deprecated') {
      console.warn(`⚠️ Registering deprecated tool: ${metadata.name}`);
    }

    this.tools.set(metadata.id, metadata);
    console.log(`✓ Registered: ${metadata.name} (${metadata.category})`);
  }

  get(id: string): ToolMetadata | undefined {
    return this.tools.get(id);
  }

  findByCategory(category: ToolCategory): ToolMetadata[] {
    return Array.from(this.tools.values())
      .filter(t => t.category === category && t.status === 'active');
  }

  search(query: string): ToolMetadata[] {
    const q = query.toLowerCase();
    return Array.from(this.tools.values())
      .filter(t =>
        t.status === 'active' && (
          t.name.toLowerCase().includes(q) ||
          t.description.toLowerCase().includes(q) ||
          t.tags.some(tag => tag.toLowerCase().includes(q))
        )
      );
  }

  filterByRisk(maxRisk: 'low' | 'medium' | 'high'): ToolMetadata[] {
    const riskOrder = { low: 0, medium: 1, high: 2 };
    return Array.from(this.tools.values())
      .filter(t => riskOrder[t.riskLevel] <= riskOrder[maxRisk])
      .filter(t => t.status === 'active');
  }

  // Convert to AI SDK format
  toAISDKTools(): Record<string, any> {
    const result: Record<string, any> = {};
    for (const tool of this.getAll()) {
      result[tool.name] = {
        description: tool.description,
        inputSchema: tool.inputSchema,
        execute: tool.execute,
      };
    }
    return result;
  }

  getAll(): ToolMetadata[] {
    return Array.from(this.tools.values())
      .filter(t => t.status === 'active');
  }
}

// Singleton
export const toolRegistry = new ToolRegistry();
```

#### 2. Register Tools with Metadata

```typescript
// server/tools/cms/index.ts
import { tool } from 'ai';
import { z } from 'zod';
import { toolRegistry, ToolCategory } from '../registry';

// Define tool
const cms_getPage = tool({
  description: 'Retrieves CMS page by ID or slug',
  inputSchema: z.object({
    identifier: z.string(),
    fetchMode: z.enum(['summary', 'full']).default('summary'),
  }),
  execute: async ({ identifier, fetchMode }, { experimental_context }) => {
    // Implementation
  },
});

// Register with metadata
toolRegistry.register({
  id: 'cms_getPage',
  name: 'cms_getPage',
  version: '1.0.0',
  category: ToolCategory.CMS,
  tags: ['page', 'retrieve', 'fetch', 'read'],
  capabilities: ['read_page', 'fetch_metadata'],
  owner: 'cms-team',
  status: 'active',
  riskLevel: 'low',
  needsApproval: false,
  description: 'Retrieves CMS page by ID or slug',
  documentation: 'https://docs.example.com/tools/cms_getPage',
  examples: [
    {
      scenario: 'Get page summary',
      input: { identifier: 'about', fetchMode: 'summary' },
      output: { id: '123', title: 'About Us' },
    },
  ],
  inputSchema: cms_getPage.inputSchema,
  execute: cms_getPage.execute,
});
```

#### 3. Dynamic Tool Loading

```typescript
// Load tools based on agent type
export function getToolsForAgent(
  agentType: 'cms' | 'email' | 'general'
): Record<string, any> {
  let tools: ToolMetadata[];

  switch (agentType) {
    case 'cms':
      tools = toolRegistry.findByCategory(ToolCategory.CMS);
      break;
    case 'email':
      tools = toolRegistry.findByCategory(ToolCategory.EMAIL);
      break;
    default:
      tools = toolRegistry.getAll();
  }

  return tools.reduce((acc, t) => {
    acc[t.name] = {
      description: t.description,
      inputSchema: t.inputSchema,
      execute: t.execute,
    };
    return acc;
  }, {} as Record<string, any>);
}

// Load tools based on user permissions
export function getToolsForUser(
  userRoles: string[]
): Record<string, any> {
  const allTools = toolRegistry.getAll();

  const allowed = allTools.filter(tool => {
    // Admin gets all tools
    if (userRoles.includes('admin')) return true;

    // Filter high-risk tools for non-power-users
    if (tool.riskLevel === 'high' && !userRoles.includes('power-user')) {
      return false;
    }

    return true;
  });

  return allowed.reduce((acc, t) => {
    acc[t.name] = {
      description: t.description,
      inputSchema: t.inputSchema,
      execute: t.execute,
    };
    return acc;
  }, {} as Record<string, any>);
}
```

---

## Framework Integration

### AI SDK v6 with Registry

```typescript
import { generateText, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';
import { toolRegistry } from './tools/registry';

// Use registry to get tools
const result = await generateText({
  model: openai('gpt-4o'),
  prompt: userMessage,

  // Get tools from registry
  tools: toolRegistry.toAISDKTools(),

  // Or filtered by category
  tools: getToolsForAgent('cms'),

  // Or filtered by user permissions
  tools: getToolsForUser(user.roles),

  experimental_context: context,
  stopWhen: stepCountIs(15),
});
```

### MCP Integration

```typescript
// server/mcp/registry-server.ts
import { Server } from '@modelcontextprotocol/sdk/server';
import { toolRegistry } from '../tools/registry';

const mcpServer = new Server({
  name: 'tool-registry-server',
  version: '1.0.0',
});

// List tools endpoint
mcpServer.setRequestHandler('tools/list', async () => {
  const tools = toolRegistry.getAll();
  return {
    tools: tools.map(t => ({
      name: t.name,
      description: t.description,
      inputSchema: t.inputSchema,
    })),
  };
});

// Call tool endpoint
mcpServer.setRequestHandler('tools/call', async (request) => {
  const { name, arguments: args } = request.params;
  const tool = toolRegistry.get(name);

  if (!tool) throw new Error(`Tool not found: ${name}`);

  const result = await tool.execute(args, request.context);
  return { content: [{ type: 'text', text: JSON.stringify(result) }] };
});
```

---

## Testing Strategy

### Registry Unit Tests

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { ToolRegistry, ToolCategory } from '../registry';

describe('ToolRegistry', () => {
  let registry: ToolRegistry;

  beforeEach(() => {
    registry = new ToolRegistry();
  });

  it('registers and retrieves tools', () => {
    registry.register({
      id: 'test_tool',
      name: 'test_tool',
      version: '1.0.0',
      category: ToolCategory.UTILITY,
      tags: ['test'],
      capabilities: ['testing'],
      owner: 'test-team',
      status: 'active',
      riskLevel: 'low',
      needsApproval: false,
      description: 'A test tool',
      inputSchema: z.object({}),
      execute: async () => ({ success: true }),
    });

    expect(registry.get('test_tool')).toBeDefined();
    expect(registry.get('test_tool')?.name).toBe('test_tool');
  });

  it('filters by category', () => {
    // Register CMS tool
    registry.register({ ...baseTool, id: 'cms_1', category: ToolCategory.CMS });
    // Register EMAIL tool
    registry.register({ ...baseTool, id: 'email_1', category: ToolCategory.EMAIL });

    const cmsTools = registry.findByCategory(ToolCategory.CMS);
    expect(cmsTools).toHaveLength(1);
    expect(cmsTools[0].id).toBe('cms_1');
  });

  it('excludes deprecated tools from getAll', () => {
    registry.register({ ...baseTool, id: 'active', status: 'active' });
    registry.register({ ...baseTool, id: 'deprecated', status: 'deprecated' });

    const all = registry.getAll();
    expect(all).toHaveLength(1);
    expect(all[0].id).toBe('active');
  });
});
```

---

## Common Pitfalls

### ❌ Avoid

| Pitfall | Problem | Solution |
|---------|---------|----------|
| Tools scattered across files | No central inventory | Use registry for all tools |
| No metadata | Can't govern or discover | Add category, owner, risk level |
| No permission filtering | Security risk | Filter by user roles |
| Hardcoded tool lists | Inflexible | Use registry's dynamic loading |
| No deprecation strategy | Breaking changes | Use status field, warn before removal |

### ✅ Best Practices

1. **Register all tools** - Even internal ones need tracking
2. **Use semantic versioning** - 1.0.0 → 1.0.1 (patch) → 1.1.0 (minor)
3. **Track ownership** - Who to contact when tool fails
4. **Filter by permission** - Users see only allowed tools
5. **Monitor usage** - Track which tools need optimization

---

## Summary

### Quick Reference

```typescript
// Registry Pattern
import { toolRegistry, ToolCategory } from './registry';

// 1. Register tool with full metadata
toolRegistry.register({
  id: 'cms_getPage',
  name: 'cms_getPage',
  version: '1.0.0',
  category: ToolCategory.CMS,
  tags: ['page', 'read'],
  capabilities: ['read_page'],
  owner: 'cms-team',
  status: 'active',
  riskLevel: 'low',
  needsApproval: false,
  description: 'Gets CMS page',
  inputSchema,
  execute,
});

// 2. Get tools for agent
const tools = toolRegistry.toAISDKTools();

// 3. Filter by category
const cmsTools = toolRegistry.findByCategory(ToolCategory.CMS);

// 4. Filter by permission
const userTools = getToolsForUser(user.roles);
```

### Decision Tree

```
When adding a tool to the registry:

1. Does it fit an existing category?
   ├─ Yes → Use that category
   └─ No → Consider creating new category or use UTILITY

2. What's the risk level?
   ├─ Read-only → low
   ├─ Mutations → medium
   └─ Destructive/external → high

3. Does it need approval?
   ├─ Sends emails, deletes data → Yes
   └─ Internal queries → No

4. Who owns it?
   └─ Assign team/person for accountability
```

---

## Related Topics

- [3.3.1 - Tool Definition](./3.3.1-tool-definition.md) - Creating well-structured tools
- [3.3.3 - Context Injection](./3.3.3-context-injection.md) - Passing runtime data to tools
- [3.3.5 - Tool Composition](./3.3.5-composition.md) - Chaining tools together

---

## Research Citations

1. **Solo.io** - "AgentRegistry: Open-source tool for AI agent discovery" (Nov 2025)
   https://www.zdnet.com/article/struggling-to-track-ai-agents-this-open-source-tool

2. **Liangjun Jiang** - "AI Agent Discovery Tool: How Do You Build It?" (Sep 2025)
   https://liangjunjiang.medium.com/ai-agent-discovery-tool-how-do-you-build-it

3. **Collibra** - "AI Agent Registry: Governing Autonomous AI Agents" (Oct 2025)
   https://www.collibra.com/blog/collibra-ai-agent-registry-governing-autonomous-ai-agents

4. **Anthropic** - "Model Context Protocol" (2024-2025)
   https://modelcontextprotocol.io/

5. **Forgen.ai** - "The 2025 AI Agent Landscape: Platforms, Frameworks, and Registries" (Jul 2025)
   https://blog.forgen.ai/the-2025-ai-agent-landscape-platforms-frameworks-and-registries
