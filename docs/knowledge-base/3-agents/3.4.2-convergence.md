# 3.4.2 - Convergence Detection (Task Completion Criteria)

## Overview

**Convergence detection** identifies when an agent has successfully completed its task and should stop executing. Unlike stuck detection (which catches failures) and max steps (which enforces limits), convergence detection recognizes **positive completion signals** that indicate the agent achieved its goal.

Effective convergence detection prevents unnecessary steps after task completion, reduces costs, and improves user experience by delivering results quickly.

**Key Research Findings (2024-2025)**:

- **96.5% of tasks converge within 3 iterations** with proper verification (Plan Verification paper, 2025)
- **Entropy-based stopping** reduces token usage by 15-30% while maintaining accuracy (HALT-CoT, 2025)
- **Progress tracking** achieves 90% recall + 100% precision in task completion detection
- **Goal-state reflection** (ReflAct) improves success rate to 93.3% (27.7% better than ReAct, May 2025)
- **Multi-criteria convergence** outperforms single-signal approaches by 40%

**Date Verified**: November 19, 2025

---

## Convergence vs. Other Stopping Mechanisms

### Comparison Table

| Mechanism               | Detects                  | Signal Type | Use Case                          |
| ----------------------- | ------------------------ | ----------- | --------------------------------- |
| **Convergence**         | Task complete (success)  | Positive    | Normal completion                 |
| **Stuck Detection**     | Unproductive loops       | Negative    | Failure prevention                |
| **Max Steps**           | Exceeded iteration limit | Limit       | Cost protection                   |
| **Early Exit**          | Sufficient progress      | Adaptive    | Efficiency optimization           |

**Best Practice**: Use all four mechanisms together for robust agent control.

---

## Convergence Signals

### 1. Explicit Completion Markers

**Most reliable**: Agent explicitly signals it's done.

```typescript
// ✅ GOOD: Explicit "finish" tool
const tools = {
  // ... other tools ...
  
  finish: tool({
    description: `Call this when you have completed the task and have a final answer.
                 Only call this when you are certain the task is complete.`,
    parameters: z.object({
      answer: z.string().describe('The final answer or summary of work completed'),
      confidence: z.number().min(0).max(1).describe('Confidence in completion (0-1)'),
      workSummary: z.string().optional().describe('Summary of actions taken'),
    }),
    execute: async ({ answer, confidence, workSummary }) => {
      return {
        finished: true,
        answer,
        confidence,
        workSummary,
      };
    },
  }),
};

// Check for finish signal in step handler
const onStepFinish = (step: any) => {
  if (step.toolCalls) {
    for (const call of step.toolCalls) {
      if (call.toolName === 'finish') {
        console.log('Agent signaled completion');
        return { shouldContinue: false, result: call.args.answer };
      }
    }
  }
  return { shouldContinue: true };
};
```

**Pros**:
- ✅ Unambiguous completion signal
- ✅ Agent provides confidence score
- ✅ Includes work summary for transparency

**Cons**:
- ❌ Agent must remember to call finish
- ❌ Premature finish calls if agent is overconfident
- ❌ Requires explicit tool in registry

### 2. Goal-State Verification

**Research-backed**: Verify that goal conditions are met.

```typescript
// From "ReflAct: World-Grounded Decision Making via Goal-State Reflection"
// https://arxiv.org/abs/2505.15182

interface TaskGoal {
  type: 'create' | 'update' | 'delete' | 'retrieve' | 'analyze';
  target: string;
  successCriteria: SuccessCriterion[];
}

interface SuccessCriterion {
  field: string;
  operator: 'equals' | 'contains' | 'exists' | 'matches';
  expectedValue: any;
}

class GoalStateVerifier {
  async verifyConvergence(
    goal: TaskGoal,
    context: AgentContext
  ): Promise<ConvergenceResult> {
    // Check each success criterion
    const results = await Promise.all(
      goal.successCriteria.map(criterion => 
        this.checkCriterion(criterion, goal.target, context)
      )
    );
    
    const allMet = results.every(r => r.met);
    const confidence = results.reduce((sum, r) => sum + r.confidence, 0) / results.length;
    
    return {
      converged: allMet,
      confidence,
      criteriaResults: results,
    };
  }
  
  private async checkCriterion(
    criterion: SuccessCriterion,
    target: string,
    context: AgentContext
  ): Promise<{ met: boolean; confidence: number; details: string }> {
    // Fetch current state of target
    const currentState = await context.fetchState(target);
    
    if (!currentState) {
      return {
        met: false,
        confidence: 1.0,
        details: `Target "${target}" not found`,
      };
    }
    
    // Check criterion
    const value = currentState[criterion.field];
    let met = false;
    
    switch (criterion.operator) {
      case 'equals':
        met = value === criterion.expectedValue;
        break;
      case 'contains':
        met = String(value).includes(criterion.expectedValue);
        break;
      case 'exists':
        met = value !== null && value !== undefined;
        break;
      case 'matches':
        met = new RegExp(criterion.expectedValue).test(String(value));
        break;
    }
    
    return {
      met,
      confidence: 1.0, // Deterministic checks have full confidence
      details: `${criterion.field} ${criterion.operator} ${criterion.expectedValue}: ${met ? 'PASS' : 'FAIL'}`,
    };
  }
}

// Usage example
const verifier = new GoalStateVerifier();

const goal: TaskGoal = {
  type: 'create',
  target: 'about-page',
  successCriteria: [
    { field: 'title', operator: 'exists', expectedValue: true },
    { field: 'content', operator: 'contains', expectedValue: 'hero section' },
    { field: 'status', operator: 'equals', expectedValue: 'published' },
  ],
};

// Check after each step
const onStepFinish = async (step: any, context: AgentContext) => {
  const convergence = await verifier.verifyConvergence(goal, context);
  
  if (convergence.converged) {
    console.log(`Task converged with ${(convergence.confidence * 100).toFixed(1)}% confidence`);
    return { shouldContinue: false };
  }
  
  return { shouldContinue: true };
};
```

**Results from ReflAct paper**:
- 93.3% success rate (vs 65.6% for vanilla ReAct)
- 27.7% improvement through explicit goal-state checking
- Reduces ungrounded reasoning errors

**Pros**:
- ✅ Objective verification (not relying on agent's judgment)
- ✅ Handles partial completion (show which criteria met)
- ✅ High confidence in convergence decision

**Cons**:
- ❌ Requires upfront goal specification
- ❌ Additional API calls for state verification
- ❌ Complex for open-ended tasks

### 3. Information Sufficiency Detection

**Best for research/analysis tasks**: Has enough information been gathered?

```typescript
// Track information accumulation
class InformationSufficiencyDetector {
  private facts: Set<string> = new Set();
  private readonly MIN_FACTS_THRESHOLD = 5;
  private readonly NOVELTY_DECAY_FACTOR = 0.8;
  private lastNoveltyRate = 1.0;
  
  recordToolResult(result: any): boolean {
    const newFacts = this.extractFacts(result);
    const previousSize = this.facts.size;
    
    // Add new facts
    newFacts.forEach(fact => this.facts.add(fact));
    
    // Calculate novelty rate
    const newFactsCount = this.facts.size - previousSize;
    const noveltyRate = newFactsCount / Math.max(newFacts.length, 1);
    
    // Update moving average
    this.lastNoveltyRate = 
      this.NOVELTY_DECAY_FACTOR * this.lastNoveltyRate + 
      (1 - this.NOVELTY_DECAY_FACTOR) * noveltyRate;
    
    // Converged if:
    // 1. Have minimum facts AND
    // 2. Novelty rate is low (diminishing returns)
    const hasEnoughFacts = this.facts.size >= this.MIN_FACTS_THRESHOLD;
    const noveltyIsDiminishing = this.lastNoveltyRate < 0.2; // <20% new info
    
    return hasEnoughFacts && noveltyIsDiminishing;
  }
  
  private extractFacts(result: any): string[] {
    if (typeof result === 'string') {
      // Simple heuristic: split by sentences
      return result
        .split(/[.!?]+/)
        .map(s => s.trim())
        .filter(s => s.length > 10); // Ignore short fragments
    } else if (Array.isArray(result)) {
      return result.map(item => JSON.stringify(item));
    } else if (typeof result === 'object') {
      return Object.entries(result).map(([k, v]) => `${k}:${v}`);
    }
    return [];
  }
  
  getDiagnostics() {
    return {
      totalFacts: this.facts.size,
      noveltyRate: this.lastNoveltyRate,
      converged: this.facts.size >= this.MIN_FACTS_THRESHOLD && this.lastNoveltyRate < 0.2,
    };
  }
}

// Usage
const sufficiency = new InformationSufficiencyDetector();

const onStepFinish = (step: any) => {
  if (step.toolCalls) {
    for (const call of step.toolCalls) {
      if (call.result) {
        const converged = sufficiency.recordToolResult(call.result);
        
        if (converged) {
          console.log('Information sufficiency reached:', sufficiency.getDiagnostics());
          return { shouldContinue: false };
        }
      }
    }
  }
  return { shouldContinue: true };
};
```

**Pros**:
- ✅ Good for research/exploration tasks
- ✅ Detects diminishing returns
- ✅ No upfront goal specification needed

**Cons**:
- ❌ Heuristic-based (may not capture semantic duplicates)
- ❌ Requires tuning thresholds per task type
- ❌ Not suitable for execution tasks

### 4. Confidence-Based Stopping (Entropy Method)

**Lightweight**: Stop when agent is confident in its answer.

```typescript
// From "HALT-CoT: Model-Agnostic Early Stopping via Answer Entropy"
// https://openreview.net/pdf?id=CX5c7C1CZa

import { generateObject } from 'ai';

class EntropyBasedConvergenceDetector {
  private readonly ENTROPY_THRESHOLD = 0.5; // Low entropy = high confidence
  
  async checkConvergence(
    currentAnswer: string,
    recentAnswers: string[]
  ): Promise<{ converged: boolean; entropy: number; confidence: number }> {
    // Sample multiple answers from current state
    const samples = await this.sampleAnswers(currentAnswer, 5);
    
    // Calculate Shannon entropy of answer distribution
    const entropy = this.calculateEntropy(samples);
    
    // Low entropy = answers are consistent = high confidence
    const confidence = 1 - entropy; // Convert to confidence score
    const converged = entropy < this.ENTROPY_THRESHOLD;
    
    return { converged, entropy, confidence };
  }
  
  private async sampleAnswers(baseAnswer: string, numSamples: number): Promise<string[]> {
    // Generate slight variations to test confidence
    const samples: string[] = [];
    
    for (let i = 0; i < numSamples; i++) {
      const { object } = await generateObject({
        model: openai('gpt-4o-mini'),
        temperature: 0.7, // Higher temp for diversity
        schema: z.object({
          answer: z.string(),
        }),
        prompt: `Given the current answer: "${baseAnswer}"
                 Provide your answer to the same question.
                 Be brief.`,
      });
      samples.push(object.answer);
    }
    
    return samples;
  }
  
  private calculateEntropy(answers: string[]): number {
    // Simple entropy: count unique answers
    const uniqueAnswers = new Set(answers.map(a => a.toLowerCase().trim()));
    
    // Calculate probability distribution
    const probs: number[] = [];
    for (const unique of uniqueAnswers) {
      const count = answers.filter(a => 
        a.toLowerCase().trim() === unique
      ).length;
      probs.push(count / answers.length);
    }
    
    // Shannon entropy: H = -Σ(p * log2(p))
    const entropy = -probs.reduce((sum, p) => 
      sum + (p > 0 ? p * Math.log2(p) : 0), 
      0
    );
    
    // Normalize to [0, 1] range
    const maxEntropy = Math.log2(answers.length);
    return entropy / maxEntropy;
  }
}

// Usage
const entropyDetector = new EntropyBasedConvergenceDetector();

// Check after generating an answer
const checkIfDone = async (currentAnswer: string, history: string[]) => {
  const result = await entropyDetector.checkConvergence(currentAnswer, history);
  
  console.log(`Entropy: ${result.entropy.toFixed(3)}, Confidence: ${(result.confidence * 100).toFixed(1)}%`);
  
  return result.converged;
};
```

**Results from HALT-CoT paper**:
- 15-30% token reduction
- Maintains 90%+ accuracy
- Works with any model (model-agnostic)

**Pros**:
- ✅ Lightweight (no state verification needed)
- ✅ Model-agnostic
- ✅ Reduces overthinking

**Cons**:
- ❌ Additional LLM calls for sampling (cost)
- ❌ Only suitable for answer-generation tasks
- ❌ Not for execution/action tasks

---

## Multi-Criteria Convergence

**Best practice**: Combine multiple signals for robust detection.

```typescript
// Composite convergence detector
interface ConvergenceScore {
  signal: string;
  score: number; // 0-1
  weight: number;
  details: string;
}

class CompositeConvergenceDetector {
  private goalVerifier: GoalStateVerifier;
  private sufficiencyDetector: InformationSufficiencyDetector;
  private entropyDetector: EntropyBasedConvergenceDetector;
  
  private readonly CONVERGENCE_THRESHOLD = 0.75; // 75% confidence
  
  async checkConvergence(
    goal: TaskGoal,
    context: AgentContext,
    step: any
  ): Promise<{ converged: boolean; overallScore: number; breakdown: ConvergenceScore[] }> {
    const scores: ConvergenceScore[] = [];
    
    // 1. Goal-state verification (highest weight)
    const goalResult = await this.goalVerifier.verifyConvergence(goal, context);
    scores.push({
      signal: 'goal_state',
      score: goalResult.converged ? 1.0 : 0.0,
      weight: 0.5, // 50% of total score
      details: `${goalResult.criteriaResults.filter(c => c.met).length}/${goalResult.criteriaResults.length} criteria met`,
    });
    
    // 2. Information sufficiency (medium weight)
    const sufficiency = this.sufficiencyDetector.getDiagnostics();
    scores.push({
      signal: 'information_sufficiency',
      score: sufficiency.converged ? 1.0 : Math.min(sufficiency.totalFacts / 5, 1.0),
      weight: 0.3, // 30% of total score
      details: `${sufficiency.totalFacts} facts, ${(sufficiency.noveltyRate * 100).toFixed(1)}% novelty`,
    });
    
    // 3. No recent tool calls (low weight)
    const noRecentTools = !step.toolCalls || step.toolCalls.length === 0;
    scores.push({
      signal: 'no_recent_tools',
      score: noRecentTools ? 1.0 : 0.0,
      weight: 0.1, // 10% of total score
      details: noRecentTools ? 'No tools called' : `${step.toolCalls.length} tools called`,
    });
    
    // 4. Agent signaled completion (medium weight)
    const finishCalled = step.toolCalls?.some((c: any) => c.toolName === 'finish');
    scores.push({
      signal: 'explicit_finish',
      score: finishCalled ? 1.0 : 0.0,
      weight: 0.2, // 20% of total score
      details: finishCalled ? 'Finish tool called' : 'No finish signal',
    });
    
    // Calculate weighted score
    const totalWeight = scores.reduce((sum, s) => sum + s.weight, 0);
    const overallScore = scores.reduce((sum, s) => 
      sum + (s.score * s.weight), 
      0
    ) / totalWeight;
    
    const converged = overallScore >= this.CONVERGENCE_THRESHOLD;
    
    return {
      converged,
      overallScore,
      breakdown: scores,
    };
  }
  
  printDiagnostics(result: any) {
    console.log(`\n=== Convergence Check ===`);
    console.log(`Overall Score: ${(result.overallScore * 100).toFixed(1)}% (threshold: ${this.CONVERGENCE_THRESHOLD * 100}%)`);
    console.log(`Converged: ${result.converged ? 'YES ✓' : 'NO ✗'}`);
    console.log(`\nBreakdown:`);
    
    for (const score of result.breakdown) {
      const percentage = (score.score * 100).toFixed(0);
      const weight = (score.weight * 100).toFixed(0);
      console.log(`  ${score.signal}: ${percentage}% (weight: ${weight}%) - ${score.details}`);
    }
  }
}

// Usage
const detector = new CompositeConvergenceDetector();

const onStepFinish = async (step: any, context: AgentContext) => {
  const result = await detector.checkConvergence(goal, context, step);
  
  detector.printDiagnostics(result);
  
  if (result.converged) {
    console.log('✓ Task converged successfully!');
    return { shouldContinue: false };
  }
  
  // Log how close we are
  const remaining = (1 - result.overallScore) * 100;
  console.log(`  → ${remaining.toFixed(1)}% away from convergence`);
  
  return { shouldContinue: true };
};
```

**Example Output**:
```
=== Convergence Check ===
Overall Score: 82.5% (threshold: 75%)
Converged: YES ✓

Breakdown:
  goal_state: 100% (weight: 50%) - 3/3 criteria met
  information_sufficiency: 80% (weight: 30%) - 8 facts, 15.3% novelty
  no_recent_tools: 100% (weight: 10%) - No tools called
  explicit_finish: 0% (weight: 20%) - No finish signal

✓ Task converged successfully!
```

**Advantages of multi-criteria**:
- ✅ More robust than single signal
- ✅ Provides detailed diagnostics
- ✅ Tunable weights per task type
- ✅ Graceful degradation (partial scores)

---

## Production Implementation

### Integration with AI SDK

```typescript
// File: server/agent/convergence.ts

export interface ConvergenceConfig {
  method: 'explicit' | 'goal_state' | 'multi_criteria';
  threshold: number; // For multi-criteria
  goal?: TaskGoal; // For goal-state method
}

export const DEFAULT_CONVERGENCE_CONFIG: ConvergenceConfig = {
  method: 'multi_criteria',
  threshold: 0.75,
};

export const runAgentWithConvergence = async (
  prompt: string,
  context: AgentContext,
  config: ConvergenceConfig = DEFAULT_CONVERGENCE_CONFIG
) => {
  const detector = createDetector(config);
  let converged = false;
  let result: any;
  
  const onStepFinish = async (step: any) => {
    // Check convergence
    const convergenceResult = await detector.checkConvergence(step, context);
    
    if (convergenceResult.converged) {
      converged = true;
      console.log('✓ Task converged:', convergenceResult);
      return { shouldContinue: false };
    }
    
    // Continue
    console.log(`Progress: ${(convergenceResult.score * 100).toFixed(1)}%`);
    return { shouldContinue: true };
  };
  
  try {
    result = await generateText({
      model: openai('gpt-4o'),
      prompt,
      tools: ALL_TOOLS,
      maxSteps: 20,
      onStepFinish,
      experimental_context: context,
    });
    
    return {
      success: true,
      convergedEarly: converged,
      stepsUsed: result.steps,
      result: result.text,
    };
  } catch (error) {
    throw error;
  }
};

function createDetector(config: ConvergenceConfig) {
  switch (config.method) {
    case 'explicit':
      return new ExplicitFinishDetector();
    case 'goal_state':
      return new GoalStateVerifier();
    case 'multi_criteria':
      return new CompositeConvergenceDetector(config.threshold);
    default:
      throw new Error(`Unknown convergence method: ${config.method}`);
  }
}
```

---

## Best Practices

### DO ✅

1. **Use multiple signals**: Combine explicit + goal-state + information sufficiency
2. **Verify state**: Don't trust agent's claim of completion without verification
3. **Provide feedback**: Tell agent how close to completion it is
4. **Set clear criteria**: Define success upfront when possible
5. **Log convergence attempts**: Track why agent thought it was done
6. **Adjust weights**: Tune multi-criteria weights per task type
7. **Return partial results**: Even if not fully converged, return what was achieved
8. **Celebrate early completion**: Save costs when task finishes before max steps

### DON'T ❌

1. **Don't rely on single signal**: Agent might prematurely call finish
2. **Don't skip verification**: Always check if goal actually met
3. **Don't ignore false positives**: Track premature convergence cases
4. **Don't use same criteria for all tasks**: Different tasks need different signals
5. **Don't forget logging**: Need data to tune convergence thresholds
6. **Don't make it too strict**: Perfect convergence may be impossible
7. **Don't waste API calls**: If clearly converged, stop immediately
8. **Don't confuse with stuck detection**: Convergence = success, stuck = failure

---

## Performance Metrics

### Tracking Convergence Quality

```typescript
interface ConvergenceMetrics {
  requestId: string;
  convergedEarly: boolean; // Before max steps?
  stepsToConvergence: number;
  verifiedCorrect: boolean; // Was convergence legitimate?
  falsePositive: boolean; // Claimed done but wasn't
  cost: number;
  timeSaved: number; // vs. running to max steps
}

class ConvergenceMetricsCollector {
  metrics: ConvergenceMetrics[] = [];
  
  record(metric: ConvergenceMetrics) {
    this.metrics.push(metric);
  }
  
  getStats() {
    const total = this.metrics.length;
    const earlyConvergence = this.metrics.filter(m => m.convergedEarly).length;
    const falsePositives = this.metrics.filter(m => m.falsePositive).length;
    const avgSteps = this.metrics.reduce((sum, m) => sum + m.stepsToConvergence, 0) / total;
    const totalTimeSaved = this.metrics.reduce((sum, m) => sum + m.timeSaved, 0);
    
    return {
      totalRequests: total,
      earlyConvergenceRate: (earlyConvergence / total * 100).toFixed(1) + '%',
      falsePositiveRate: (falsePositives / total * 100).toFixed(1) + '%',
      avgStepsToConvergence: avgSteps.toFixed(1),
      totalTimeSavedMs: totalTimeSaved,
    };
  }
}
```

**Target metrics**:
- Early convergence rate: >50% (saves costs)
- False positive rate: <5% (high accuracy)
- Average steps to convergence: 60-70% of max steps

---

## Summary

### Key Takeaways

1. **Multi-signal is best**: Combine explicit + goal-state + information sufficiency
2. **Verify objectively**: Don't trust agent's judgment alone
3. **Saves significant cost**: Early stopping reduces unnecessary steps
4. **Task-specific tuning**: Different tasks need different convergence criteria
5. **Track false positives**: Monitor premature convergence cases
6. **96.5% converge in 3 iterations**: With proper verification (research finding)

### Convergence Strategy Quick Reference

```typescript
const CONVERGENCE_STRATEGIES = {
  // Execution tasks (CMS, APIs)
  execution: {
    method: 'goal_state',
    verifyEveryStep: true,
    threshold: 0.9, // High confidence required
  },
  
  // Research/analysis tasks
  research: {
    method: 'multi_criteria',
    signals: ['information_sufficiency', 'entropy', 'explicit_finish'],
    threshold: 0.75, // Medium confidence OK
  },
  
  // Simple Q&A
  qa: {
    method: 'explicit',
    requireFinishTool: true,
    verifyAnswer: false, // Trust agent
  },
};
```

---

## Research Citations

1. **Plan Verification Paper** - "Plan Verification for LLM-Based Embodied Task Completion Agents" (2025)  
   https://arxiv.org/html/2509.02761v1

2. **ReflAct** - "World-Grounded Decision Making in LLM Agents via Goal-State Reflection" (May 2025)  
   https://arxiv.org/abs/2505.15182

3. **HALT-CoT** - "Model-Agnostic Early Stopping for Chain-of-Thought Reasoning via Answer Entropy" (Jul 2025)  
   https://openreview.net/pdf?id=CX5c7C1CZa

4. **VeriLA** - "A Human-Centered Evaluation Framework for Interpretable Verification of LLM Agent Failures" (Mar 2025)  
   https://arxiv.org/pdf/2503.12651

5. **PIPA** - "A Unified Evaluation Protocol for Diagnosing Interactive Planning Agents" (May 2025)  
   https://arxiv.org/abs/2505.01592

---

**Next Steps**:

- Read [3.4.5 - Early Exit Strategies](./3.4.5-early-exit.md) for adaptive stopping optimization
- Read [3.4.3 - Stuck Detection](./3.4.3-stuck-detection.md) for failure prevention
- Read [3.4.1 - Max Steps Limits](./3.4.1-max-steps.md) for hard bounds
