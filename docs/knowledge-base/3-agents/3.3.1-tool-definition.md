# 3.3.1 - Tool Definition

> **Layer**: Agent Architecture | **Topic**: Tool System
> **Version**: 2.0 | **Date Verified**: December 2025

---

## TL;DR

**Tool definitions are the contract between LLMs and executable functions.** Well-structured tools with clear descriptions, Zod schemas, and proper validation enable agents to select and invoke the right tools reliably.

### Key Takeaways

- **Descriptions > Names**: LLMs read descriptions to decide when to use tools—be specific about WHEN, not just WHAT
- **Zod schemas** provide type safety AND runtime validation in one place
- **Clear parameter descriptions** reduce tool call errors by 60-80%
- **Structured error responses** help agents recover from failures
- **AI SDK v6** uses `inputSchema` (not `parameters`) and `experimental_context` for dependency injection

---

## Why It Matters

### The Problem

Poor tool definitions lead to:

- **Wrong tool selection**: Agent picks `update_page` when it should use `create_page`
- **Invalid parameters**: LLM guesses wrong types or formats
- **Silent failures**: Agent doesn't know tool failed
- **Frustrated users**: Requests take multiple retries

### Research Evidence

| Finding | Source | Year |
|---------|--------|------|
| Clear schemas reduce errors by **60-80%** | Scalifiai | Oct 2025 |
| Input validation prevents **85%** of runtime errors | Production metrics | 2025 |
| Distinct keywords in descriptions reduce confusion by **40%** | OpenAI Community | 2024 |
| Function descriptions are **more important than names** | Prompt Engineering Guide | 2024 |

---

## Core Concepts

### Tool Anatomy

Every tool has three pillars:

```
┌─────────────────────────────────────────────────────┐
│                    TOOL DEFINITION                   │
├─────────────────────────────────────────────────────┤
│  1. DESCRIPTION                                      │
│     ↳ When to use, what it does, what it returns    │
│                                                      │
│  2. INPUT SCHEMA (Zod)                              │
│     ↳ Parameters with types and descriptions        │
│                                                      │
│  3. EXECUTE FUNCTION                                │
│     ↳ Implementation with validation                │
└─────────────────────────────────────────────────────┘
```

### Description Best Practices

```typescript
// ❌ BAD: Vague, no guidance
description: 'Gets a page from the CMS'

// ✅ GOOD: Specific about WHEN, WHAT, and OUTPUT
description: `Retrieves detailed information about a CMS page by ID or slug.
              Use this when the user wants to view, inspect, or reference page content.
              Returns title, content, metadata, and publication status.`
```

**Template:**
```
[ACTION VERB] [WHAT] [with/by PARAMETERS].
Use this when [USER INTENT / SCENARIO].
Returns [OUTPUT FORMAT].
[Constraints or warnings].
```

### Input Schema Patterns

```typescript
import { z } from 'zod';

// Required field with validation
z.string().min(1, 'Cannot be empty').describe('Unique page identifier')

// Optional with default
z.string().default('summary').describe('Fetch mode')

// Enum for limited choices (preferred over free-form strings)
z.enum(['draft', 'published', 'archived']).describe('Publication status')

// Complex objects
z.object({
  title: z.string().describe('Page title'),
  content: z.string().optional().describe('Page content (HTML/Markdown)'),
})
```

---

## Implementation Guide

### Step-by-Step

#### 1. Define the Tool (AI SDK v6)

```typescript
// server/tools/cms/get-page.ts
import { tool } from 'ai';
import { z } from 'zod';
import type { AgentContext } from '@/types';

export const cms_getPage = tool({
  // 1. Clear, specific description
  description: `Retrieves CMS page by ID or slug with optional content fetching.
                Use when user wants to view, inspect, or reference page content.
                Returns page object with title, content, metadata, and status.`,

  // 2. Zod schema (AI SDK v6 uses inputSchema)
  inputSchema: z.object({
    identifier: z.string()
      .min(1, 'Identifier required')
      .describe('Page ID or slug (e.g., "about" or "page-123")'),

    fetchMode: z.enum(['summary', 'full'])
      .default('summary')
      .describe('summary = metadata only, full = with content'),
  }),

  // 3. Execute with context injection
  execute: async ({ identifier, fetchMode }, { experimental_context }) => {
    const ctx = experimental_context as AgentContext;

    try {
      const page = await ctx.cmsService.getPage(identifier, fetchMode);

      if (!page) {
        return {
          error: 'Page not found',
          identifier,
          suggestion: 'Check the page ID/slug or use cms_listPages to find available pages',
        };
      }

      return {
        success: true,
        page,
      };
    } catch (error) {
      return {
        error: error.message,
        suggestion: 'Verify the identifier format and try again',
      };
    }
  },
});
```

#### 2. Handle Mutations with Validation

```typescript
export const cms_createPage = tool({
  description: `Creates a new CMS page with title and optional content.
                Use when user explicitly requests page creation.
                Returns created page object with generated ID.`,

  inputSchema: z.object({
    title: z.string().min(1).max(200).describe('Page title'),
    slug: z.string()
      .regex(/^[a-z0-9-]+$/, 'Slug must be lowercase alphanumeric with hyphens')
      .optional()
      .describe('URL slug (auto-generated from title if omitted)'),
    content: z.string().optional().describe('Initial page content'),
    status: z.enum(['draft', 'published']).default('draft'),
  }),

  execute: async (input, { experimental_context }) => {
    const ctx = experimental_context as AgentContext;

    // Validate slug uniqueness (business rule)
    if (input.slug) {
      const existing = await ctx.cmsService.findBySlug(input.slug);
      if (existing) {
        return {
          error: `Page with slug "${input.slug}" already exists`,
          existingPage: { id: existing.id, title: existing.title },
          suggestion: `Try "${input.slug}-2" or choose a different slug`,
        };
      }
    }

    const page = await ctx.cmsService.createPage(input);

    return {
      success: true,
      page,
      message: `Created page "${page.title}" with ID ${page.id}`,
    };
  },
});
```

#### 3. Structured Error Responses

```typescript
// Always return structured errors that help agents recover
interface ToolError {
  error: string;           // What went wrong
  field?: string;          // Which parameter caused issue
  suggestion?: string;     // How to fix it
  validValues?: any[];     // If enum, show valid options
}

// Example error response
return {
  error: 'Invalid status value',
  field: 'status',
  suggestion: 'Choose from: draft, published, or archived',
  validValues: ['draft', 'published', 'archived'],
};
```

---

## Framework Integration

### AI SDK v6 Pattern

```typescript
import { generateText, tool, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';

// Define context type
interface AgentContext {
  cmsService: CMSService;
  userId: string;
  sessionId: string;
}

// Run agent with tools and context
const result = await generateText({
  model: openai('gpt-4o'),
  prompt: userMessage,

  // Tool definitions
  tools: {
    cms_getPage,
    cms_createPage,
    cms_updatePage,
  },

  // Context injection (available in tool execute)
  experimental_context: {
    cmsService: new CMSService(db),
    userId: session.userId,
    sessionId: session.id,
  } satisfies AgentContext,

  // Multi-step execution (v6 uses stopWhen)
  stopWhen: stepCountIs(15),
});
```

### Key v6 Changes from v4/v5

| Feature | v4/v5 | v6 |
|---------|-------|-----|
| Parameters | `parameters` | `inputSchema` |
| Max steps | `maxSteps: 10` | `stopWhen: stepCountIs(10)` |
| Context | `experimental_context` | `experimental_context` (same) |
| Tool result content | `experimental_toToolResultContent` | `toModelOutput` |

---

## Testing Strategy

### Unit Testing Tools

```typescript
// server/tools/__tests__/cms-get-page.test.ts
import { describe, it, expect, vi } from 'vitest';
import { cms_getPage } from '../cms/get-page';

describe('cms_getPage', () => {
  const mockContext = {
    cmsService: {
      getPage: vi.fn(),
    },
    userId: 'test-user',
    sessionId: 'test-session',
  };

  it('returns page when found', async () => {
    mockContext.cmsService.getPage.mockResolvedValue({
      id: 'page-1',
      title: 'About Us',
      content: '<p>Content</p>',
    });

    const result = await cms_getPage.execute(
      { identifier: 'about', fetchMode: 'full' },
      { experimental_context: mockContext }
    );

    expect(result.success).toBe(true);
    expect(result.page.title).toBe('About Us');
    expect(mockContext.cmsService.getPage).toHaveBeenCalledWith('about', 'full');
  });

  it('returns structured error when not found', async () => {
    mockContext.cmsService.getPage.mockResolvedValue(null);

    const result = await cms_getPage.execute(
      { identifier: 'nonexistent', fetchMode: 'summary' },
      { experimental_context: mockContext }
    );

    expect(result.error).toBe('Page not found');
    expect(result.suggestion).toBeDefined();
  });
});
```

### Schema Validation Testing

```typescript
it('validates input schema', () => {
  const schema = cms_getPage.inputSchema;

  // Valid input
  expect(() => schema.parse({ identifier: 'about' })).not.toThrow();

  // Invalid: empty identifier
  expect(() => schema.parse({ identifier: '' })).toThrow();

  // Invalid: wrong fetchMode
  expect(() => schema.parse({ identifier: 'x', fetchMode: 'invalid' })).toThrow();
});
```

---

## Common Pitfalls

### ❌ Avoid

| Pitfall | Problem | Solution |
|---------|---------|----------|
| Vague descriptions | LLM picks wrong tool | Be specific: WHEN, WHAT, OUTPUT |
| No parameter descriptions | Invalid inputs | Describe every parameter |
| Generic errors | Agent can't recover | Return structured errors with suggestions |
| Overlapping tool names | Tool confusion | Use distinct keywords |
| Trusting LLM output | Runtime failures | Validate inputs in execute function |

### ✅ Best Practices

1. **Write descriptions first** - If you can't explain when to use it, the LLM won't know either
2. **Use enums over strings** - Constrain choices to valid options
3. **Provide defaults** - Reduce required parameters where sensible
4. **Test with real prompts** - Verify LLM selects the right tool
5. **Version carefully** - Add optional params, don't remove existing ones

---

## Summary

### Quick Reference

```typescript
// Tool Definition Template
export const myTool = tool({
  // 1. Specific description with WHEN, WHAT, OUTPUT
  description: `[ACTION] [WHAT] [with/by PARAMS].
                Use when [SCENARIO].
                Returns [OUTPUT FORMAT].`,

  // 2. Zod schema with descriptions
  inputSchema: z.object({
    requiredField: z.string().describe('What this field is'),
    optionalField: z.string().default('value').describe('Optional with default'),
    choiceField: z.enum(['a', 'b', 'c']).describe('Limited choices'),
  }),

  // 3. Execute with context and error handling
  execute: async (input, { experimental_context }) => {
    const ctx = experimental_context as AgentContext;

    try {
      const result = await ctx.service.doSomething(input);
      return { success: true, data: result };
    } catch (error) {
      return {
        error: error.message,
        suggestion: 'How to fix this',
      };
    }
  },
});
```

### Decision Tree

```
When defining a tool:

1. Can you explain WHEN to use it in one sentence?
   ├─ No → Refine the tool's purpose
   └─ Yes → Write that sentence as the first line of description

2. Does each parameter have a clear description?
   ├─ No → Add .describe() to each Zod field
   └─ Yes → Continue

3. Are there limited valid values?
   ├─ Yes → Use z.enum() instead of z.string()
   └─ No → Add validation (min, max, regex)

4. What happens on failure?
   ├─ Generic error → Add structured error with suggestion
   └─ Structured → Good to go
```

---

## Related Topics

- [3.3.2 - Tool Registry](./3.3.2-tool-registry.md) - Organizing and discovering tools at scale
- [3.3.3 - Context Injection](./3.3.3-context-injection.md) - Passing runtime dependencies to tools
- [3.3.4 - Result Validation](./3.3.4-result-validation.md) - Verifying tool execution succeeded
- [3.3.5 - Tool Composition](./3.3.5-composition.md) - Chaining tools together

---

## Research Citations

1. **Scalifiai** - "Best Practices for Function Calling in LLMs in 2025" (Oct 2025)
   https://www.scalifiai.com/blog/function-calling-tool-call-best%20practices

2. **CodeWithCaptain** - "LLM Function Calling Best Practices: Build Reliable Agents" (Nov 2025)
   https://codewithcaptain.com/llm-function-calling-best-practices/

3. **QuotientAI** - "Evaluating Tool Calling Capabilities in LLMs" (May 2025)
   https://blog.quotientai.co/evaluating-tool-calling-capabilities-in-large-language-models

4. **OpenAI Community** - "Best Practices for Improving Assistants' Function Calling Reasoning" (2024)
   https://community.openai.com/t/best-practices-for-improving-assistants-function-calling-reasoning

5. **AI SDK v6 Documentation** - "Tools and Tool Calling" (2025)
   https://v6.ai-sdk.dev/docs/ai-sdk-core/tools-and-tool-calling
