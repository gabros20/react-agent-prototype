# 3.2.4 - Observation Phase

## TL;DR
The observation phase interprets tool results, extracts key data, updates agent context/memory, and decides whether to continue the ReAct loop or return the final answer. This phase bridges execution and reasoning, making tool outcomes actionable for next steps.

**Prerequisites**: [3.2.3 Acting Phase]
**Key Research**: Observation Integration (ReAct, 2022), Memory Updates (Episodic Memory, 2024)

---

## What is Observation?

Observation is the **interpretation phase** where agent learns from tool results.

### Simple Example

```
Agent Action: cms_findResource(query: "about")
Tool Result: [
  {id: "page-456", slug: "about-us", score: 0.95},
  {id: "page-789", slug: "about-team", score: 0.75}
]

Agent Observation:
"Found 2 pages matching 'about'. Most likely is page-456
 (about-us, 95% confidence). Will use this going forward."

Agent Memory Update:
  context.pageId = "page-456"
  context.pageSlug = "about-us"
  context.matchConfidence = 0.95
```

---

## The Observation Loop

### Three-Step Process

```
┌────────────────────────────────────┐
│ CAPTURE RESULT                     │
│ Tool returned data from execute()  │
│                                    │
│ Example: {id: "page-456"}          │
└──────────────┬─────────────────────┘
               │
               ▼
┌────────────────────────────────────┐
│ EXTRACT KEY DATA                   │
│ Pull out actionable information    │
│                                    │
│ Example: ID = page-456             │
│          Slug = about-us           │
│          Matched = Yes             │
└──────────────┬─────────────────────┘
               │
               ▼
┌────────────────────────────────────┐
│ UPDATE CONTEXT                     │
│ Store in working memory            │
│ Inform next thought                │
│                                    │
│ Example: page-456 now in memory    │
│ Next thought can reference it      │
└────────────────────────────────────┘
```

---

## Observation Formats

### Format 1: Simple (Quick Feedback)

**For**: Straightforward results, obvious next step

```
Thought: I need page ID

Action: cms_findResource(query: "about")

Observation: ✅ Found page-456 (about-us, 95% match)

Thought: Great, now I'll get its sections...
```

**When to use**:
- ✅ Results are unambiguous
- ✅ Only one valid interpretation
- ✅ Obvious next action

---

### Format 2: Structured (Complex Results)

**For**: Multiple results, requires analysis

```
Action: cms_findResource(query: "about")

Observation:
  [STATUS] ✅ Success - 2 results found
  [KEY DATA] Top match: page-456 (slug: about-us, score: 0.95)
  [ALTERNATIVES] page-789 (slug: about-team, score: 0.75)
  [DECISION] Using page-456 (highest confidence)
  [NEXT STEP] Will fetch page sections

Thought: Now I have the page ID. Let me get sections...
```

**When to use**:
- ✅ Multiple results to evaluate
- ✅ Ambiguous matches
- ✅ Need to show reasoning
- ✅ Debugging failures

---

### Format 3: Error Analysis (Failures)

**For**: When tool returns error

```
Action: cms_getPage(slug: "about")

Observation:
  [STATUS] ❌ FAILED - 404 Not found
  [ERROR] "Page with slug 'about' not found"
  [ANALYSIS] Slug might be incorrect or page deleted
  [RECOVERY] Will use fuzzy search instead
  [CONFIDENCE] 70% this will work

Thought: Exact match failed. Let me try fuzzy search...
```

---

## Memory & Context Management

### What to Store in Memory

```
Working Memory Contents:
┌──────────────────────────────┐
│ Recent Pages                 │
├──────────────────────────────┤
│ page-456: about-us           │ ← Most recent
│ page-123: home               │
│ page-789: contact            │
└──────────────────────────────┘

Timestamp: Updated on each observation

Usage: Resolve pronouns like "update that page"
       → "that page" = most recent = page-456
```

### Your Implementation

From `react.xml`:

```xml
**REFERENCE RESOLUTION:**
- When user mentions "this page", "that section", "it", "them"
- Check WORKING MEMORY above
- WORKING MEMORY shows recently accessed resources
- Use MOST RECENT resource of appropriate type

Example: User says "what sections are on this page?"
→ Check working memory for most recent page
→ page-456 (about-us) is most recent
→ Answer: "[sections on page-456]"
```

**Implementation**: Update memory after each observation

```typescript
// After tool execution
const observation = await tool.execute(input);

// Extract and update memory
if (observation.data) {
  const entities = entityExtractor.extract(toolName, observation.data);

  entities.forEach(entity => {
    // Entity: {type: "page", id: "page-456", slug: "about-us"}
    workingMemory.add(entity, { timestamp: Date.now() });
  });
}
```

---

## Loop Control Decision

### Key Question: Continue or Complete?

```
After each observation, decide:

Observation: Tool returned page ID

Decision Tree:
├─ Do I have enough to answer user?
│  ├─ YES → Return FINAL_ANSWER
│  └─ NO → Continue loop
│
├─ Did tool fail?
│  ├─ YES → Attempt RECOVERY
│  └─ NO → Check goal progress
│
└─ Is there a clear next step?
   ├─ YES → Loop again with new thought
   └─ NO → Ask for clarification or return result
```

---

## Loop Termination Conditions

### When to Stop and Return Answer

```
✅ COMPLETE - Task is done:
  - Goal achieved
  - All required information gathered
  - User question fully answered

❌ FAILED - Can't complete:
  - Max iterations reached (10)
  - Unrecoverable error
  - User must clarify

⏸️ WAITING - Need user input:
  - Ambiguous situation
  - Destructive operation (confirmation)
  - Missing information only user can provide
```

### Your Implementation

From `react.xml`:

```xml
**CORE LOOP:**
Think → Act → Observe → Repeat until completion

Think step-by-step:
1. Analyze the question
2. Execute ONE tool
3. Observe the result
4. Continue until you have enough information
   OR the task is complete
5. Provide final answer
```

**Implicitly**: When you have enough info, stop looping.

---

## Observation Examples

### Example 1: Simple Success

```
User: "What's the name of the about page?"

Thought: I need to find the about page

Action: cms_findResource(query: "about", resourceType: "page")

Observation: ✅ Found page-456 with name "About Us"

Thought: I have the answer now

Final Answer: "The about page is named 'About Us'"

[Loop ends after 1 iteration]
```

---

### Example 2: Multi-Step with Memory

```
User: "Create a page called 'Services' with hero and features sections"

Iteration 1:
  Thought: Need to create page first
  Action: cms_createPage(slug: "services", name: "Services")
  Observation: ✅ Created page-999
  Memory: {page: page-999}
  Decision: Continue (need to add sections)

Iteration 2:
  Thought: Now I'll add hero section to page-999
  Action: cms_findSectionDef(query: "hero")
  Observation: ✅ Found hero-def-1
  Memory: {section_def: hero-def-1}
  Decision: Continue (need to add to page)

Iteration 3:
  Thought: Add hero-def-1 to page-999
  Action: cms_addSectionToPage(pageId: "page-999", sectionDefId: "hero-def-1")
  Observation: ✅ Added, returned section-2001
  Memory: {section: section-2001}
  Decision: Continue (still need features)

Iteration 4:
  Thought: Add features section
  Action: cms_findSectionDef(query: "features")
  Observation: ✅ Found features-def-2
  Decision: Continue (add to page)

Iteration 5:
  Action: cms_addSectionToPage(pageId: "page-999", sectionDefId: "features-def-2")
  Observation: ✅ Added, returned section-2002
  Decision: Task complete

Final Answer: "Created Services page with hero and features sections"

[Loop ends after 5 iterations]
```

---

### Example 3: Error Recovery

```
User: "Update the hero section on the about page"

Iteration 1:
  Thought: Need page ID first
  Action: cms_getPage(slug: "about")
  Observation: ❌ ERROR 404 - Page not found
  Analysis: Slug might be wrong
  Decision: Try fuzzy search

Iteration 2:
  Thought: Exact slug failed. Using fuzzy search.
  Action: cms_findResource(query: "about", resourceType: "page")
  Observation: ✅ Found page-456 (about-us, 95% match)
  Memory: {page: page-456}
  Decision: Continue (got page ID now)

Iteration 3:
  Thought: Get page sections
  Action: cms_getPageSections(pageId: "page-456")
  Observation: ✅ Found 3 sections: hero, features, team
  Memory: {sections: [...]}
  Decision: Ready to update hero

Iteration 4:
  Thought: Update hero section
  Action: cms_updateSection(sectionId: "hero", content: {...})
  Observation: ✅ Updated successfully
  Decision: Task complete

Final Answer: "Updated the hero section on the about page"

[Loop ends after 4 iterations, recovered from error]
```

---

## Data Extraction Patterns

### Pattern 1: Single Value

```
Tool Result: {id: "page-456", name: "About Us", ...}

Extraction:
  Key value: id = "page-456"

Observation: "Got page ID: page-456"
```

### Pattern 2: Multiple Options

```
Tool Result: [
  {id: "page-456", slug: "about-us", score: 0.95},
  {id: "page-789", slug: "about-team", score: 0.75}
]

Extraction:
  Top result: page-456 (confidence: 95%)
  Alternative: page-789 (confidence: 75%)

Observation: "Found about-us (95%) and about-team (75%).
             Using about-us as primary choice."
```

### Pattern 3: Nested Data

```
Tool Result: {
  page: {
    id: "page-456",
    sections: [
      {id: "sec-1", name: "Hero", type: "hero"},
      {id: "sec-2", name: "Features", type: "features"}
    ]
  }
}

Extraction:
  Page ID: page-456
  Section count: 2
  Section names: ["Hero", "Features"]

Observation: "Page has 2 sections: Hero and Features.
             IDs: sec-1 (hero), sec-2 (features)"
```

---

## Token Management in Observations

### Observation Length Trade-offs

```
Brief Observation (~100 tokens):
  "Got page ID: page-456"
  + Fast processing
  - Loses context detail

Detailed (~300 tokens):
  "Found 2 matching pages. Top: page-456 (about-us,
   95% confidence). Alternative: page-789 (about-team,
   75%). Using page-456 as it best matches query."
  + Maintains reasoning context
  - Uses more tokens

Recommendation: Match observation verbosity to task complexity
- Simple task → Brief
- Complex multi-step → Detailed
```

---

## Observation Best Practices

### Checklist

```
□ Did the tool succeed or fail?
□ What is the key data I need?
□ How does this move me toward the goal?
□ Should I continue or stop looping?
□ What should I remember for next iteration?
□ Are there alternative interpretations?
```

### Common Mistakes

| Mistake | Impact | Fix |
|---------|--------|-----|
| Ignoring error details | Wrong recovery | Analyze error message |
| Over-extracting data | Token waste | Extract only key info |
| Losing context | Loop inefficiency | Update working memory |
| Wrong termination | Incomplete task | Verify goal achievement |
| Not updating memory | Reference resolution fails | Store in working memory |

---

## Integration with ReAct Loop

### Full Cycle Example

```
USER: "What pages do we have?"

┌─────────────────┐
│ THOUGHT (1)     │  "I need to list all pages"
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ ACTION (1)      │  cms_listPages()
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────────────────┐
│ OBSERVATION (1)                             │
│ Got list of 5 pages:                        │
│ - page-123: home                            │
│ - page-456: about-us                        │
│ - page-789: contact                         │
│ - page-111: services                        │
│ - page-222: blog                            │
│                                             │
│ Memory updated with all pages               │
│ All info to answer question present         │
│ → Decision: Task complete                   │
└────────┬────────────────────────────────────┘
         │
         ▼
┌──────────────────────────┐
│ FINAL_ANSWER             │
│ "We have 5 pages:        │
│  1. Home                 │
│  2. About Us             │
│  3. Contact              │
│  4. Services             │
│  5. Blog"                │
└──────────────────────────┘

[Loop ends - task complete]
```

---

## References

1. Yao et al. (2022). "ReAct: Synergizing Reasoning and Acting"
2. Episodic Memory in AI Systems (2024)
3. Working Memory Best Practices (LangChain, 2024)
4. Error Analysis Patterns (2024 agent research)

---

**Status**: Complete
**Word Count**: ~2,300
**Last Updated**: November 21, 2025
