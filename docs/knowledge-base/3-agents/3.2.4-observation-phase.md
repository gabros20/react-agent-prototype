# 3.2.4 - Observation Phase: Learn from Results

## TL;DR

The observation phase interprets tool results, extracts actionable data, updates working memory, and decides whether to continue looping or return the final answer. This "OBSERVE" step bridges execution and reasoning—without proper observation handling, agents repeat mistakes and lose context across iterations.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-03
- **Prerequisites**: [3.2.3 Acting Phase](./3.2.3-acting-phase.md)
- **Grounded In**: ReAct (Yao et al., 2022), Episodic Memory Systems (2024)

## Table of Contents

- [Overview](#overview)
- [The Problem](#the-problem-lost-context)
- [Core Concept](#core-concept)
- [Observation Patterns](#observation-patterns)
- [Memory Integration](#memory-integration)
- [Loop Control](#loop-control)
- [Framework Integration](#framework-integration)
- [Common Failures](#common-failures)
- [Trade-offs & Considerations](#trade-offs--considerations)
- [Key Takeaways](#key-takeaways)
- [References](#references)

## Overview

Observation is the interpretation phase where the agent learns from tool execution results and updates its understanding before the next reasoning step.

**The Observation Flow**:

```
┌─────────────────────────────────────────────────────────────┐
│                    OBSERVATION PHASE                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. CAPTURE                                                  │
│     └─ Receive raw tool result from execute()                │
│                                                              │
│  2. INTERPRET                                                │
│     ├─ Success or failure?                                   │
│     ├─ What is the key data?                                 │
│     └─ Any unexpected outcomes?                              │
│                                                              │
│  3. EXTRACT                                                  │
│     ├─ Pull actionable information                           │
│     ├─ Identify entities (IDs, names, relationships)         │
│     └─ Note alternatives if multiple matches                 │
│                                                              │
│  4. UPDATE MEMORY                                            │
│     ├─ Store entities in working memory                      │
│     ├─ Update context for next iteration                     │
│     └─ Enable pronoun resolution ("this page", "that item")  │
│                                                              │
│  5. DECIDE                                                   │
│     ├─ Goal achieved? → Return final answer                  │
│     ├─ Need more steps? → Continue loop                      │
│     └─ Error? → Attempt recovery or escalate                 │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

## The Problem: Lost Context

### Agents Without Observation Management

When agents don't properly process observations:

1. **Lost entity references** - Can't resolve "update that page" without memory
2. **Repeated failures** - Same error, same approach, infinite loop
3. **Context drift** - Agent forgets what it discovered earlier
4. **Premature termination** - Stops before task is actually complete

**Example: Agent Without Memory**

```
User: "Create a page and add a hero section to it"

Iteration 1:
  Action: createPage(name: "Services")
  Result: {id: "page-123", name: "Services"}

Iteration 2:
  Action: addSection(pageId: ???, type: "hero")
  → ERROR: pageId is undefined

Agent forgot page-123 from previous step!
```

**Example: Agent With Memory**

```
User: "Create a page and add a hero section to it"

Iteration 1:
  Action: createPage(name: "Services")
  Result: {id: "page-123", name: "Services"}
  Observation: Created page-123
  Memory Update: {recentPage: "page-123"}

Iteration 2:
  Thought: I'll add hero to the page I just created (page-123)
  Action: addSection(pageId: "page-123", type: "hero")
  Result: {id: "section-456"}
  Decision: Task complete
```

## Core Concept

### What Happens in Observation

The observation phase has three core responsibilities:

**1. Result Interpretation**

```typescript
interface ToolResult {
  success: boolean;
  data?: unknown;
  error?: { code: string; message: string };
}

function interpretResult(result: ToolResult): Observation {
  if (!result.success) {
    return {
      status: 'failed',
      error: result.error,
      recoverable: isRecoverable(result.error),
    };
  }

  return {
    status: 'success',
    keyData: extractKeyData(result.data),
    entities: extractEntities(result.data),
  };
}
```

**2. Entity Extraction**

```typescript
interface Entity {
  type: 'page' | 'section' | 'image' | string;
  id: string;
  name?: string;
  metadata?: Record<string, unknown>;
}

function extractEntities(toolName: string, data: unknown): Entity[] {
  // Tool-specific extraction logic
  switch (toolName) {
    case 'getPage':
      return [{ type: 'page', id: data.id, name: data.name }];
    case 'listSections':
      return data.sections.map(s => ({ type: 'section', id: s.id, name: s.name }));
    default:
      return [];
  }
}
```

**3. Loop Decision**

```
After each observation:

┌─────────────────────────────────────┐
│ Do I have enough to answer user?    │
├──────────┬──────────────────────────┤
│   YES    │ Return FINAL_ANSWER      │
├──────────┼──────────────────────────┤
│   NO     │ Continue to next thought │
└──────────┴──────────────────────────┘

┌─────────────────────────────────────┐
│ Did tool fail?                      │
├──────────┬──────────────────────────┤
│   YES    │ Attempt RECOVERY         │
│          │ (alternative approach)   │
├──────────┼──────────────────────────┤
│   NO     │ Check goal progress      │
└──────────┴──────────────────────────┘

┌─────────────────────────────────────┐
│ Max iterations reached?             │
├──────────┬──────────────────────────┤
│   YES    │ Return partial result    │
│          │ or escalate to user      │
├──────────┼──────────────────────────┤
│   NO     │ Loop again               │
└──────────┴──────────────────────────┘
```

## Observation Patterns

### Pattern 1: Simple Success

For straightforward results with obvious next steps.

```
Thought: I need the about page ID

Action: findResource(query: "about", type: "page")

Result: {id: "page-456", slug: "about-us", score: 0.95}

Observation: ✅ Found page-456 (about-us)

Memory: {recentPage: "page-456"}

Thought: Now I can get its sections...
```

**Use when**:
- Results are unambiguous
- Only one valid interpretation
- Clear next action

### Pattern 2: Multiple Results

When tool returns alternatives requiring selection.

```
Action: findResource(query: "about")

Result: [
  {id: "page-456", slug: "about-us", score: 0.95},
  {id: "page-789", slug: "about-team", score: 0.72}
]

Observation:
  Status: ✅ Found 2 matches
  Top match: page-456 (about-us, 95% confidence)
  Alternative: page-789 (about-team, 72%)
  Decision: Using page-456 as primary match

Memory: {recentPage: "page-456", alternatives: ["page-789"]}

Thought: Found about-us with high confidence. Proceeding...
```

**Use when**:
- Multiple results returned
- Need to show selection reasoning
- Want to preserve alternatives

### Pattern 3: Error Recovery

When tool execution fails.

```
Action: getPage(slug: "about")

Result: {success: false, error: {code: "NOT_FOUND", message: "Page not found"}}

Observation:
  Status: ❌ Failed - 404 Not Found
  Error: Page with slug "about" doesn't exist
  Analysis: Exact slug might be wrong
  Recovery: Will try fuzzy search instead

Thought: Exact match failed. Let me search broadly...

Action: findResource(query: "about", type: "page")
```

**Error classification**:

| Error Type | Recovery Strategy |
|------------|-------------------|
| NOT_FOUND | Try fuzzy search or list all |
| VALIDATION | Fix input parameters |
| PERMISSION | Inform user, can't proceed |
| TIMEOUT | Retry once, then fail |
| RATE_LIMIT | Wait and retry |

### Pattern 4: Completion Check

Verify task is actually done before stopping.

```
User: "Create a contact page with a form section"

Iteration 3:
  Action: addSection(pageId: "page-123", type: "form")
  Result: {id: "section-789", type: "form"}

  Observation:
    Status: ✅ Section added

    Completion Check:
    [✓] Page created (page-123)
    [✓] Form section added (section-789)
    [✓] All user requirements met

    Decision: Task complete

  Final Answer: Created contact page with form section
```

## Memory Integration

### Working Memory Structure

```
┌─────────────────────────────────────────────────┐
│              WORKING MEMORY                      │
├─────────────────────────────────────────────────┤
│ Recent Pages (ordered by access time)            │
│ ├─ page-456: about-us        [2 min ago]        │
│ ├─ page-123: home            [5 min ago]        │
│ └─ page-789: contact         [8 min ago]        │
├─────────────────────────────────────────────────┤
│ Recent Sections                                  │
│ ├─ section-111: hero         [1 min ago]        │
│ └─ section-222: features     [3 min ago]        │
├─────────────────────────────────────────────────┤
│ Recent Operations                                │
│ ├─ UPDATE section-111        [1 min ago]        │
│ └─ CREATE page-456           [5 min ago]        │
└─────────────────────────────────────────────────┘

Pronoun Resolution:
  "this page"    → page-456 (most recent page)
  "that section" → section-111 (most recent section)
  "it"           → last referenced entity
```

### Memory Update Implementation

```typescript
class WorkingMemory {
  private entities: Map<string, Entity[]> = new Map();
  private maxPerType = 10;

  add(entity: Entity): void {
    const list = this.entities.get(entity.type) || [];

    // Add to front (most recent first)
    list.unshift({
      ...entity,
      accessedAt: Date.now(),
    });

    // Trim to max size
    if (list.length > this.maxPerType) {
      list.pop();
    }

    this.entities.set(entity.type, list);
  }

  getMostRecent(type: string): Entity | undefined {
    return this.entities.get(type)?.[0];
  }

  resolve(reference: string): Entity | undefined {
    // "this page" → most recent page
    if (reference.includes('page')) {
      return this.getMostRecent('page');
    }
    if (reference.includes('section')) {
      return this.getMostRecent('section');
    }
    // Generic "it" → last accessed anything
    return this.getLastAccessed();
  }

  toContextString(): string {
    let context = 'WORKING MEMORY:\n\n';

    for (const [type, entities] of this.entities) {
      context += `${type}s:\n`;
      entities.slice(0, 5).forEach(e => {
        context += `  - ${e.id}: ${e.name || 'unnamed'}\n`;
      });
      context += '\n';
    }

    return context;
  }
}
```

## Loop Control

### Termination Conditions

```typescript
type LoopDecision =
  | { action: 'continue'; reason: string }
  | { action: 'complete'; answer: string }
  | { action: 'failed'; error: string }
  | { action: 'clarify'; question: string };

function decideNextStep(
  observation: Observation,
  goal: string,
  stepCount: number,
  maxSteps: number
): LoopDecision {
  // Check iteration limit
  if (stepCount >= maxSteps) {
    return {
      action: 'failed',
      error: `Reached max iterations (${maxSteps}) without completing task`,
    };
  }

  // Check for errors
  if (observation.status === 'failed') {
    if (observation.recoverable) {
      return {
        action: 'continue',
        reason: `Error occurred, attempting recovery: ${observation.recovery}`,
      };
    }
    return {
      action: 'failed',
      error: observation.error.message,
    };
  }

  // Check goal completion
  if (isGoalAchieved(observation, goal)) {
    return {
      action: 'complete',
      answer: generateFinalAnswer(observation, goal),
    };
  }

  // Continue if progress made
  return {
    action: 'continue',
    reason: 'Progress made, more steps needed',
  };
}
```

### Complete vs Continue Examples

**Complete** - Goal Achieved:

```
Goal: "What's the homepage title?"

Action: getPage(slug: "home")
Result: {id: "page-1", name: "Welcome Home", title: "Welcome to Our Site"}

Observation: Got homepage with title "Welcome to Our Site"

Decision: COMPLETE
  - User asked for title
  - We have the title
  - No more steps needed

Final Answer: The homepage title is "Welcome to Our Site"
```

**Continue** - More Steps Needed:

```
Goal: "Update the hero section on the about page"

Action: getPage(slug: "about")
Result: {id: "page-456", sections: ["hero-123", "features-456"]}

Observation: Got about page with sections

Decision: CONTINUE
  - User wants to UPDATE hero section
  - We only FOUND the page so far
  - Still need to call updateSection

Next thought: Now I'll update the hero section (hero-123)...
```

**Failed** - Unrecoverable:

```
Goal: "Delete the admin page"

Action: deletePage(id: "admin-page")
Result: {success: false, error: {code: "FORBIDDEN", message: "Cannot delete system pages"}}

Observation: Delete failed - permission denied

Decision: FAILED
  - System page cannot be deleted
  - No recovery possible
  - Must inform user

Final Answer: Cannot delete the admin page - it's a protected system page.
```

## Framework Integration

### AI SDK v6: onStepFinish Hook

```typescript
import { ToolLoopAgent, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';

const workingMemory = new WorkingMemory();

const agent = new ToolLoopAgent({
  model: openai('gpt-4o'),
  instructions: `You are a helpful assistant.

WORKING MEMORY (recently accessed resources):
${workingMemory.toContextString()}

When user says "this page" or "that section", check working memory above.`,

  tools: { /* ... */ },
  stopWhen: stepCountIs(10),

  onStepFinish: async ({ step }) => {
    // Process each completed step
    for (const toolCall of step.toolCalls || []) {
      const result = step.toolResults?.find(r => r.toolCallId === toolCall.id);

      if (result?.success) {
        // Extract and store entities
        const entities = extractEntities(toolCall.toolName, result.data);
        entities.forEach(e => workingMemory.add(e));

        // Log for debugging
        console.log(`Observation: ${toolCall.toolName} returned ${entities.length} entities`);
      }
    }
  },
});
```

### Streaming Observations

```typescript
const stream = await agent.stream({ prompt: userMessage });

for await (const event of stream) {
  switch (event.type) {
    case 'tool-result':
      // Observation received
      const observation = interpretResult(event.result);

      // Update UI with observation
      emitToClient({
        type: 'observation',
        toolName: event.toolName,
        status: observation.status,
        summary: summarize(observation),
      });

      // Update memory
      observation.entities?.forEach(e => workingMemory.add(e));
      break;

    case 'text':
      // Agent reasoning/response
      emitToClient({ type: 'text', content: event.text });
      break;

    case 'finish':
      // Loop complete
      emitToClient({ type: 'complete', answer: event.text });
      break;
  }
}
```

## Common Failures

### Failure 1: Forgetting Context

**Symptom**: Agent can't reference earlier results

```
❌ BAD:
Step 1: Found page-456
Step 2: "I don't know which page to update"

✅ GOOD:
Step 1: Found page-456 → Memory: {recentPage: "page-456"}
Step 2: "I'll update page-456 from my memory"
```

**Fix**: Always update working memory after successful tool calls

### Failure 2: Ignoring Errors

**Symptom**: Agent continues as if nothing happened

```
❌ BAD:
Action: getPage(slug: "about")
Result: {error: "Not found"}
Thought: "Now I'll update the page content..."
→ Crash: No page to update

✅ GOOD:
Action: getPage(slug: "about")
Result: {error: "Not found"}
Observation: ❌ Page not found. Will try fuzzy search.
Action: findResource(query: "about")
```

**Fix**: Check result.success before proceeding

### Failure 3: Premature Completion

**Symptom**: Agent stops before task is done

```
❌ BAD:
Goal: "Create page with hero AND features"
Step 1: Created page
Step 2: Added hero section
Final Answer: "Done!"
→ Missing features section!

✅ GOOD:
Goal: "Create page with hero AND features"
Step 1: Created page
Step 2: Added hero section
Observation: Hero added. Still need features.
Step 3: Added features section
Observation: All requirements met.
Final Answer: "Created page with hero and features"
```

**Fix**: Track goal requirements explicitly, check all are met

### Failure 4: Not Learning from Failures

**Symptom**: Same error, same approach, repeat

```
❌ BAD:
Step 1: getPage(slug: "about") → NOT_FOUND
Step 2: getPage(slug: "about") → NOT_FOUND
Step 3: getPage(slug: "about") → NOT_FOUND
... infinite loop

✅ GOOD:
Step 1: getPage(slug: "about") → NOT_FOUND
Observation: Exact slug failed. Recording failure.
Step 2: findResource(query: "about") → Found "about-us"
Observation: Found via fuzzy search
```

**Fix**: Track failed approaches, try alternatives

## Trade-offs & Considerations

### Observation Verbosity

| Level | Tokens | Best For |
|-------|--------|----------|
| Minimal | ~50 | Simple lookups, fast iteration |
| Standard | ~150 | Normal operations, good balance |
| Verbose | ~300+ | Debugging, complex disambiguation |

**Guideline**: Match verbosity to task complexity

```
Simple: "Got page-456" (~50 tokens)
Standard: "Found page-456 (about-us, 95% match)" (~100 tokens)
Verbose: "Found 2 pages matching 'about'. Selected page-456 (about-us)
         with 95% confidence over page-789 (about-team, 72%).
         Proceeding with about-us as primary match." (~200 tokens)
```

### Memory Size Limits

```
Working Memory Trade-offs:

Small (10 items):
  + Fast context injection
  + Lower token usage
  - May forget older references

Large (100 items):
  + Better context retention
  + More pronoun resolution
  - Higher token cost
  - Slower processing

Recommendation: 20-50 items with LRU eviction
```

## Key Takeaways

1. **Always interpret results** - Don't just pass raw data to next step
2. **Update working memory** - Enable pronoun resolution and context continuity
3. **Check for errors first** - Handle failures before assuming success
4. **Verify goal completion** - Don't stop early based on step count alone
5. **Learn from failures** - Track what didn't work, try alternatives

**Observation Checklist**:

- [ ] Did the tool succeed or fail?
- [ ] What is the key data to extract?
- [ ] Which entities should go in memory?
- [ ] Is the goal achieved or do we need more steps?
- [ ] If error, is recovery possible?
- [ ] Are there alternative interpretations?

## References

1. **Yao et al.** (2022). "ReAct: Synergizing Reasoning and Acting in Language Models". https://arxiv.org/abs/2210.03629
2. **Park et al.** (2023). "Generative Agents: Interactive Simulacra of Human Behavior" (Memory Architecture). https://arxiv.org/abs/2304.03442
3. **Shinn et al.** (2023). "Reflexion: Language Agents with Verbal Reinforcement Learning" (Learning from Observations). https://arxiv.org/abs/2303.11366
4. **AI SDK 6 Documentation** (2025). Vercel. https://v6.ai-sdk.dev/docs/foundations/agents

**Related Topics**:

- [3.2.3 Acting Phase](./3.2.3-acting-phase.md) - Tool execution before observation
- [3.2.2 Reasoning Phase](./3.2.2-reasoning-phase.md) - Using observations in next thought
- [2.3.4 Working Memory](../2-context/2.3.4-working-memory.md) - Memory system details

**Layer Index**: [Layer 3: Agent Architecture](../AI_KNOWLEDGE_BASE_TOC.md#layer-3)
