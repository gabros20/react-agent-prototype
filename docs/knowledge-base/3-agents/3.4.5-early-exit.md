# 3.4.5 - Early Exit Strategies

> **Layer**: Agent Architecture | **Topic**: Loop Control
> **Status**: Verified | **Last Updated**: December 2025
> **Prerequisites**: [3.4.1 Max Steps Limits](./3.4.1-max-steps.md), [3.4.2 Convergence Detection](./3.4.2-convergence.md)
> **Grounded In**: REFRAIN, HALT-CoT, Stop-RAG, production cost optimization

## TL;DR

**Early exit strategies enable agents to stop before max steps when sufficient progress has been made.** Unlike convergence (task completion) and stuck detection (failures), early exit **optimizes efficiency** by recognizing diminishing returns.

**Key Takeaways**
- **20-55% token reduction** with adaptive stopping while maintaining accuracy
- **HALT-CoT entropy method** achieves 15-30% savings with any model
- **Progress-based exit** works best for multi-step execution tasks
- **AI SDK v6** uses custom `stopWhen` conditions for early exit
- **Track ROI** - early exit overhead must justify savings

## Why It Matters

**The Problem**

Without early exit, agents over-process:

```typescript
// ❌ WITHOUT EARLY EXIT
// Task: "Create page with hero section"

// Step 1: cms_createPage({ title: 'About' }) → Created!
// Step 2: cms_addSection({ type: 'hero' }) → Added!
// Step 3: Agent satisfied... but keeps going
// Step 4: cms_getPage() → "Just checking..."
// Step 5: "Let me add more content" → Not asked!
// Step 6-15: Over-optimization, unnecessary refinements

// Problem: Task 85% complete at step 2, but used 15 steps
// Wasted: $0.65 (13 unnecessary steps)
```

**Root causes:**
1. **No "good enough" signal** - Agent pursues perfection
2. **Missing progress tracking** - Can't measure completion percentage
3. **Over-cautious behavior** - Keeps verifying already-done work

**Research Evidence**

| Finding | Source | Year |
|---------|--------|------|
| **20-55%** token reduction with adaptive stopping | REFRAIN | Oct 2025 |
| **15-30%** savings with entropy-based stopping | HALT-CoT | Jul 2025 |
| **35-61%** sequence reduction with RL training | S-GRPO | May 2025 |
| **4.7×** efficiency vs fixed iterations | Stop-RAG | Oct 2025 |

## Core Concepts

### When to Apply Early Exit

```
┌─────────────────────────────────────────────────────────────┐
│                    EARLY EXIT DECISION                       │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ✅ USE EARLY EXIT:                                         │
│     • Research with 20+ sources (diminishing returns)       │
│     • Multi-hop Q&A (sufficient info in 2-3 hops)           │
│     • Code generation with tests (stop when tests pass)     │
│                                                              │
│  ❌ DON'T USE:                                              │
│     • Critical financial transactions (complete all steps)  │
│     • Simple lookup (1-2 steps already fast)                │
│     • Safety-critical operations                            │
│                                                              │
│  ⚠️ MAYBE:                                                  │
│     • Creative writing (may want full iteration)            │
│     • Exploration tasks (depends on goals)                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Strategy Selection

```
Strategy              Best For                  Savings
────────────────────────────────────────────────────────
Entropy-Based         Q&A, reasoning           15-30%
Progress-Based        Multi-step execution     20-40%
Stop-RAG              Research, retrieval      30-50%
Adaptive Planning     Complex planning         25-45%
```

## Implementation Patterns

### Entropy-Based Exit (HALT-CoT Method)

```typescript
// Best for: Q&A, reasoning tasks where answer converges

import { generateObject } from 'ai';
import { z } from 'zod';

export class EntropyEarlyExit {
  private readonly ENTROPY_THRESHOLD = 0.3;
  private readonly CHECK_EVERY_N_STEPS = 2;

  async shouldExit(currentStep: number, currentAnswer: string): Promise<ExitDecision> {
    if (currentStep % this.CHECK_EVERY_N_STEPS !== 0) {
      return { exit: false, confidence: 0, reason: 'Not time to check' };
    }

    // Sample multiple answers to measure consistency
    const samples = await this.sampleAnswers(currentAnswer, 5);
    const entropy = this.calculateEntropy(samples);
    const confidence = 1 - entropy;

    const exit = entropy < this.ENTROPY_THRESHOLD;

    return {
      exit,
      confidence,
      reason: exit
        ? `High confidence (entropy: ${entropy.toFixed(3)})`
        : `Still uncertain (entropy: ${entropy.toFixed(3)})`,
    };
  }

  private async sampleAnswers(baseAnswer: string, n: number): Promise<string[]> {
    const samples: string[] = [];

    for (let i = 0; i < n; i++) {
      const { object } = await generateObject({
        model: openai('gpt-4o-mini'),
        temperature: 0.8,
        schema: z.object({ answer: z.string() }),
        prompt: `Given reasoning so far: "${baseAnswer}"
                 What is your answer? Be concise.`,
      });
      samples.push(object.answer.toLowerCase().trim());
    }

    return samples;
  }

  private calculateEntropy(answers: string[]): number {
    const counts = new Map<string, number>();
    for (const ans of answers) {
      counts.set(ans, (counts.get(ans) || 0) + 1);
    }

    const probs = Array.from(counts.values()).map(count => count / answers.length);

    // Shannon entropy: H = -Σ(p * log2(p))
    const entropy = -probs.reduce((sum, p) =>
      sum + (p > 0 ? p * Math.log2(p) : 0), 0
    );

    // Normalize to [0, 1]
    const maxEntropy = Math.log2(answers.length);
    return entropy / maxEntropy;
  }
}
```

### Progress-Based Exit

```typescript
// Best for: Multi-step execution tasks (CMS agent)

interface TaskGoal {
  type: 'create' | 'update' | 'delete';
  target: string;
  successCriteria: SuccessCriterion[];
}

export class ProgressBasedEarlyExit {
  private readonly SUFFICIENT_PROGRESS = 0.85;
  private readonly CHECK_FREQUENCY = 3;

  async shouldExit(
    currentStep: number,
    goal: TaskGoal,
    ctx: AgentContext
  ): Promise<ExitDecision> {
    if (currentStep % this.CHECK_FREQUENCY !== 0) {
      return { exit: false, progress: 0, reason: 'Not time to check' };
    }

    const progress = await this.calculateProgress(goal, ctx);
    const exit = progress >= this.SUFFICIENT_PROGRESS;

    return {
      exit,
      progress,
      reason: exit
        ? `Sufficient progress (${(progress * 100).toFixed(1)}%)`
        : `Still working (${(progress * 100).toFixed(1)}%)`,
    };
  }

  private async calculateProgress(goal: TaskGoal, ctx: AgentContext): Promise<number> {
    const results = await Promise.all(
      goal.successCriteria.map(criterion =>
        this.checkCriterion(criterion, goal.target, ctx)
      )
    );

    const metCount = results.filter(r => r.met).length;
    return metCount / results.length;
  }

  private async checkCriterion(
    criterion: SuccessCriterion,
    target: string,
    ctx: AgentContext
  ): Promise<{ met: boolean }> {
    const state = await ctx.cmsService.getPage(target, 'full');
    if (!state) return { met: false };

    switch (criterion.operator) {
      case 'exists':
        return { met: state[criterion.field] != null };
      case 'equals':
        return { met: state[criterion.field] === criterion.expectedValue };
      case 'contains':
        return { met: String(state[criterion.field]).includes(criterion.expectedValue) };
      default:
        return { met: false };
    }
  }
}
```

### Stop-RAG (Value-Based Retrieval)

```typescript
// Best for: Research tasks with iterative retrieval

export class StopRAGController {
  private readonly VALUE_THRESHOLD = 0.8;

  async shouldRetrieveMore(state: RAGState): Promise<ExitDecision> {
    const value = await this.estimateRetrievalValue(state);
    const retrieve = value >= this.VALUE_THRESHOLD;

    return {
      exit: !retrieve,
      value,
      reason: retrieve
        ? `High value (${value.toFixed(2)}), continue`
        : `Low value (${value.toFixed(2)}), sufficient info`,
    };
  }

  private async estimateRetrievalValue(state: RAGState): Promise<number> {
    const answerConfidence = await this.assessConfidence(state.currentAnswer);
    const diminishingReturns = 1 / (1 + state.iteration * 0.5);
    const diversity = this.calculateDiversity(state.retrievedDocs);

    return 0.4 * (1 - answerConfidence) +
           0.4 * diminishingReturns +
           0.2 * diversity;
  }

  private async assessConfidence(answer: string): Promise<number> {
    const { object } = await generateObject({
      model: openai('gpt-4o-mini'),
      schema: z.object({ confidence: z.number().min(0).max(1) }),
      prompt: `Rate confidence in this answer (0-1): "${answer}"`,
    });
    return object.confidence;
  }

  private calculateDiversity(docs: Document[]): number {
    const uniqueSources = new Set(docs.map(d => d.source));
    return Math.min(uniqueSources.size / 10, 1.0);
  }
}
```

## Framework Integration

### AI SDK v6 Pattern

```typescript
import { generateText, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';

export async function runAgentWithEarlyExit(
  prompt: string,
  context: AgentContext,
  config: EarlyExitConfig = DEFAULT_CONFIG
): Promise<AgentResult> {
  const exitManager = new EarlyExitManager(config);
  let exitedEarly = false;
  let exitReason = '';

  const result = await generateText({
    model: openai('gpt-4o'),
    prompt,
    tools: getAllTools(),

    // v6: Use stopWhen for max steps
    stopWhen: stepCountIs(20),

    experimental_context: context,

    // Check for early exit after each step
    experimental_onStepFinish: async (step) => {
      const decision = await exitManager.shouldExit(step, context);

      if (decision.exit) {
        exitedEarly = true;
        exitReason = decision.reason;
        context.logger?.info('Early exit triggered', decision);
        return { shouldContinue: false };
      }

      return { shouldContinue: true };
    },
  });

  return {
    text: result.text,
    steps: result.steps.length,
    exitedEarly,
    exitReason,
    stepsSaved: exitedEarly ? (20 - result.steps.length) : 0,
  };
}
```

### Unified Early Exit Manager

```typescript
export type EarlyExitStrategy = 'entropy' | 'progress' | 'stop_rag' | 'none';

export interface EarlyExitConfig {
  strategy: EarlyExitStrategy;
  checkEveryNSteps: number;
  threshold: number;
  enabled: boolean;
}

export const DEFAULT_CONFIG: EarlyExitConfig = {
  strategy: 'progress',
  checkEveryNSteps: 3,
  threshold: 0.85,
  enabled: true,
};

export class EarlyExitManager {
  private controller: EarlyExitController;

  constructor(private config: EarlyExitConfig) {
    this.controller = this.createController(config.strategy);
  }

  async shouldExit(step: any, context: AgentContext): Promise<ExitDecision> {
    if (!this.config.enabled) {
      return { exit: false, reason: 'Early exit disabled' };
    }

    if (step.stepNumber % this.config.checkEveryNSteps !== 0) {
      return { exit: false, reason: 'Not time to check' };
    }

    return this.controller.evaluate(step, context, this.config);
  }

  private createController(strategy: EarlyExitStrategy): EarlyExitController {
    switch (strategy) {
      case 'entropy':
        return new EntropyEarlyExit();
      case 'progress':
        return new ProgressBasedEarlyExit();
      case 'stop_rag':
        return new StopRAGController();
      case 'none':
        return { evaluate: async () => ({ exit: false, reason: 'Disabled' }) };
      default:
        throw new Error(`Unknown strategy: ${strategy}`);
    }
  }
}
```

## Testing Strategy

### Unit Testing Early Exit

```typescript
import { describe, it, expect, vi } from 'vitest';
import { ProgressBasedEarlyExit } from '../progress-exit';
import { EntropyEarlyExit } from '../entropy-exit';

describe('ProgressBasedEarlyExit', () => {
  const createMockContext = () => ({
    cmsService: { getPage: vi.fn() },
  });

  it('exits when progress exceeds threshold', async () => {
    const ctx = createMockContext();
    ctx.cmsService.getPage.mockResolvedValue({
      title: 'About',
      content: 'Hero section content',
      status: 'published',
    });

    const exit = new ProgressBasedEarlyExit();
    const goal = {
      type: 'create' as const,
      target: 'about',
      successCriteria: [
        { field: 'title', operator: 'exists' as const, expectedValue: true },
        { field: 'content', operator: 'contains' as const, expectedValue: 'Hero' },
        { field: 'status', operator: 'equals' as const, expectedValue: 'published' },
      ],
    };

    // Step 3 triggers check (CHECK_FREQUENCY = 3)
    const result = await exit.shouldExit(3, goal, ctx as any);

    expect(result.exit).toBe(true);
    expect(result.progress).toBe(1.0);
  });

  it('continues when progress below threshold', async () => {
    const ctx = createMockContext();
    ctx.cmsService.getPage.mockResolvedValue({
      title: 'About',
      content: 'No hero yet',
      status: 'draft',
    });

    const exit = new ProgressBasedEarlyExit();
    const goal = {
      type: 'create' as const,
      target: 'about',
      successCriteria: [
        { field: 'title', operator: 'exists' as const, expectedValue: true },
        { field: 'content', operator: 'contains' as const, expectedValue: 'Hero' },
        { field: 'status', operator: 'equals' as const, expectedValue: 'published' },
      ],
    };

    const result = await exit.shouldExit(3, goal, ctx as any);

    expect(result.exit).toBe(false);
    expect(result.progress).toBeCloseTo(0.33, 1); // 1 of 3 criteria
  });
});

describe('EntropyEarlyExit', () => {
  it('exits on low entropy (high confidence)', async () => {
    const exit = new EntropyEarlyExit();

    // Mock consistent answers (low entropy)
    vi.spyOn(exit as any, 'sampleAnswers').mockResolvedValue([
      'tokyo', 'tokyo', 'tokyo', 'tokyo', 'tokyo',
    ]);

    const result = await exit.shouldExit(2, 'The capital is Tokyo');

    expect(result.exit).toBe(true);
    expect(result.confidence).toBeGreaterThan(0.7);
  });
});
```

## Common Pitfalls

### ❌ Avoid

| Pitfall | Problem | Solution |
|---------|---------|----------|
| Exit too aggressively | Quality degradation | Use 85%+ threshold |
| Check every step | Overhead exceeds savings | Check every 2-3 steps |
| Skip verification | Exit on false progress | Always verify state |
| Apply to short tasks | Overhead not worth it | Skip for 1-3 step tasks |
| Ignore user preferences | Some want thorough | Make configurable |
| No ROI tracking | Can't justify investment | Measure actual savings |

### ✅ Best Practices

1. **Check periodically** - Every 2-3 steps, not every step
2. **Track metrics** - Exit rate, steps saved, quality impact
3. **Tune thresholds** - Different tasks need different criteria
4. **Combine with convergence** - Early exit for efficiency, convergence for correctness
5. **Start conservative** - Higher thresholds initially
6. **Log false exits** - Track quality degradation cases

## Quick Reference

### AI SDK v6 Early Exit Pattern

```typescript
import { generateText, stepCountIs } from 'ai';

const result = await generateText({
  model: openai('gpt-4o'),
  prompt,
  tools,
  stopWhen: stepCountIs(20),

  experimental_onStepFinish: async (step) => {
    const decision = await exitManager.shouldExit(step, context);
    if (decision.exit) {
      return { shouldContinue: false };
    }
    return { shouldContinue: true };
  },
});

// Strategy guide by task type
const STRATEGIES = {
  qa: { strategy: 'entropy', threshold: 0.3, savings: '15-30%' },
  execution: { strategy: 'progress', threshold: 0.85, savings: '20-40%' },
  research: { strategy: 'stop_rag', threshold: 0.8, savings: '30-50%' },
};
```

### ROI Calculation

| Monthly Requests | Early Exit Rate | Steps Saved | Monthly Savings |
|------------------|-----------------|-------------|-----------------|
| 10,000 | 50% | 5 | $25 |
| 50,000 | 50% | 5 | $125 |
| 100,000 | 50% | 5 | $250 |

*Based on $0.001/step cost*

## Related Topics

- [3.4.1 - Max Steps Limits](./3.4.1-max-steps.md) - Hard bounds on iterations
- [3.4.2 - Convergence Detection](./3.4.2-convergence.md) - Task completion signals
- [3.4.3 - Stuck Detection](./3.4.3-stuck-detection.md) - Preventing infinite loops

## Research & Resources

**Academic Papers**
- REFRAIN - "Stop When Enough: Adaptive Early-Stopping for Chain-of-Thought" (Oct 2025) - [arxiv.org](https://arxiv.org/html/2510.10103v1)
- HALT-CoT - "Model-Agnostic Early Stopping via Answer Entropy" (Jul 2025) - [openreview.net](https://openreview.net/pdf?id=CX5c7C1CZa)
- S-GRPO - "Serial-Group Decaying-Reward Policy Optimization" (May 2025) - [arxiv.org](https://arxiv.org/abs/2505.07686)
- Stop-RAG - "Value-Based Retrieval Control for Iterative RAG" (Oct 2025) - [arxiv.org](https://www.arxiv.org/abs/2510.14337)

**Industry Resources**
- "Learning When to Plan: Efficiently Allocating Test-Time Compute" (Sep 2025) - [arxiv.org](https://arxiv.org/abs/2509.03581)
