# 3.3.4 - Result Validation

> **Layer**: Agent Architecture | **Topic**: Tool System
> **Version**: 2.0 | **Date Verified**: December 2025

---

## TL;DR

**Result validation verifies tool executions produced expected outcomes before the agent continues.** Unlike input validation (pre-execution), result validation catches silent failures, partial successes, and unexpected side effects that would otherwise propagate through workflows.

### Key Takeaways

- **60% of tool failures are silent** - operation "succeeds" but goal not achieved
- **Read-after-write verification** catches mutations that didn't persist
- **Schema validation** ensures response shape matches expectations
- **Business rule validation** confirms domain constraints are satisfied
- **Structured error responses** help agents recover and retry

---

## Why It Matters

### The Problem

Silent failures corrupt agent workflows:

```typescript
// ❌ WITHOUT VALIDATION
const cms_updatePage = tool({
  execute: async ({ pageId, content }, { experimental_context }) => {
    const ctx = experimental_context as AgentContext;
    await ctx.cmsService.updatePage(pageId, { content });

    // What if:
    // - Content was truncated (exceeded max length)?
    // - Permission was silently denied?
    // - Database connection dropped mid-write?

    return { success: true };  // ⚠️ Lying to the agent!
  },
});

// Agent continues thinking update worked...
// Step 5: update_page → "success"
// Step 6: publish_page → Publishes OLD content!
```

### Research Evidence

| Finding | Source | Year |
|---------|--------|------|
| **60%** of tool failures are silent | Production metrics | 2025 |
| Post-execution verification reduces errors by **85%** | VeriGuard | Oct 2025 |
| EviBound achieves **0%** hallucination rate with dual-gate validation | EviBound | Oct 2025 |
| Verification agents outperform traditional methods by **40%** | VerifiAgent | Apr 2025 |

---

## Core Concepts

### Validation Types

```
┌─────────────────────────────────────────────────────────────┐
│                    RESULT VALIDATION                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. READ-AFTER-WRITE                                        │
│     └─ Confirm mutations persisted correctly                │
│                                                              │
│  2. SCHEMA VALIDATION                                       │
│     └─ Verify result matches expected shape                 │
│                                                              │
│  3. BUSINESS RULES                                          │
│     └─ Check domain constraints are satisfied               │
│                                                              │
│  4. SIDE EFFECTS                                            │
│     └─ Confirm expected side effects occurred               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Validation Flow

```
Execute Operation → Read Back Result → Validate → Return
                          ↓
                   ┌──────────────┐
                   │  Validated?  │
                   └──────────────┘
                    ↓           ↓
                  Yes          No
                   ↓            ↓
           Return Success   Return Error
           { verified: true }   + Suggestion
```

---

## Implementation Guide

### Step-by-Step

#### 1. Read-After-Write Verification

```typescript
// server/tools/cms/update-page.ts
import { tool } from 'ai';
import { z } from 'zod';
import type { AgentContext } from '@/types';

export const cms_updatePage = tool({
  description: 'Updates CMS page content with verification',
  inputSchema: z.object({
    pageId: z.string(),
    content: z.string(),
  }),

  execute: async ({ pageId, content }, { experimental_context }) => {
    const ctx = experimental_context as AgentContext;

    // Step 1: Execute update
    await ctx.cmsService.updatePage(pageId, { content });

    // Step 2: Read back to verify
    const updated = await ctx.cmsService.getPage(pageId);

    // Step 3: Validate content matches
    if (updated.content !== content) {
      return {
        error: 'Update verification failed',
        expected: content.substring(0, 100) + '...',
        actual: updated.content.substring(0, 100) + '...',
        suggestion: 'Content may have been truncated or sanitized',
      };
    }

    return {
      success: true,
      page: updated,
      verified: true,
    };
  },
});
```

#### 2. Schema Validation

```typescript
import { z } from 'zod';

// Define expected output schema
const PageSchema = z.object({
  id: z.string(),
  title: z.string().min(1),
  slug: z.string().regex(/^[a-z0-9-]+$/),
  content: z.string(),
  status: z.enum(['draft', 'published', 'archived']),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export const cms_getPage = tool({
  description: 'Gets page with schema validation',
  inputSchema: z.object({ pageId: z.string() }),

  execute: async ({ pageId }, { experimental_context }) => {
    const ctx = experimental_context as AgentContext;
    const page = await ctx.cmsService.getPage(pageId);

    if (!page) {
      return { error: 'Page not found', pageId };
    }

    // Validate against schema
    const validation = PageSchema.safeParse(page);

    if (!validation.success) {
      return {
        error: 'Page data failed validation',
        validationErrors: validation.error.errors,
        page,  // Include raw data for debugging
        suggestion: 'Database may contain invalid data',
      };
    }

    return {
      success: true,
      page: validation.data,
      verified: true,
    };
  },
});
```

#### 3. Business Rule Validation

```typescript
export const cms_publishPage = tool({
  description: 'Publishes page with business rule validation',
  inputSchema: z.object({ pageId: z.string() }),

  execute: async ({ pageId }, { experimental_context }) => {
    const ctx = experimental_context as AgentContext;

    // Step 1: Publish
    await ctx.cmsService.updatePage(pageId, { status: 'published' });

    // Step 2: Read back
    const page = await ctx.cmsService.getPage(pageId);

    // Step 3: Verify business rules
    const rules = [
      {
        check: page.status === 'published',
        error: 'Status not set to published',
      },
      {
        check: page.title?.length > 0,
        error: 'Published page must have title',
      },
      {
        check: page.content?.length > 0,
        error: 'Published page must have content',
      },
      {
        check: /^[a-z0-9-]+$/.test(page.slug),
        error: 'Published page must have valid slug',
      },
    ];

    for (const rule of rules) {
      if (!rule.check) {
        return {
          error: 'Publication validation failed',
          reason: rule.error,
          page,
          suggestion: 'Complete required fields before publishing',
        };
      }
    }

    return {
      success: true,
      page,
      verified: true,
      url: `https://example.com/${page.slug}`,
    };
  },
});
```

#### 4. Delete Verification

```typescript
export const cms_deletePage = tool({
  description: 'Deletes page with verification',
  inputSchema: z.object({ pageId: z.string() }),

  execute: async ({ pageId }, { experimental_context }) => {
    const ctx = experimental_context as AgentContext;

    // Step 1: Delete
    await ctx.cmsService.deletePage(pageId);

    // Step 2: Verify deletion
    const stillExists = await ctx.cmsService.getPage(pageId);

    if (stillExists) {
      return {
        error: 'Deletion failed verification',
        reason: 'Page still exists after delete operation',
        suggestion: 'May have soft-delete or insufficient permissions',
        pageId,
      };
    }

    return {
      success: true,
      deleted: true,
      verified: true,
    };
  },
});
```

---

## Framework Integration

### Verification Wrapper

```typescript
// server/tools/lib/with-verification.ts
type VerifyFn<R> = (result: R) => Promise<boolean | VerificationResult>;

interface VerificationResult {
  verified: boolean;
  errors?: string[];
}

export function withVerification<P, R>(
  toolDef: ToolDefinition<P, R>,
  verify: VerifyFn<R>
) {
  return {
    ...toolDef,

    execute: async (params: P, options: ToolOptions) => {
      // Execute original tool
      const result = await toolDef.execute(params, options);

      // Skip verification if already errored
      if ('error' in result) return result;

      // Run verification
      const verification = await verify(result);

      if (verification === false) {
        return {
          error: 'Result verification failed',
          result,
          suggestion: 'Operation may have partially succeeded',
        };
      }

      if (typeof verification === 'object' && !verification.verified) {
        return {
          error: 'Result verification failed',
          errors: verification.errors,
          result,
        };
      }

      return { ...result, verified: true };
    },
  };
}

// Usage
const cms_updatePage = withVerification(
  baseCmsUpdatePage,
  async (result) => {
    // Verify content was saved
    return result.page?.content?.length > 0;
  }
);
```

### AI SDK v6 Integration

```typescript
import { generateText, tool, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';

// Tools with built-in verification
const result = await generateText({
  model: openai('gpt-4o'),
  prompt: userMessage,

  tools: {
    cms_updatePage: tool({
      description: 'Updates page with verification',
      inputSchema: z.object({
        pageId: z.string(),
        content: z.string(),
      }),

      execute: async ({ pageId, content }, { experimental_context }) => {
        const ctx = experimental_context as AgentContext;

        // Execute
        await ctx.cmsService.updatePage(pageId, { content });

        // Verify
        const updated = await ctx.cmsService.getPage(pageId);

        if (updated.content !== content) {
          return {
            error: 'Verification failed: content mismatch',
            suggestion: 'Try shorter content or check permissions',
          };
        }

        return { success: true, page: updated, verified: true };
      },
    }),
  },

  experimental_context: context,
  stopWhen: stepCountIs(15),
});
```

---

## Testing Strategy

### Unit Testing Validation Logic

```typescript
import { describe, it, expect, vi } from 'vitest';
import { cms_updatePage } from '../cms/update-page';

describe('cms_updatePage verification', () => {
  const mockContext = {
    cmsService: {
      updatePage: vi.fn(),
      getPage: vi.fn(),
    },
    userId: 'test-user',
    sessionId: 'test-session',
  };

  it('returns verified: true when content matches', async () => {
    mockContext.cmsService.updatePage.mockResolvedValue(undefined);
    mockContext.cmsService.getPage.mockResolvedValue({
      id: 'page-1',
      content: 'New content',
    });

    const result = await cms_updatePage.execute(
      { pageId: 'page-1', content: 'New content' },
      { experimental_context: mockContext }
    );

    expect(result.success).toBe(true);
    expect(result.verified).toBe(true);
  });

  it('returns error when content was truncated', async () => {
    mockContext.cmsService.updatePage.mockResolvedValue(undefined);
    mockContext.cmsService.getPage.mockResolvedValue({
      id: 'page-1',
      content: 'Truncated...',  // Different from input
    });

    const result = await cms_updatePage.execute(
      { pageId: 'page-1', content: 'Very long content that got truncated' },
      { experimental_context: mockContext }
    );

    expect(result.error).toBe('Update verification failed');
    expect(result.suggestion).toBeDefined();
  });

  it('handles database errors gracefully', async () => {
    mockContext.cmsService.updatePage.mockRejectedValue(
      new Error('Database connection lost')
    );

    const result = await cms_updatePage.execute(
      { pageId: 'page-1', content: 'Content' },
      { experimental_context: mockContext }
    );

    expect(result.error).toContain('Database');
  });
});
```

---

## Common Pitfalls

### ❌ Avoid

| Pitfall | Problem | Solution |
|---------|---------|----------|
| Trusting returned status | Silent failures | Always read back and verify |
| Skipping verification | 60% of failures are silent | Verify all mutations |
| Generic error messages | Agent can't recover | Include suggestions |
| Blocking on non-critical ops | Performance hit | Use async for logs/emails |
| Over-validating reads | Unnecessary overhead | Light validation for reads |

### ✅ Best Practices

1. **Verify all mutations** - CREATE, UPDATE, DELETE operations
2. **Read-after-write** - Confirm changes actually persisted
3. **Include `verified: true`** - Agent knows result is trustworthy
4. **Provide recovery suggestions** - Help agent fix failures
5. **Balance thoroughness** - Fast for reads, thorough for writes

---

## Summary

### Quick Reference

```typescript
// Verification Pattern Template
export const myMutationTool = tool({
  description: 'Mutation with verification',
  inputSchema: z.object({ /* ... */ }),

  execute: async (input, { experimental_context }) => {
    const ctx = experimental_context as AgentContext;

    // 1. Execute mutation
    await ctx.service.mutate(input);

    // 2. Read back
    const result = await ctx.service.get(input.id);

    // 3. Verify
    if (!isExpected(result, input)) {
      return {
        error: 'Verification failed',
        expected: input,
        actual: result,
        suggestion: 'How to fix this',
      };
    }

    // 4. Return with verified flag
    return {
      success: true,
      data: result,
      verified: true,
    };
  },
});
```

### Verification Checklist

| Operation | Verification Required |
|-----------|----------------------|
| **CREATE** | Read back, confirm exists, verify fields |
| **UPDATE** | Read back, compare changed fields |
| **DELETE** | Read back, confirm not found |
| **READ** | Schema validation (light) |
| **SEARCH** | Schema validation, count check |

---

## Related Topics

- [3.3.1 - Tool Definition](./3.3.1-tool-definition.md) - Input validation patterns
- [3.3.3 - Context Injection](./3.3.3-context-injection.md) - Accessing services for verification
- [3.4.2 - Convergence Detection](./3.4.2-convergence.md) - Task completion verification

---

## Research Citations

1. **VeriGuard** - "Enhancing LLM Agent Safety via Verified Code Generation" (Oct 2025)
   https://arxiv.org/html/2510.05156v1

2. **EviBound** - "Evidence-Bound Autonomous Research: Eliminating False Claims" (Oct 2025)
   https://arxiv.org/abs/2511.05524

3. **VerifiAgent** - "Unified Verification Agent in Language Model Reasoning" (Apr 2025)
   https://arxiv.org/abs/2504.00406

4. **xVerify** - "Efficient Answer Verifier for Reasoning Model Evaluations" (Apr 2025)
   https://arxiv.org/abs/2504.10481

5. **CircleCI** - "Building LLM agents to validate LangGraph tool use" (Oct 2025)
   https://circleci.com/blog/building-llm-agents-to-validate-tool-use-and-structured-output
