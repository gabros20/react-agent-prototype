# 3.3.6 Dynamic Tool Search

## TL;DR

Dynamic tool search enables agents to work with hundreds or thousands of tools by discovering and loading them on-demand rather than upfront—achieving 34-94% token savings while maintaining tool selection accuracy through semantic search, BM25, or regex patterns.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-12
- **Prerequisites**: [3.3.2 Tool Registry](./3.3.2-tool-registry.md)
- **Grounded In**: Anthropic Tool Search Tool (2025), Spring AI Tool Search (Tzolov 2025), MCP Optimizer (Stacklok 2025)

## Table of Contents

- [Overview](#overview)
- [The Problem](#the-problem-tool-explosion)
- [Core Concept](#core-concept)
- [Search Strategies](#search-strategies)
- [Implementation Patterns](#implementation-patterns)
- [Framework Integration](#framework-integration)
- [Benchmarks & Performance](#benchmarks--performance)
- [When to Use This Pattern](#when-to-use-this-pattern)
- [Production Best Practices](#production-best-practices)
- [Key Takeaways](#key-takeaways)
- [References](#references)

## Overview

As AI agents connect to more services—Slack, GitHub, Jira, databases, MCP servers—tool libraries grow rapidly. A typical multi-server setup can easily have 50+ tools consuming 55,000+ tokens before any conversation starts. The **Tool Search Tool** pattern, pioneered by Anthropic in late 2025, addresses this by having the model discover tools on-demand rather than loading all definitions upfront.

**Key Research Findings**:

| Source | Finding | Year |
|--------|---------|------|
| **Spring AI** (Tzolov) | 34-64% token reduction with dynamic tool discovery | Dec 2025 |
| **Anthropic** | Tool selection accuracy degrades with >30-50 tools | Nov 2025 |
| **Stacklok** | Hybrid semantic+BM25 achieves 94% vs 34% accuracy | 2025 |
| **Arcade** | BM25 achieves 64% retrieval accuracy at 4,000 tools | 2025 |

**Date Verified**: 2025-12-12

## The Problem: Tool Explosion

```
┌─────────────────────────────────────────────────────────────┐
│              THE TOOL EXPLOSION PROBLEM                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Traditional Approach (All Tools Upfront):                   │
│  ─────────────────────────────────────────                   │
│                                                              │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  Context Window (200K tokens)                           ││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │  Tool Definitions (50 tools ≈ 55K tokens)          │││
│  │  │  ████████████████████████████████                   │││
│  │  └─────────────────────────────────────────────────────┘││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │  System Prompt + Conversation (remaining space)     │││
│  │  │  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░  │││
│  │  └─────────────────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────┘│
│                                                              │
│  Problems:                                                   │
│  • 50 tools ≈ 10-20K tokens (before conversation starts)   │
│  • Tool selection accuracy degrades >30-50 tools            │
│  • Most tools unused in any given conversation              │
│  • MCP servers can add 100+ tools each                     │
│                                                              │
│  Dynamic Tool Search:                                        │
│  ────────────────────                                        │
│                                                              │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  Context Window (200K tokens)                           ││
│  │  ┌───────┐                                              ││
│  │  │Search │  ← Only search tool + 3-5 frequently used   ││
│  │  │ Tool  │                                              ││
│  │  └───────┘                                              ││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │  System Prompt + Conversation (maximum space!)      │││
│  │  │  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│││
│  │  └─────────────────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────┘│
│                                                              │
│  Benefits:                                                   │
│  • 34-94% token savings                                     │
│  • Scale to 1,000+ tools                                   │
│  • Only relevant tools loaded per request                   │
│  • Better selection accuracy (focused context)              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

## Core Concept

### How Tool Search Works

```
┌─────────────────────────────────────────────────────────────┐
│              TOOL SEARCH FLOW                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. Initial State                                            │
│     ┌──────────────────────────────────────────────────────┐│
│     │  Tools Available to Model:                           ││
│     │  • tool_search (always loaded)                       ││
│     │  • 3-5 frequently used tools (non-deferred)         ││
│     │                                                       ││
│     │  Deferred Tools (not in context):                    ││
│     │  • get_weather, search_files, send_email...         ││
│     │  • (stored with defer_loading: true)                ││
│     └──────────────────────────────────────────────────────┘│
│                                                              │
│  2. User Request: "What's the weather in Seattle?"          │
│     ↓                                                       │
│  3. Model Uses Search Tool                                  │
│     ┌──────────────────────────────────────────────────────┐│
│     │  tool_search({ query: "weather" })                   ││
│     │                                                       ││
│     │  Search matches tool names, descriptions,            ││
│     │  argument names against query                        ││
│     └──────────────────────────────────────────────────────┘│
│     ↓                                                       │
│  4. Search Returns Tool References                          │
│     ┌──────────────────────────────────────────────────────┐│
│     │  tool_references: [                                  ││
│     │    { tool_name: "get_weather" },                     ││
│     │    { tool_name: "check_forecast" }                   ││
│     │  ]                                                   ││
│     └──────────────────────────────────────────────────────┘│
│     ↓                                                       │
│  5. Tool Definitions Expanded into Context                  │
│     ┌──────────────────────────────────────────────────────┐│
│     │  Now model sees full definition of get_weather:      ││
│     │  • name, description, input_schema                   ││
│     │  • Ready to invoke                                   ││
│     └──────────────────────────────────────────────────────┘│
│     ↓                                                       │
│  6. Model Invokes Discovered Tool                           │
│     ┌──────────────────────────────────────────────────────┐│
│     │  get_weather({ location: "Seattle" })                ││
│     └──────────────────────────────────────────────────────┘│
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Deferred Loading

The key mechanism is **deferred loading**—tools marked with `defer_loading: true` are not included in the initial context but can be discovered via search:

```typescript
const tools = [
  // Always loaded - the search mechanism itself
  {
    type: 'tool_search_tool_bm25',
    name: 'tool_search',
  },

  // Always loaded - frequently used tools (3-5 max)
  {
    name: 'get_page',
    description: 'Get CMS page by ID or slug',
    inputSchema: getPageSchema,
    // No defer_loading = always available
  },

  // Deferred - loaded on demand
  {
    name: 'send_email',
    description: 'Send email to recipient',
    inputSchema: sendEmailSchema,
    defer_loading: true,  // Only loaded when discovered
  },

  {
    name: 'create_github_issue',
    description: 'Create issue in GitHub repository',
    inputSchema: createIssueSchema,
    defer_loading: true,
  },

  // ... hundreds more deferred tools
];
```

## Search Strategies

### Strategy Comparison

| Strategy | How It Works | Accuracy | Best For |
|----------|--------------|----------|----------|
| **Regex** | Pattern matching on tool names/descriptions | 30-56% | Exact name matching |
| **BM25** | Keyword-based ranking (TF-IDF variant) | 48-64% | Natural language queries |
| **Semantic** | Vector embeddings similarity | 80-98% | Conceptual matching |
| **Hybrid** | Semantic + BM25 combined | 94%+ | Production systems |

### 1. Regex Search (Anthropic Built-in)

```typescript
// Claude constructs regex patterns, NOT natural language
// Pattern: Python re.search() syntax

// Examples of how Claude generates patterns:
// "weather" → matches tools containing "weather"
// "get_.*_data" → matches get_user_data, get_weather_data
// "(?i)slack" → case-insensitive search for "slack"
// "email|message|notification" → OR patterns

const regexSearchTool = {
  type: 'tool_search_tool_regex_20251119',
  name: 'tool_search_regex',
};
```

**Pros**: Fast, predictable, no external dependencies
**Cons**: Limited to exact/pattern matches, 30-56% accuracy at scale

### 2. BM25 Search (Anthropic Built-in)

```typescript
// Natural language queries ranked by BM25 algorithm
const bm25SearchTool = {
  type: 'tool_search_tool_bm25_20251119',
  name: 'tool_search_bm25',
};

// Claude uses natural language:
// "tools for sending messages"
// "weather and forecast capabilities"
// "database query operations"
```

**Pros**: Natural language queries, better than regex
**Cons**: Still keyword-based, 48-64% accuracy at scale

### 3. Semantic Search (Custom Implementation)

```typescript
import { embed, cosineSimilarity } from 'ai';
import { openai } from '@ai-sdk/openai';

interface ToolEmbedding {
  toolName: string;
  embedding: number[];
  description: string;
}

class SemanticToolSearch {
  private embeddings: ToolEmbedding[] = [];

  async indexTools(tools: ToolMetadata[]): Promise<void> {
    for (const tool of tools) {
      // Create searchable text from tool metadata
      const searchText = [
        tool.name,
        tool.description,
        ...tool.tags,
        ...Object.keys(tool.inputSchema.properties || {}),
      ].join(' ');

      const { embedding } = await embed({
        model: openai.embedding('text-embedding-3-small'),
        value: searchText,
      });

      this.embeddings.push({
        toolName: tool.name,
        embedding,
        description: tool.description,
      });
    }
  }

  async search(query: string, topK: number = 5): Promise<string[]> {
    const { embedding: queryEmbedding } = await embed({
      model: openai.embedding('text-embedding-3-small'),
      value: query,
    });

    const scored = this.embeddings.map(tool => ({
      toolName: tool.toolName,
      score: cosineSimilarity(queryEmbedding, tool.embedding),
    }));

    return scored
      .sort((a, b) => b.score - a.score)
      .slice(0, topK)
      .map(s => s.toolName);
  }
}
```

**Pros**: 80-98% accuracy, conceptual matching
**Cons**: Requires embedding model, latency for embedding generation

### 4. Hybrid Search (Production Recommended)

```typescript
class HybridToolSearch {
  constructor(
    private semanticSearch: SemanticToolSearch,
    private bm25Search: BM25Search,
    private alpha: number = 0.7 // Weight for semantic
  ) {}

  async search(query: string, topK: number = 5): Promise<string[]> {
    // Run both searches in parallel
    const [semanticResults, bm25Results] = await Promise.all([
      this.semanticSearch.search(query, topK * 2),
      this.bm25Search.search(query, topK * 2),
    ]);

    // Reciprocal Rank Fusion (RRF)
    const scores = new Map<string, number>();
    const k = 60; // RRF constant

    semanticResults.forEach((tool, rank) => {
      const score = this.alpha / (k + rank + 1);
      scores.set(tool, (scores.get(tool) || 0) + score);
    });

    bm25Results.forEach((tool, rank) => {
      const score = (1 - this.alpha) / (k + rank + 1);
      scores.set(tool, (scores.get(tool) || 0) + score);
    });

    return Array.from(scores.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, topK)
      .map(([tool]) => tool);
  }
}
```

**Pros**: 94%+ accuracy, best of both worlds
**Cons**: More complex, two search systems to maintain

## Implementation Patterns

### Pattern 1: Anthropic Native Tool Search

```typescript
import Anthropic from '@anthropic-ai/sdk';

const client = new Anthropic();

async function agentWithToolSearch(userMessage: string) {
  const response = await client.beta.messages.create({
    model: 'claude-sonnet-4-5-20250929',
    betas: ['advanced-tool-use-2025-11-20'],
    max_tokens: 2048,
    messages: [{ role: 'user', content: userMessage }],
    tools: [
      // Search tool (always loaded)
      {
        type: 'tool_search_tool_bm25_20251119',
        name: 'tool_search',
      },
      // Frequently used (always loaded)
      {
        name: 'get_page',
        description: 'Get CMS page content',
        input_schema: { /* ... */ },
      },
      // Deferred tools (loaded on demand)
      {
        name: 'send_email',
        description: 'Send email to recipients',
        input_schema: { /* ... */ },
        defer_loading: true,
      },
      {
        name: 'create_github_issue',
        description: 'Create GitHub issue',
        input_schema: { /* ... */ },
        defer_loading: true,
      },
      // ... hundreds more deferred tools
    ],
  });

  return response;
}
```

### Pattern 2: Custom Semantic Search Tool

```typescript
import { tool } from 'ai';
import { z } from 'zod';

// Custom tool search that returns tool_reference blocks
const semanticToolSearch = tool({
  description: 'Search for available tools by describing what you need',
  inputSchema: z.object({
    query: z.string().describe('Natural language description of needed capability'),
    limit: z.number().default(5).describe('Maximum tools to return'),
  }),
  execute: async ({ query, limit }, { experimental_context }) => {
    const ctx = experimental_context as AgentContext;
    const searcher = ctx.services.getToolSearcher();

    const results = await searcher.search(query, limit);

    // Return tool_reference blocks for expansion
    return {
      type: 'tool_search_tool_search_result',
      tool_references: results.map(toolName => ({
        type: 'tool_reference',
        tool_name: toolName,
      })),
    };
  },
});
```

### Pattern 3: Spring AI Recursive Advisor Pattern

```typescript
// Spring AI approach using recursive advisors
// Works with any LLM, not just Claude

interface ToolSearchAdvisor {
  beforeRequest(request: ChatRequest): ChatRequest;
  afterResponse(response: ChatResponse): ChatResponse;
}

class ToolSearchRecursiveAdvisor implements ToolSearchAdvisor {
  constructor(
    private toolRegistry: ToolRegistry,
    private searcher: HybridToolSearch
  ) {}

  beforeRequest(request: ChatRequest): ChatRequest {
    // Initially provide only search tool
    return {
      ...request,
      tools: [this.getSearchTool()],
    };
  }

  afterResponse(response: ChatResponse): ChatResponse {
    // If model called search tool, expand results and re-run
    const searchCall = response.toolCalls?.find(
      tc => tc.name === 'tool_search'
    );

    if (searchCall) {
      const discoveredTools = this.expandToolReferences(
        searchCall.result.tool_references
      );

      // Add discovered tools to context and continue
      return this.continueWithTools(response, discoveredTools);
    }

    return response;
  }

  private expandToolReferences(refs: ToolReference[]): Tool[] {
    return refs.map(ref =>
      this.toolRegistry.get(ref.tool_name)
    ).filter(Boolean);
  }
}
```

### Pattern 4: Vector Store Integration

```typescript
import { PGVectorStore } from './vector-store';

class VectorToolSearch {
  private vectorStore: PGVectorStore;

  constructor(connectionString: string) {
    this.vectorStore = new PGVectorStore({
      connectionString,
      tableName: 'tool_embeddings',
      dimensions: 1536,
    });
  }

  async indexTool(tool: ToolMetadata): Promise<void> {
    const searchableText = this.buildSearchableText(tool);

    await this.vectorStore.addDocument({
      id: tool.name,
      content: searchableText,
      metadata: {
        name: tool.name,
        category: tool.category,
        riskLevel: tool.riskLevel,
      },
    });
  }

  async search(
    query: string,
    filters?: { category?: string; maxRisk?: string },
    topK: number = 5
  ): Promise<ToolMetadata[]> {
    const results = await this.vectorStore.similaritySearch(query, {
      k: topK,
      filter: filters,
    });

    return results.map(r => this.toolRegistry.get(r.metadata.name));
  }

  private buildSearchableText(tool: ToolMetadata): string {
    const parts = [
      `Tool: ${tool.name}`,
      `Description: ${tool.description}`,
      `Category: ${tool.category}`,
      `Tags: ${tool.tags.join(', ')}`,
      `Parameters: ${Object.keys(tool.inputSchema.properties || {}).join(', ')}`,
    ];

    if (tool.examples) {
      parts.push(`Examples: ${tool.examples.map(e => e.scenario).join('; ')}`);
    }

    return parts.join('\n');
  }
}
```

## Framework Integration

### AI SDK v6 with Tool Search

```typescript
import { generateText, tool } from 'ai';
import { openai } from '@ai-sdk/openai';

// Tool search as a regular tool
const toolSearchTool = tool({
  description: 'Search for tools to accomplish a task',
  inputSchema: z.object({
    query: z.string(),
  }),
  execute: async ({ query }, { experimental_context }) => {
    const ctx = experimental_context as AgentContext;
    const results = await ctx.toolSearcher.search(query, 5);

    // Dynamically inject discovered tools for next iteration
    ctx.discoveredTools = results.map(name => ctx.toolRegistry.get(name));

    return {
      found: results.length,
      tools: results.map(name => ({
        name,
        description: ctx.toolRegistry.get(name)?.description,
      })),
    };
  },
});

// Agent loop with dynamic tool injection
async function agentWithDynamicTools(prompt: string) {
  const context: AgentContext = {
    toolRegistry,
    toolSearcher: new HybridToolSearch(semanticSearch, bm25Search),
    discoveredTools: [],
  };

  // Start with only search tool
  let activeTools = { tool_search: toolSearchTool };

  let result = await generateText({
    model: openai('gpt-4o'),
    prompt,
    tools: activeTools,
    experimental_context: context,
    maxSteps: 10,
    onStepFinish: ({ toolResults }) => {
      // After each step, add any discovered tools
      if (context.discoveredTools.length > 0) {
        for (const tool of context.discoveredTools) {
          activeTools[tool.name] = tool;
        }
        context.discoveredTools = [];
      }
    },
  });

  return result;
}
```

### MCP Integration

```typescript
// MCP toolset with deferred loading
const mcpConfig = {
  type: 'mcp_toolset',
  mcp_server_name: 'github-server',
  default_config: {
    defer_loading: true,  // All tools deferred by default
  },
  configs: {
    // Exceptions - frequently used tools always loaded
    'github_get_repo': { defer_loading: false },
    'github_list_issues': { defer_loading: false },
  },
};
```

## Benchmarks & Performance

### Token Savings (Spring AI Study)

| Model | Without TST | With TST | Savings |
|-------|-------------|----------|---------|
| Gemini Pro | 15,234 tokens | 5,280 tokens | **65%** |
| GPT-4o-mini | 12,891 tokens | 8,508 tokens | **34%** |
| Claude Sonnet | 14,102 tokens | 6,890 tokens | **51%** |

*TST = Tool Search Tool, tested with 28 tools*

### Retrieval Accuracy (Arcade Study - 4,027 tools)

| Method | Retrieval Accuracy | Selection Accuracy |
|--------|-------------------|-------------------|
| Regex | 39% | 30% |
| BM25 | 48% | 34% |
| Semantic | 85% | 78% |
| Hybrid (Semantic+BM25) | 98% | 94% |

### Latency Impact

| Configuration | Avg Request Time | Requests per Task |
|---------------|------------------|-------------------|
| All tools upfront | 8.2s | 3-4 |
| Tool search (BM25) | 12.1s | 4-5 |
| Tool search (Semantic) | 10.5s | 4-5 |

*Tool search adds ~1 extra request but reduces total tokens significantly*

## When to Use This Pattern

### ✅ Use Tool Search When:

1. **Large Tool Libraries** (10+ tools)
   - Tool definitions consume >10K tokens
   - MCP servers adding many tools

2. **Variable Tool Usage**
   - Different tools needed per conversation
   - Most tools unused in any given request

3. **Scaling to Enterprise**
   - 50-1000+ tools across services
   - Multiple MCP servers connected

4. **Token Cost Concerns**
   - High-volume production systems
   - Cost per token matters

### ❌ Don't Use When:

1. **Small Tool Sets** (<10 tools)
   - Overhead not worth it
   - All tools likely used regularly

2. **Fixed Tool Requirements**
   - Same tools always needed
   - No variation in tool usage

3. **Latency Critical**
   - Extra search round-trip unacceptable
   - Real-time response required

4. **Simple Use Cases**
   - Single-purpose agents
   - <100 tokens of tool definitions

## Production Best Practices

### 1. Optimize Tool Descriptions for Search

```typescript
// ❌ Bad - generic, hard to find
{
  name: 'process',
  description: 'Processes data',
}

// ✅ Good - specific, keyword-rich
{
  name: 'process_payment',
  description: 'Process payment transaction via Stripe. Handles credit cards, ACH transfers, and refunds. Supports USD, EUR, GBP currencies.',
  tags: ['payment', 'stripe', 'transaction', 'credit-card', 'refund'],
}
```

### 2. Keep Frequently Used Tools Non-Deferred

```typescript
// Identify your 3-5 most used tools and keep them always loaded
const frequentlyUsedTools = [
  'get_page',      // 45% of requests
  'update_page',   // 30% of requests
  'search_pages',  // 20% of requests
];

const tools = allTools.map(tool => ({
  ...tool,
  defer_loading: !frequentlyUsedTools.includes(tool.name),
}));
```

### 3. Use Hybrid Search in Production

```typescript
// Production-ready hybrid search configuration
const productionSearcher = new HybridToolSearch({
  semanticWeight: 0.7,      // Favor semantic for conceptual matches
  bm25Weight: 0.3,          // BM25 for exact keyword matches
  embeddingModel: 'text-embedding-3-small',
  indexRefreshInterval: 300_000, // Re-index every 5 minutes
  cacheResults: true,
  cacheTTL: 60_000,         // 1 minute cache
});
```

### 4. Monitor Search Quality

```typescript
// Track search effectiveness
interface SearchMetrics {
  query: string;
  resultsReturned: string[];
  toolActuallyUsed: string | null;
  wasInResults: boolean;
  searchLatency: number;
}

function trackSearchQuality(metrics: SearchMetrics) {
  // Log for analysis
  logger.info('tool_search_quality', metrics);

  // Alert if retrieval accuracy drops
  if (!metrics.wasInResults && metrics.toolActuallyUsed) {
    alerting.warn('tool_search_miss', {
      query: metrics.query,
      expectedTool: metrics.toolActuallyUsed,
    });
  }
}
```

## Key Takeaways

1. **Token savings of 34-64%**: Dynamic loading dramatically reduces context usage
2. **Accuracy depends on search method**: Hybrid semantic+BM25 achieves 94% vs 34% for keyword-only
3. **Keep 3-5 tools non-deferred**: Most frequently used tools should always be available
4. **Invest in tool descriptions**: Search quality depends on rich, keyword-rich descriptions
5. **Monitor retrieval accuracy**: Track whether the right tools are being discovered
6. **Scale to thousands**: Pattern enables 1,000+ tools without context explosion

## References

1. **Anthropic** (2025). "Tool Search Tool". [platform.claude.com](https://platform.claude.com/docs/en/agents-and-tools/tool-use/tool-search-tool)
2. **Tzolov, C.** (2025). "Smart Tool Selection: Achieving 34-64% Token Savings with Spring AI's Dynamic Tool Discovery". [spring.io](https://spring.io/blog/2025/12/11/spring-ai-tool-search-tools-tzolov/)
3. **Stacklok** (2025). "MCP Optimizer vs Anthropic Tool Search Tool: Head-to-Head". [dev.to](https://dev.to/stacklok/stackloks-mcp-optimizer-vs-anthropics-tool-search-tool-a-head-to-head-comparison-2f32)
4. **Arcade** (2025). "Anthropic Tool Search Test: 4,000 Tools, 60% Success". [arcade.dev](https://blog.arcade.dev/anthropic-tool-search-4000-tools-test)

**Related Topics**: [3.3.2 Tool Registry](./3.3.2-tool-registry.md), [5.3.5 Fusion Strategies](../5-rag/5.3.5-fusion.md)

**Layer Index**: [Layer 3: Agent Architecture](../AI_KNOWLEDGE_BASE_TOC.md#layer-3-agent-architecture)
