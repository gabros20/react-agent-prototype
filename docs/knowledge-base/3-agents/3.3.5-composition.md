# 3.3.5 - Tool Composition

> **Layer**: Agent Architecture | **Topic**: Tool System
> **Version**: 2.0 | **Date Verified**: December 2025

---

## TL;DR

**Tool composition enables complex workflows by combining multiple tools in sequence, parallel, or conditional patterns.** Rather than monolithic tools, composition builds sophisticated behaviors from simple, reusable building blocks.

### Key Takeaways

- **Parallel execution** achieves 2-5× speedup for independent tasks
- **Hybrid patterns** (sequential + parallel) are optimal for most workflows
- **Map-reduce** scales to 100+ concurrent operations
- **AI SDK v6** handles parallel tool calls automatically with `stopWhen: stepCountIs()`
- **Workflow orchestration** manages complex multi-step dependencies

---

## Why It Matters

### The Problem

Without composition, tools become monolithic:

```typescript
// ❌ BAD: Monolithic tool that does everything
const cms_createPublishAndNotify = tool({
  description: 'Creates page, adds content, publishes, and sends notifications',
  execute: async (input) => {
    // 200+ lines of tightly coupled logic
    // Can't reuse any part independently
    // Hard to test, debug, or modify
  },
});
```

**Problems:**
- Can't reuse individual steps
- Hard to test in isolation
- One failure breaks everything
- Token-heavy tool descriptions

### Research Evidence

| Finding | Source | Year |
|---------|--------|------|
| **Parallel execution** achieves 2-5× speedup | AI SDK | 2025 |
| **Monoidal structures** provide formal composition framework | LightcapAI | Nov 2025 |
| **Hybrid sequential+parallel** optimal for complex workflows | Skywork.ai | Sep 2025 |
| **Map-reduce patterns** scale to 100+ concurrent operations | Industry practice | 2025 |
| **Proper composition reduces token usage by 30-40%** | Production metrics | 2025 |

---

## Core Concepts

### Composition Patterns

```
┌─────────────────────────────────────────────────────────────┐
│                 TOOL COMPOSITION PATTERNS                    │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. SEQUENTIAL (A → B → C)                                  │
│     └─ Steps depend on previous results                     │
│                                                              │
│  2. PARALLEL (A ⊗ B ⊗ C)                                    │
│     └─ Independent tasks run simultaneously                 │
│                                                              │
│  3. MAP-REDUCE                                              │
│     └─ Apply operation to collection, then aggregate        │
│                                                              │
│  4. CONDITIONAL (if-then-else)                              │
│     └─ Different paths based on runtime conditions          │
│                                                              │
│  5. HYBRID (Sequential + Parallel)                          │
│     └─ Combine patterns for optimal performance             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Pattern Selection Guide

```
When choosing a pattern:

1. Are tasks dependent on each other?
   ├─ Yes → Sequential
   └─ No → Continue...

2. Can tasks run simultaneously?
   ├─ Yes → Parallel
   └─ Some → Hybrid

3. Processing a collection?
   └─ Yes → Map-Reduce

4. Need branching logic?
   └─ Yes → Conditional
```

---

## Implementation Guide

### Step-by-Step

#### 1. Sequential Composition (A → B → C)

```typescript
// server/workflows/sequential.ts
// Use when: Steps have strict dependencies

async function createAndPublishPage(
  title: string,
  content: string,
  ctx: AgentContext
): Promise<{ pageId: string; url: string }> {
  // Step 1: Create page
  const createResult = await ctx.cmsService.createPage({
    title,
    status: 'draft',
  });

  if (!createResult.success) {
    throw new Error(`Failed to create page: ${createResult.error}`);
  }

  const pageId = createResult.page.id;

  // Step 2: Update content (depends on pageId)
  const updateResult = await ctx.cmsService.updatePage(pageId, { content });

  if (!updateResult.success) {
    throw new Error(`Failed to update content: ${updateResult.error}`);
  }

  // Step 3: Publish (depends on content being added)
  const publishResult = await ctx.cmsService.publishPage(pageId);

  if (!publishResult.success) {
    throw new Error(`Failed to publish: ${publishResult.error}`);
  }

  return {
    pageId,
    url: publishResult.url,
  };
}
```

**Characteristics:**
- ✅ Simple to understand and debug
- ✅ Clear data flow
- ❌ Slower (serial execution)
- ❌ One failure blocks entire chain

#### 2. Parallel Composition (A ⊗ B ⊗ C)

```typescript
// server/workflows/parallel.ts
// Use when: Tasks are independent and can run concurrently

async function fetchMultiplePages(
  pageIds: string[],
  ctx: AgentContext
): Promise<Page[]> {
  // Execute all fetches in parallel
  const results = await Promise.all(
    pageIds.map(id =>
      ctx.cmsService.getPage(id, 'summary')
    )
  );

  // Filter successful results
  return results.filter((r): r is Page => r !== null);
}

// With error handling
async function fetchPagesWithErrors(
  pageIds: string[],
  ctx: AgentContext
): Promise<{ pages: Page[]; errors: string[] }> {
  const results = await Promise.allSettled(
    pageIds.map(id => ctx.cmsService.getPage(id, 'full'))
  );

  const pages: Page[] = [];
  const errors: string[] = [];

  results.forEach((result, i) => {
    if (result.status === 'fulfilled' && result.value) {
      pages.push(result.value);
    } else {
      errors.push(`Failed to fetch ${pageIds[i]}`);
    }
  });

  return { pages, errors };
}
```

**Characteristics:**
- ✅ 2-5× faster than sequential
- ✅ Better resource utilization
- ✅ Resilient (one failure doesn't block others)
- ❌ Harder to debug
- ❌ Potential race conditions

#### 3. Map-Reduce Pattern

```typescript
// server/workflows/map-reduce.ts
// Use when: Batch operations on collections

async function analyzeSentimentBatch(
  documentIds: string[],
  ctx: AgentContext
): Promise<{ overall: number; details: Array<{ id: string; sentiment: number }> }> {
  // Map phase: Parallel analysis
  const sentiments = await Promise.all(
    documentIds.map(async (id) => {
      const doc = await ctx.cmsService.getPage(id, 'full');
      if (!doc) return { id, sentiment: 0 };

      const analysis = await ctx.aiService.analyzeSentiment(doc.content);

      return {
        id,
        sentiment: analysis.score,
      };
    })
  );

  // Reduce phase: Aggregate results
  const overall = sentiments.reduce((sum, s) => sum + s.sentiment, 0) / sentiments.length;

  return {
    overall,
    details: sentiments,
  };
}
```

#### 4. Conditional Composition (if-then-else)

```typescript
// server/workflows/conditional.ts
// Use when: Business logic requires branching

async function upsertPage(
  slug: string,
  title: string,
  content: string,
  ctx: AgentContext
): Promise<Page> {
  // Check if page exists
  const existing = await ctx.cmsService.findBySlug(slug);

  if (existing) {
    // Page exists → Update
    const updateResult = await ctx.cmsService.updatePage(existing.id, {
      title,
      content,
    });

    return updateResult.page;
  } else {
    // Page doesn't exist → Create
    const createResult = await ctx.cmsService.createPage({
      title,
      content,
      slug,
      status: 'draft',
    });

    return createResult.page;
  }
}
```

#### 5. Hybrid Pattern (Sequential + Parallel)

```typescript
// server/workflows/hybrid.ts
// Use when: Complex workflows with mixed dependencies

async function processUserDashboard(
  userId: string,
  ctx: AgentContext
): Promise<DashboardData> {
  // Stage 1: Sequential (must happen first)
  const user = await ctx.userService.getUser(userId);

  if (!user) {
    throw new Error(`User not found: ${userId}`);
  }

  // Stage 2: Parallel (independent operations using user data)
  const [orders, preferences, activity] = await Promise.all([
    ctx.orderService.getOrders(user.id),
    ctx.userService.getPreferences(user.id),
    ctx.activityService.getLog(user.id, { limit: 100 }),
  ]);

  // Stage 3: Sequential (depends on all parallel results)
  const recommendations = await ctx.aiService.generateRecommendations({
    user,
    orders,
    preferences,
    recentActivity: activity,
  });

  // Stage 4: Parallel (independent side effects)
  await Promise.all([
    ctx.emailService.queueDigest(user.email, recommendations),
    ctx.analyticsService.track('dashboard_viewed', { userId: user.id }),
  ]);

  return {
    user,
    orders,
    preferences,
    recommendations,
  };
}
```

---

## Framework Integration

### AI SDK v6 Multi-Step Execution

```typescript
import { generateText, tool, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';

// AI SDK v6 handles tool composition automatically
const result = await generateText({
  model: openai('gpt-4o'),
  prompt: 'Get weather for San Francisco, Los Angeles, and New York',

  tools: {
    getWeather: tool({
      description: 'Gets current weather for a city',
      inputSchema: z.object({
        city: z.string().describe('City name'),
      }),
      execute: async ({ city }) => {
        return await fetchWeather(city);
      },
    }),
  },

  // v6: Use stopWhen instead of maxSteps
  stopWhen: stepCountIs(10),

  experimental_context: context,
});

// AI SDK automatically:
// 1. Identifies need for parallel calls (3 cities)
// 2. Executes getWeather 3 times in parallel
// 3. Waits for all to complete
// 4. Synthesizes results into response
```

### Workflow Orchestrator Pattern

```typescript
// server/workflows/orchestrator.ts
interface WorkflowStep {
  name: string;
  tool: string;
  params: Record<string, any>;
  dependsOn?: string[]; // Step names
}

export class WorkflowOrchestrator {
  constructor(private toolRegistry: ToolRegistry) {}

  async execute(steps: WorkflowStep[]): Promise<Map<string, any>> {
    const results = new Map<string, any>();
    const executed = new Set<string>();

    // Topological sort for execution order
    const order = this.topologicalSort(steps);

    for (const step of order) {
      // Wait for dependencies
      if (step.dependsOn?.length) {
        const pending = step.dependsOn.filter(dep => !executed.has(dep));
        if (pending.length > 0) {
          throw new Error(`Unmet dependencies: ${pending.join(', ')}`);
        }
      }

      // Resolve parameters (may reference previous results)
      const params = this.resolveParams(step.params, results);

      // Execute step
      const tool = this.toolRegistry.get(step.tool);
      if (!tool) {
        throw new Error(`Tool not found: ${step.tool}`);
      }

      const result = await tool.execute(params);
      results.set(step.name, result);
      executed.add(step.name);
    }

    return results;
  }

  private resolveParams(
    params: Record<string, any>,
    results: Map<string, any>
  ): Record<string, any> {
    const resolved: Record<string, any> = {};

    for (const [key, value] of Object.entries(params)) {
      if (typeof value === 'string' && value.startsWith('$')) {
        // Reference to previous step result: $stepName.path.to.value
        const [stepName, ...pathParts] = value.slice(1).split('.');
        const stepResult = results.get(stepName);

        if (!stepResult) {
          throw new Error(`Step result not found: ${stepName}`);
        }

        resolved[key] = pathParts.length
          ? this.getPath(stepResult, pathParts.join('.'))
          : stepResult;
      } else {
        resolved[key] = value;
      }
    }

    return resolved;
  }

  private getPath(obj: any, path: string): any {
    return path.split('.').reduce((curr, key) => curr?.[key], obj);
  }

  private topologicalSort(steps: WorkflowStep[]): WorkflowStep[] {
    const sorted: WorkflowStep[] = [];
    const visited = new Set<string>();

    const visit = (step: WorkflowStep) => {
      if (visited.has(step.name)) return;

      if (step.dependsOn) {
        for (const depName of step.dependsOn) {
          const dep = steps.find(s => s.name === depName);
          if (dep) visit(dep);
        }
      }

      visited.add(step.name);
      sorted.push(step);
    };

    steps.forEach(visit);
    return sorted;
  }
}

// Usage
const orchestrator = new WorkflowOrchestrator(toolRegistry);

const results = await orchestrator.execute([
  {
    name: 'fetchUser',
    tool: 'getUser',
    params: { userId: '123' },
  },
  {
    name: 'fetchOrders',
    tool: 'getOrders',
    params: { userId: '$fetchUser.id' },
    dependsOn: ['fetchUser'],
  },
  {
    name: 'generateRecommendations',
    tool: 'recommend',
    params: {
      user: '$fetchUser',
      orders: '$fetchOrders.items',
    },
    dependsOn: ['fetchUser', 'fetchOrders'],
  },
]);
```

### Retry with Fallback

```typescript
// server/lib/resilience.ts
async function withRetryAndFallback<T>(
  primary: () => Promise<T>,
  fallback: () => Promise<T>,
  options: { maxRetries?: number; backoff?: number } = {}
): Promise<T> {
  const { maxRetries = 3, backoff = 1000 } = options;
  let lastError: Error | null = null;

  // Try primary with retries
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await primary();
    } catch (error) {
      lastError = error as Error;
      console.warn(`Primary failed (attempt ${i + 1}/${maxRetries}):`, error);

      // Exponential backoff
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * backoff));
    }
  }

  // Primary exhausted, try fallback
  console.warn('Primary exhausted, using fallback');
  try {
    return await fallback();
  } catch (fallbackError) {
    throw new Error(
      `Both primary and fallback failed. Primary: ${lastError?.message}`
    );
  }
}
```

---

## Testing Strategy

### Unit Testing Compositions

```typescript
// server/workflows/__tests__/hybrid.test.ts
import { describe, it, expect, vi } from 'vitest';
import { processUserDashboard } from '../hybrid';

describe('processUserDashboard', () => {
  const createMockContext = () => ({
    userService: {
      getUser: vi.fn(),
      getPreferences: vi.fn(),
    },
    orderService: {
      getOrders: vi.fn(),
    },
    activityService: {
      getLog: vi.fn(),
    },
    aiService: {
      generateRecommendations: vi.fn(),
    },
    emailService: {
      queueDigest: vi.fn(),
    },
    analyticsService: {
      track: vi.fn(),
    },
  });

  it('executes parallel phase concurrently', async () => {
    const ctx = createMockContext();
    const callOrder: string[] = [];

    // Track call order
    ctx.userService.getUser.mockImplementation(async () => {
      callOrder.push('getUser');
      return { id: 'user-1', email: 'test@example.com' };
    });

    ctx.orderService.getOrders.mockImplementation(async () => {
      callOrder.push('getOrders-start');
      await new Promise(r => setTimeout(r, 50));
      callOrder.push('getOrders-end');
      return [];
    });

    ctx.userService.getPreferences.mockImplementation(async () => {
      callOrder.push('getPreferences-start');
      await new Promise(r => setTimeout(r, 50));
      callOrder.push('getPreferences-end');
      return {};
    });

    ctx.activityService.getLog.mockImplementation(async () => {
      callOrder.push('getActivity-start');
      await new Promise(r => setTimeout(r, 50));
      callOrder.push('getActivity-end');
      return [];
    });

    ctx.aiService.generateRecommendations.mockResolvedValue([]);

    await processUserDashboard('user-1', ctx as any);

    // Sequential: getUser must complete first
    expect(callOrder[0]).toBe('getUser');

    // Parallel: all three should start before any ends
    const startIndices = [
      callOrder.indexOf('getOrders-start'),
      callOrder.indexOf('getPreferences-start'),
      callOrder.indexOf('getActivity-start'),
    ];
    const endIndices = [
      callOrder.indexOf('getOrders-end'),
      callOrder.indexOf('getPreferences-end'),
      callOrder.indexOf('getActivity-end'),
    ];

    // All starts should happen before any end
    expect(Math.max(...startIndices)).toBeLessThan(Math.min(...endIndices));
  });

  it('handles partial failures in parallel phase', async () => {
    const ctx = createMockContext();
    ctx.userService.getUser.mockResolvedValue({ id: 'user-1' });
    ctx.orderService.getOrders.mockRejectedValue(new Error('Order service down'));
    ctx.userService.getPreferences.mockResolvedValue({});
    ctx.activityService.getLog.mockResolvedValue([]);

    // Should throw because orders failed
    await expect(processUserDashboard('user-1', ctx as any)).rejects.toThrow();
  });
});
```

### Testing Workflow Orchestrator

```typescript
describe('WorkflowOrchestrator', () => {
  it('resolves parameter references', async () => {
    const mockRegistry = {
      get: vi.fn((name) => ({
        execute: vi.fn(async (params) => {
          if (name === 'getUser') return { id: 'user-123', name: 'John' };
          if (name === 'getOrders') return { items: [{ id: 'order-1' }] };
          return params;
        }),
      })),
    };

    const orchestrator = new WorkflowOrchestrator(mockRegistry as any);

    const results = await orchestrator.execute([
      { name: 'user', tool: 'getUser', params: { id: '123' } },
      {
        name: 'orders',
        tool: 'getOrders',
        params: { userId: '$user.id' },
        dependsOn: ['user'],
      },
    ]);

    expect(mockRegistry.get('getOrders').execute).toHaveBeenCalledWith({
      userId: 'user-123',
    });
  });
});
```

---

## Common Pitfalls

### ❌ Avoid

| Pitfall | Problem | Solution |
|---------|---------|----------|
| Over-parallelizing | Diminishing returns after ~10 concurrent | Batch large collections |
| Ignoring errors | Silent failures propagate | Use `Promise.allSettled` for resilience |
| Circular dependencies | Deadlock | Use topological sort in orchestrator |
| Deep nesting | Hard to debug | Flatten with orchestrator pattern |
| Missing timeouts | Hanging workflows | Add timeout wrapper to each step |
| Hardcoded workflows | Inflexible | Use declarative orchestration |

### ✅ Best Practices

1. **Parallelize independent tasks** - 2-5× speedup is worth the complexity
2. **Use sequential for dependencies** - Clear data flow, easy debugging
3. **Implement retry logic** - Production resilience
4. **Add fallback options** - Graceful degradation
5. **Track execution time** - Identify bottlenecks
6. **Handle partial failures** - Don't fail entire workflow for one step

---

## Summary

### Quick Reference

```typescript
// Pattern Selection
const pattern = {
  // Strict dependencies
  sequential: async () => {
    const a = await stepA();
    const b = await stepB(a);
    return stepC(b);
  },

  // Independent tasks
  parallel: async () => {
    return Promise.all([stepA(), stepB(), stepC()]);
  },

  // Batch with aggregation
  mapReduce: async (items: Item[]) => {
    const results = await Promise.all(items.map(process));
    return results.reduce(aggregate, initial);
  },

  // Mixed dependencies
  hybrid: async () => {
    const prerequisite = await stepA();
    const [b, c] = await Promise.all([stepB(prerequisite), stepC(prerequisite)]);
    return stepD(b, c);
  },
};
```

### Performance Comparison

| Pattern | Steps | Sequential Time | Optimized Time | Speedup |
|---------|-------|-----------------|----------------|---------|
| **Pure Sequential** | 5 | 5000ms | 5000ms | 1.0× |
| **Pure Parallel** | 5 | 5000ms | 1000ms | 5.0× |
| **Hybrid (3+2)** | 5 | 5000ms | 2000ms | 2.5× |
| **Map-Reduce (10)** | 10 | 10000ms | 1500ms | 6.7× |

*Assumptions: Each step takes 1000ms, 100ms overhead per parallel batch*

---

## Related Topics

- [3.3.1 - Tool Definition](./3.3.1-tool-definition.md) - Creating well-structured tools
- [3.3.2 - Tool Registry](./3.3.2-tool-registry.md) - Organizing and discovering tools
- [3.3.3 - Context Injection](./3.3.3-context-injection.md) - Passing runtime data to tools
- [3.3.4 - Result Validation](./3.3.4-result-validation.md) - Verifying tool execution

---

## Research Citations

1. **AI SDK v6** - "Multi-Step Interfaces" (2025)
   https://v6.ai-sdk.dev/docs/ai-sdk-core/generating-text#multi-step-calls

2. **AI SDK** - "Cookbook: Call Tools in Parallel" (2025)
   https://ai-sdk.dev/cookbook/rsc/call-tools-in-parallel

3. **LightcapAI** - "Composing Tools with Monoidal Structures in GPT-4 Function Calling" (Nov 2025)
   https://lightcapai.medium.com/composing-tools-with-monoidal-structures-in-gpt-4

4. **Skywork.ai** - "Design Patterns for AI Agents: Orchestration & Handoffs" (Sep 2025)
   https://skywork.ai/blog/ai-agent-orchestration-best-practices-handoffs/

5. **Neel Shah** - "Concurrent vs. Parallel Execution in LLM API Calls" (Aug 2025)
   https://medium.com/@neeldevenshah/concurrent-vs-parallel-execution-in-llm-api-calls
