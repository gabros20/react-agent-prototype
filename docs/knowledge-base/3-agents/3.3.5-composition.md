# 3.3.5 - Tool Composition

> **Layer**: Agent Architecture | **Topic**: Tool Calling & Execution
> **Status**: Verified | **Last Updated**: December 2025
> **Prerequisites**: [3.3.1 Tool Definition](./3.3.1-tool-definition.md)
> **Grounded In**: AI SDK v6 multi-step patterns, distributed systems composition

## TL;DR

**Tool composition enables complex workflows by combining multiple tools in sequence, parallel, or conditional patterns.** Rather than monolithic tools, composition builds sophisticated behaviors from simple, reusable building blocks.

**Key Takeaways**
- **Parallel execution** achieves 2-5× speedup for independent tasks
- **Hybrid patterns** (sequential + parallel) are optimal for most workflows
- **Map-reduce** scales to 100+ concurrent operations
- **AI SDK v6** handles parallel tool calls automatically with `stopWhen: stepCountIs()`
- **Workflow orchestration** manages complex multi-step dependencies

## Why It Matters

**The Problem**

Without composition, tools become monolithic:

```typescript
// ❌ BAD: Monolithic tool that does everything
const createPublishAndNotify = tool({
  description: 'Creates page, adds content, publishes, and sends notifications',
  execute: async (input) => {
    // 200+ lines of tightly coupled logic
    // Can't reuse any part independently
    // Hard to test, debug, or modify
  },
});
```

**Problems:**
- Can't reuse individual steps
- Hard to test in isolation
- One failure breaks everything
- Token-heavy tool descriptions

**Research Evidence**

| Finding | Source | Year |
|---------|--------|------|
| **Parallel execution** achieves 2-5× speedup | AI SDK | 2025 |
| **Monoidal structures** provide formal composition framework | LightcapAI | Nov 2025 |
| **Hybrid sequential+parallel** optimal for complex workflows | Skywork.ai | Sep 2025 |
| **Map-reduce patterns** scale to 100+ concurrent operations | Industry practice | 2025 |
| **Proper composition reduces token usage by 30-40%** | Production metrics | 2025 |

## Core Concepts

### Composition Patterns

```
┌─────────────────────────────────────────────────────────────┐
│                 TOOL COMPOSITION PATTERNS                    │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. SEQUENTIAL (A → B → C)                                  │
│     └─ Steps depend on previous results                     │
│                                                              │
│  2. PARALLEL (A ⊗ B ⊗ C)                                    │
│     └─ Independent tasks run simultaneously                 │
│                                                              │
│  3. MAP-REDUCE                                              │
│     └─ Apply operation to collection, then aggregate        │
│                                                              │
│  4. CONDITIONAL (if-then-else)                              │
│     └─ Different paths based on runtime conditions          │
│                                                              │
│  5. HYBRID (Sequential + Parallel)                          │
│     └─ Combine patterns for optimal performance             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Pattern Selection Guide

```
When choosing a pattern:

1. Are tasks dependent on each other?
   ├─ Yes → Sequential
   └─ No → Continue...

2. Can tasks run simultaneously?
   ├─ Yes → Parallel
   └─ Some → Hybrid

3. Processing a collection?
   └─ Yes → Map-Reduce

4. Need branching logic?
   └─ Yes → Conditional
```

## Implementation Patterns

### Sequential Composition (A → B → C)

```typescript
// Use when: Steps have strict dependencies
async function createAndPublishPage(
  title: string,
  content: string,
  ctx: AgentContext
): Promise<{ pageId: string; url: string }> {
  // Step 1: Create page
  const page = await ctx.cmsService.createPage({ title, status: 'draft' });

  // Step 2: Update content (depends on pageId)
  await ctx.cmsService.updatePage(page.id, { content });

  // Step 3: Publish (depends on content being added)
  const publishResult = await ctx.cmsService.publishPage(page.id);

  return { pageId: page.id, url: publishResult.url };
}
```

**Characteristics:**
- ✅ Simple to understand and debug
- ✅ Clear data flow
- ❌ Slower (serial execution)
- ❌ One failure blocks entire chain

### Parallel Composition (A ⊗ B ⊗ C)

```typescript
// Use when: Tasks are independent and can run concurrently
async function fetchMultiplePages(
  pageIds: string[],
  ctx: AgentContext
): Promise<Page[]> {
  // Execute all fetches in parallel
  const results = await Promise.all(
    pageIds.map(id => ctx.cmsService.getPage(id, 'summary'))
  );

  return results.filter((r): r is Page => r !== null);
}

// With error handling
async function fetchPagesWithErrors(
  pageIds: string[],
  ctx: AgentContext
): Promise<{ pages: Page[]; errors: string[] }> {
  const results = await Promise.allSettled(
    pageIds.map(id => ctx.cmsService.getPage(id, 'full'))
  );

  const pages: Page[] = [];
  const errors: string[] = [];

  results.forEach((result, i) => {
    if (result.status === 'fulfilled' && result.value) {
      pages.push(result.value);
    } else {
      errors.push(`Failed to fetch ${pageIds[i]}`);
    }
  });

  return { pages, errors };
}
```

**Characteristics:**
- ✅ 2-5× faster than sequential
- ✅ Better resource utilization
- ✅ Resilient (one failure doesn't block others)
- ❌ Harder to debug
- ❌ Potential race conditions

### Map-Reduce Pattern

```typescript
// Use when: Batch operations on collections
async function analyzeSentimentBatch(
  documentIds: string[],
  ctx: AgentContext
): Promise<{ overall: number; details: Array<{ id: string; score: number }> }> {
  // Map phase: Parallel analysis
  const sentiments = await Promise.all(
    documentIds.map(async (id) => {
      const doc = await ctx.cmsService.getPage(id, 'full');
      if (!doc) return { id, score: 0 };

      const analysis = await ctx.aiService.analyzeSentiment(doc.content);
      return { id, score: analysis.score };
    })
  );

  // Reduce phase: Aggregate results
  const overall = sentiments.reduce((sum, s) => sum + s.score, 0) / sentiments.length;

  return { overall, details: sentiments };
}
```

### Conditional Composition (if-then-else)

```typescript
// Use when: Business logic requires branching
async function upsertPage(
  slug: string,
  title: string,
  content: string,
  ctx: AgentContext
): Promise<Page> {
  const existing = await ctx.cmsService.findBySlug(slug);

  if (existing) {
    // Update existing
    return ctx.cmsService.updatePage(existing.id, { title, content });
  } else {
    // Create new
    return ctx.cmsService.createPage({ title, content, slug, status: 'draft' });
  }
}
```

### Hybrid Pattern (Sequential + Parallel)

```typescript
// Use when: Complex workflows with mixed dependencies
async function processUserDashboard(
  userId: string,
  ctx: AgentContext
): Promise<DashboardData> {
  // Stage 1: Sequential (must happen first)
  const user = await ctx.userService.getUser(userId);
  if (!user) throw new Error(`User not found: ${userId}`);

  // Stage 2: Parallel (independent operations using user data)
  const [orders, preferences, activity] = await Promise.all([
    ctx.orderService.getOrders(user.id),
    ctx.userService.getPreferences(user.id),
    ctx.activityService.getLog(user.id, { limit: 100 }),
  ]);

  // Stage 3: Sequential (depends on all parallel results)
  const recommendations = await ctx.aiService.generateRecommendations({
    user, orders, preferences, recentActivity: activity,
  });

  // Stage 4: Parallel (independent side effects)
  await Promise.all([
    ctx.emailService.queueDigest(user.email, recommendations),
    ctx.analyticsService.track('dashboard_viewed', { userId: user.id }),
  ]);

  return { user, orders, preferences, recommendations };
}
```

## Framework Integration

### AI SDK v6 Multi-Step Execution

```typescript
import { generateText, tool, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';

// AI SDK v6 handles tool composition automatically
const result = await generateText({
  model: openai('gpt-4o'),
  prompt: 'Get weather for San Francisco, Los Angeles, and New York',

  tools: {
    getWeather: tool({
      description: 'Gets current weather for a city',
      inputSchema: z.object({
        city: z.string().describe('City name'),
      }),
      execute: async ({ city }) => fetchWeather(city),
    }),
  },

  // v6: Use stopWhen instead of maxSteps
  stopWhen: stepCountIs(10),
  experimental_context: context,
});

// AI SDK automatically:
// 1. Identifies need for parallel calls (3 cities)
// 2. Executes getWeather 3 times in parallel
// 3. Waits for all to complete
// 4. Synthesizes results into response
```

### Workflow Orchestrator Pattern

```typescript
interface WorkflowStep {
  name: string;
  tool: string;
  params: Record<string, any>;
  dependsOn?: string[];
}

export class WorkflowOrchestrator {
  constructor(private toolRegistry: ToolRegistry) {}

  async execute(steps: WorkflowStep[]): Promise<Map<string, any>> {
    const results = new Map<string, any>();
    const executed = new Set<string>();
    const order = this.topologicalSort(steps);

    for (const step of order) {
      // Wait for dependencies
      if (step.dependsOn?.some(dep => !executed.has(dep))) {
        throw new Error(`Unmet dependencies for ${step.name}`);
      }

      // Resolve params (may reference previous results)
      const params = this.resolveParams(step.params, results);

      // Execute
      const tool = this.toolRegistry.get(step.tool);
      const result = await tool.execute(params);
      results.set(step.name, result);
      executed.add(step.name);
    }

    return results;
  }

  private resolveParams(
    params: Record<string, any>,
    results: Map<string, any>
  ): Record<string, any> {
    const resolved: Record<string, any> = {};

    for (const [key, value] of Object.entries(params)) {
      if (typeof value === 'string' && value.startsWith('$')) {
        // Reference: $stepName.path.to.value
        const [stepName, ...pathParts] = value.slice(1).split('.');
        const stepResult = results.get(stepName);
        resolved[key] = pathParts.length
          ? this.getPath(stepResult, pathParts.join('.'))
          : stepResult;
      } else {
        resolved[key] = value;
      }
    }

    return resolved;
  }

  private getPath(obj: any, path: string): any {
    return path.split('.').reduce((curr, key) => curr?.[key], obj);
  }

  private topologicalSort(steps: WorkflowStep[]): WorkflowStep[] {
    // Kahn's algorithm for dependency ordering
    const sorted: WorkflowStep[] = [];
    const visited = new Set<string>();

    const visit = (step: WorkflowStep) => {
      if (visited.has(step.name)) return;

      step.dependsOn?.forEach(depName => {
        const dep = steps.find(s => s.name === depName);
        if (dep) visit(dep);
      });

      visited.add(step.name);
      sorted.push(step);
    };

    steps.forEach(visit);
    return sorted;
  }
}
```

## Testing Strategy

### Unit Testing Compositions

```typescript
import { describe, it, expect, vi } from 'vitest';
import { processUserDashboard } from './hybrid';

describe('processUserDashboard', () => {
  const createMockContext = () => ({
    userService: { getUser: vi.fn(), getPreferences: vi.fn() },
    orderService: { getOrders: vi.fn() },
    activityService: { getLog: vi.fn() },
    aiService: { generateRecommendations: vi.fn() },
    emailService: { queueDigest: vi.fn() },
    analyticsService: { track: vi.fn() },
  });

  it('executes parallel phase concurrently', async () => {
    const ctx = createMockContext();
    const callOrder: string[] = [];

    ctx.userService.getUser.mockImplementation(async () => {
      callOrder.push('getUser');
      return { id: 'user-1', email: 'test@example.com' };
    });

    ctx.orderService.getOrders.mockImplementation(async () => {
      callOrder.push('getOrders-start');
      await new Promise(r => setTimeout(r, 50));
      callOrder.push('getOrders-end');
      return [];
    });

    ctx.userService.getPreferences.mockImplementation(async () => {
      callOrder.push('getPreferences-start');
      await new Promise(r => setTimeout(r, 50));
      callOrder.push('getPreferences-end');
      return {};
    });

    ctx.activityService.getLog.mockImplementation(async () => {
      callOrder.push('getActivity-start');
      await new Promise(r => setTimeout(r, 50));
      callOrder.push('getActivity-end');
      return [];
    });

    ctx.aiService.generateRecommendations.mockResolvedValue([]);

    await processUserDashboard('user-1', ctx as any);

    // Sequential: getUser must complete first
    expect(callOrder[0]).toBe('getUser');

    // Parallel: all three should start before any ends
    const startIndices = [
      callOrder.indexOf('getOrders-start'),
      callOrder.indexOf('getPreferences-start'),
      callOrder.indexOf('getActivity-start'),
    ];
    const endIndices = [
      callOrder.indexOf('getOrders-end'),
      callOrder.indexOf('getPreferences-end'),
      callOrder.indexOf('getActivity-end'),
    ];

    expect(Math.max(...startIndices)).toBeLessThan(Math.min(...endIndices));
  });
});
```

## Common Pitfalls

### ❌ Avoid

| Pitfall | Problem | Solution |
|---------|---------|----------|
| Over-parallelizing | Diminishing returns after ~10 concurrent | Batch large collections |
| Ignoring errors | Silent failures propagate | Use `Promise.allSettled` for resilience |
| Circular dependencies | Deadlock | Use topological sort in orchestrator |
| Deep nesting | Hard to debug | Flatten with orchestrator pattern |
| Missing timeouts | Hanging workflows | Add timeout wrapper to each step |
| Hardcoded workflows | Inflexible | Use declarative orchestration |

### ✅ Best Practices

1. **Parallelize independent tasks** - 2-5× speedup is worth the complexity
2. **Use sequential for dependencies** - Clear data flow, easy debugging
3. **Implement retry logic** - Production resilience
4. **Add fallback options** - Graceful degradation
5. **Track execution time** - Identify bottlenecks
6. **Handle partial failures** - Don't fail entire workflow for one step

## Quick Reference

### Pattern Selection

```typescript
// Pattern cheat sheet
const pattern = {
  // Strict dependencies
  sequential: async () => {
    const a = await stepA();
    const b = await stepB(a);
    return stepC(b);
  },

  // Independent tasks
  parallel: async () => {
    return Promise.all([stepA(), stepB(), stepC()]);
  },

  // Batch with aggregation
  mapReduce: async (items: Item[]) => {
    const results = await Promise.all(items.map(process));
    return results.reduce(aggregate, initial);
  },

  // Mixed dependencies
  hybrid: async () => {
    const prerequisite = await stepA();
    const [b, c] = await Promise.all([
      stepB(prerequisite),
      stepC(prerequisite)
    ]);
    return stepD(b, c);
  },
};
```

### Performance Comparison

| Pattern | Steps | Sequential Time | Optimized Time | Speedup |
|---------|-------|-----------------|----------------|---------|
| **Pure Sequential** | 5 | 5000ms | 5000ms | 1.0× |
| **Pure Parallel** | 5 | 5000ms | 1000ms | 5.0× |
| **Hybrid (3+2)** | 5 | 5000ms | 2000ms | 2.5× |
| **Map-Reduce (10)** | 10 | 10000ms | 1500ms | 6.7× |

*Assumptions: Each step takes 1000ms, 100ms overhead per parallel batch*

## Related Topics

- [3.3.1 - Tool Definition](./3.3.1-tool-definition.md) - Creating well-structured tools
- [3.3.2 - Tool Registry](./3.3.2-tool-registry.md) - Organizing and discovering tools
- [3.3.3 - Context Injection](./3.3.3-context-injection.md) - Passing runtime data to tools
- [3.3.4 - Result Validation](./3.3.4-result-validation.md) - Verifying tool execution

## Research & Resources

**Framework Documentation**
- AI SDK v6 - "Multi-Step Interfaces" (2025) - [v6.ai-sdk.dev](https://v6.ai-sdk.dev/docs/ai-sdk-core/generating-text#multi-step-calls)
- AI SDK - "Call Tools in Parallel" (2025) - [ai-sdk.dev](https://ai-sdk.dev/cookbook/rsc/call-tools-in-parallel)

**Academic Papers**
- LightcapAI - "Composing Tools with Monoidal Structures" (Nov 2025) - [medium.com](https://lightcapai.medium.com/composing-tools-with-monoidal-structures-in-gpt-4)

**Industry Resources**
- Skywork.ai - "AI Agent Orchestration Best Practices" (Sep 2025) - [skywork.ai](https://skywork.ai/blog/ai-agent-orchestration-best-practices-handoffs/)
- Neel Shah - "Concurrent vs. Parallel Execution in LLM API Calls" (Aug 2025) - [medium.com](https://medium.com/@neeldevenshah/concurrent-vs-parallel-execution-in-llm-api-calls)
