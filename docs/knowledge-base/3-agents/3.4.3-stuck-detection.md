# 3.4.3 - Stuck Detection

> **Layer**: Agent Architecture | **Topic**: Loop Control
> **Status**: Verified | **Last Updated**: December 2025
> **Prerequisites**: [3.4.1 Max Steps Limits](./3.4.1-max-steps.md)
> **Grounded In**: Autono framework, ReflAct, browser-use patterns

## TL;DR

**Stuck detection identifies when an agent is trapped in unproductive loops—repeating the same actions without progress.** Unlike max steps limits (which force termination), stuck detection **diagnoses and intervenes early**, saving costs and providing actionable feedback.

**Key Takeaways**
- **60% of agent failures** involve repetitive loops
- **Loop patterns**: 73% are action repetition, 27% are reasoning repetition
- **Early detection saves 85%** of wasted costs compared to max steps alone
- **Probabilistic penalty** reduces loop probability by 40-60% (Autono, Apr 2025)
- **HITL intervention** provides best user experience for recovery

## Why It Matters

**The Problem**

Without stuck detection, agents waste resources:

```typescript
// ❌ WITHOUT STUCK DETECTION
// Task: "Find the population of Tokyo"

// Step 1: scroll_down() → "Scrolled page"
// Step 2: scroll_down() → "Scrolled page"
// Step 3: scroll_down() → "Scrolled page"
// Step 4: scroll_down() → "Scrolled page"
// ... continues until max steps hit (20+ steps)

// Cost: $0.05 per step × 20 steps = $1.00 wasted
// Time: 60 seconds of stuck behavior
// User experience: Terrible
```

**Root causes:**
1. **Unclear success criteria** - Agent doesn't know what "done" looks like
2. **Missing tool feedback** - Tool doesn't indicate completion status
3. **Reasoning loops** - Agent repeats same thought without action
4. **No error adaptation** - Retries failed operations without changes

**Research Evidence**

| Finding | Source | Year |
|---------|--------|------|
| **60%** of agent failures involve repetitive loops | GitHub browser-use | Jan 2025 |
| **73%** are action loops, 27% reasoning loops | Autono framework | Apr 2025 |
| **Early detection saves 85%** of wasted costs | Production metrics | 2025 |
| **ReflAct** achieves 93.3% success with goal-state reflection | arXiv | May 2025 |

## Core Concepts

### Types of Stuck Behaviors

```
┌─────────────────────────────────────────────────────────────┐
│                    STUCK BEHAVIOR TYPES                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. ACTION REPETITION (73%)                                 │
│     └─ Same tool with same/similar parameters               │
│                                                              │
│  2. REASONING REPETITION (27%)                              │
│     └─ Same thought without taking action                   │
│                                                              │
│  3. ALTERNATING LOOPS                                       │
│     └─ Oscillates between two tools without progress        │
│                                                              │
│  4. FAILED RETRY LOOPS                                      │
│     └─ Retries failing operation without adapting           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Detection Strategies

```
Strategy              Accuracy    Cost      Best For
────────────────────────────────────────────────────
Exact Repetition      High        None      Obvious loops
Semantic Similarity   Medium      Low       Subtle variations
Progress Tracking     Very High   None      Complex tasks
Combined              Best        Low       Production
```

## Implementation Patterns

### Exact Action Repetition Detector

```typescript
interface ActionRecord {
  toolName: string;
  args: Record<string, any>;
  timestamp: number;
}

export class StuckDetector {
  private history: ActionRecord[] = [];
  private readonly REPETITION_THRESHOLD = 3;

  recordAction(toolName: string, args: Record<string, any>): void {
    this.history.push({ toolName, args, timestamp: Date.now() });
  }

  checkForLoop(): StuckStatus {
    if (this.history.length < this.REPETITION_THRESHOLD) {
      return { isStuck: false };
    }

    const lastN = this.history.slice(-this.REPETITION_THRESHOLD);

    const isStuck = lastN.every(action =>
      action.toolName === lastN[0].toolName &&
      JSON.stringify(action.args) === JSON.stringify(lastN[0].args)
    );

    if (isStuck) {
      return {
        isStuck: true,
        reason: 'exact_repetition',
        details: {
          toolName: lastN[0].toolName,
          args: lastN[0].args,
          repetitions: this.REPETITION_THRESHOLD,
        },
      };
    }

    return { isStuck: false };
  }

  reset(): void {
    this.history = [];
  }
}
```

### Progress-Based Detection

```typescript
interface ProgressMetrics {
  stepsCompleted: number;
  informationGathered: number;
  toolsSuccessfullyUsed: Set<string>;
  errorsEncountered: number;
  lastProgressTimestamp: number;
}

export class ProgressBasedStuckDetector {
  private metrics: ProgressMetrics = {
    stepsCompleted: 0,
    informationGathered: 0,
    toolsSuccessfullyUsed: new Set(),
    errorsEncountered: 0,
    lastProgressTimestamp: Date.now(),
  };

  private readonly PROGRESS_TIMEOUT_MS = 30000;
  private readonly MIN_PROGRESS_RATE = 0.3;
  private readonly MAX_ERROR_RATE = 0.5;

  recordStep(step: any): StuckStatus {
    this.metrics.stepsCompleted++;

    if (step.toolCalls) {
      for (const call of step.toolCalls) {
        if (call.result && !call.result.error) {
          this.metrics.toolsSuccessfullyUsed.add(call.toolName);
          const infoCount = this.extractInfoCount(call.result);
          if (infoCount > 0) {
            this.metrics.informationGathered += infoCount;
            this.metrics.lastProgressTimestamp = Date.now();
          }
        } else if (call.result?.error) {
          this.metrics.errorsEncountered++;
        }
      }
    }

    return this.checkIfStuck();
  }

  private checkIfStuck(): StuckStatus {
    // No progress for 30 seconds
    const timeSinceProgress = Date.now() - this.metrics.lastProgressTimestamp;
    if (timeSinceProgress > this.PROGRESS_TIMEOUT_MS) {
      return {
        isStuck: true,
        reason: 'no_progress',
        details: { timeSinceProgress, metrics: this.metrics },
      };
    }

    // Low progress rate
    const progressRate = this.metrics.informationGathered / this.metrics.stepsCompleted;
    if (this.metrics.stepsCompleted >= 5 && progressRate < this.MIN_PROGRESS_RATE) {
      return {
        isStuck: true,
        reason: 'low_progress_rate',
        details: { progressRate, metrics: this.metrics },
      };
    }

    // High error rate
    const errorRate = this.metrics.errorsEncountered / this.metrics.stepsCompleted;
    if (this.metrics.stepsCompleted >= 3 && errorRate > this.MAX_ERROR_RATE) {
      return {
        isStuck: true,
        reason: 'high_error_rate',
        details: { errorRate, metrics: this.metrics },
      };
    }

    return { isStuck: false };
  }

  private extractInfoCount(result: any): number {
    if (typeof result === 'string') return result.split('.').length;
    if (Array.isArray(result)) return result.length;
    if (typeof result === 'object') return Object.keys(result).length;
    return 0;
  }
}
```

### Composite Detector

```typescript
export interface StuckDetectionConfig {
  exactRepetitionThreshold: number;
  progressTimeoutMs: number;
  minProgressRate: number;
  maxErrorRate: number;
  enableHITL: boolean;
}

export const DEFAULT_CONFIG: StuckDetectionConfig = {
  exactRepetitionThreshold: 3,
  progressTimeoutMs: 30000,
  minProgressRate: 0.3,
  maxErrorRate: 0.5,
  enableHITL: true,
};

export class CompositeStuckDetector {
  private exactDetector: StuckDetector;
  private progressDetector: ProgressBasedStuckDetector;

  constructor(private config: StuckDetectionConfig = DEFAULT_CONFIG) {
    this.exactDetector = new StuckDetector();
    this.progressDetector = new ProgressBasedStuckDetector();
  }

  async checkStep(step: any): Promise<StuckStatus> {
    // 1. Check exact repetition
    if (step.toolCalls) {
      for (const call of step.toolCalls) {
        this.exactDetector.recordAction(call.toolName, call.args);
      }

      const repetitionStatus = this.exactDetector.checkForLoop();
      if (repetitionStatus.isStuck) return repetitionStatus;
    }

    // 2. Check progress
    const progressStatus = this.progressDetector.recordStep(step);
    if (progressStatus.isStuck) return progressStatus;

    return { isStuck: false };
  }

  reset(): void {
    this.exactDetector.reset();
  }
}
```

## Framework Integration

### AI SDK v6 Pattern

```typescript
import { generateText, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';

export async function runAgentWithStuckDetection(
  prompt: string,
  context: AgentContext
): Promise<AgentResult> {
  const detector = new CompositeStuckDetector();

  const result = await generateText({
    model: openai('gpt-4o'),
    prompt,
    tools: getAllTools(),
    stopWhen: stepCountIs(20),
    experimental_context: context,

    // Check for stuck loops after each step
    experimental_onStepFinish: async (step) => {
      const status = await detector.checkStep(step);

      if (status.isStuck) {
        context.logger?.warn('Stuck loop detected', status);

        // Option 1: Add guidance to next step
        context.addSystemMessage(`
          WARNING: You appear to be repeating the same action.
          Try a different approach or ask for help if stuck.
        `);

        // Option 2: Throw to stop immediately
        // throw new StuckLoopError(status.reason, status.details);
      }
    },
  });

  return { text: result.text, steps: result.steps.length, stuckDetected: false };
}
```

### Recovery Strategies

```typescript
// Strategy 1: Immediate termination
export class ImmediateTerminationStrategy {
  handleStuck(status: StuckStatus): never {
    throw new StuckLoopError(`Agent stuck: ${status.reason}`, status.details);
  }
}

// Strategy 2: HITL intervention
export class HITLRecoveryStrategy {
  async handleStuck(
    status: StuckStatus,
    context: AgentContext
  ): Promise<'continue' | 'abort' | 'modify'> {
    const response = await context.approvalQueue.addRequest({
      type: 'stuck_loop_detected',
      message: 'Agent appears stuck in a loop. What should I do?',
      options: [
        { id: 'continue', label: 'Continue with more steps' },
        { id: 'modify', label: 'Provide additional guidance' },
        { id: 'abort', label: 'Stop the task' },
      ],
      diagnostics: status.details,
    });

    return response.decision;
  }
}

// Strategy 3: Adaptive abandonment (Autono framework)
export class AdaptiveAbandonmentStrategy {
  private attemptCounts: Map<string, number> = new Map();
  private readonly PENALTY_FACTOR = 0.2;

  shouldAbandon(actionKey: string): boolean {
    const attempts = this.attemptCounts.get(actionKey) || 0;
    this.attemptCounts.set(actionKey, attempts + 1);

    // Calculate abandonment probability
    const abandonProb = 1 - Math.exp(-this.PENALTY_FACTOR * attempts);
    return Math.random() < abandonProb;
  }
}
```

## Testing Strategy

### Unit Testing Detection

```typescript
import { describe, it, expect } from 'vitest';
import { StuckDetector } from '../stuck-detection';
import { ProgressBasedStuckDetector } from '../progress-detector';

describe('StuckDetector', () => {
  it('detects exact action repetition', () => {
    const detector = new StuckDetector();

    detector.recordAction('scroll_down', {});
    expect(detector.checkForLoop().isStuck).toBe(false);

    detector.recordAction('scroll_down', {});
    expect(detector.checkForLoop().isStuck).toBe(false);

    detector.recordAction('scroll_down', {});
    expect(detector.checkForLoop().isStuck).toBe(true);
    expect(detector.checkForLoop().reason).toBe('exact_repetition');
  });

  it('does not detect different actions as stuck', () => {
    const detector = new StuckDetector();

    detector.recordAction('search', { query: 'A' });
    detector.recordAction('search', { query: 'B' });
    detector.recordAction('search', { query: 'C' });

    expect(detector.checkForLoop().isStuck).toBe(false);
  });

  it('resets history correctly', () => {
    const detector = new StuckDetector();

    detector.recordAction('scroll_down', {});
    detector.recordAction('scroll_down', {});
    detector.recordAction('scroll_down', {});
    expect(detector.checkForLoop().isStuck).toBe(true);

    detector.reset();
    expect(detector.checkForLoop().isStuck).toBe(false);
  });
});

describe('ProgressBasedStuckDetector', () => {
  it('detects high error rate', () => {
    const detector = new ProgressBasedStuckDetector();

    detector.recordStep({ toolCalls: [{ result: { error: 'Failed' } }] });
    detector.recordStep({ toolCalls: [{ result: { error: 'Failed' } }] });
    const status = detector.recordStep({ toolCalls: [{ result: { error: 'Failed' } }] });

    expect(status.isStuck).toBe(true);
    expect(status.reason).toBe('high_error_rate');
  });
});
```

## Common Pitfalls

### ❌ Avoid

| Pitfall | Problem | Solution |
|---------|---------|----------|
| Waiting for max steps | Too late, costs wasted | Detect after every step |
| Silent failures | User doesn't know what happened | Always notify with diagnostics |
| Losing progress | Partial work discarded | Save checkpoints before stopping |
| Ignoring patterns | Same stuck loops recur | Log and analyze to fix root causes |
| False positives | Legitimate retries flagged | Allow configurable thresholds |
| Over-detection | Agent never completes | Start with 3 repetitions, adjust |

### ✅ Best Practices

1. **Detect early** - Check after every step, not just at max steps
2. **Combine methods** - Exact repetition + progress tracking
3. **Provide diagnostics** - Show user what agent was repeating
4. **Enable HITL** - Let users intervene and provide guidance
5. **Log patterns** - Track common stuck loops to improve prompts
6. **Cost protection** - Early detection saves 85% of wasted costs

## Quick Reference

### Stuck Detection Configuration

```typescript
// Detection Configuration
const DETECTION_CONFIG = {
  exactRepetitionThreshold: 3,    // Same action 3× = stuck
  progressTimeoutMs: 30000,       // 30s without progress = stuck
  maxErrorRate: 0.5,              // 50% errors = stuck
  enableHITL: true,               // Ask user for guidance
};

// AI SDK v6 Integration
const result = await generateText({
  model: openai('gpt-4o'),
  prompt,
  tools,
  stopWhen: stepCountIs(20),
  experimental_onStepFinish: async (step) => {
    const status = await detector.checkStep(step);
    if (status.isStuck) {
      // Handle stuck loop
    }
  },
});
```

### Detection Checklist

| Check | Threshold | Action |
|-------|-----------|--------|
| Exact repetition | 3 identical calls | Stop or HITL |
| Progress timeout | 30 seconds | Stop or HITL |
| Error rate | >50% | Stop or HITL |
| Alternating loop | 2 tools oscillating 3× | Warn and guide |

## Related Topics

- [3.4.1 - Max Steps Limits](./3.4.1-max-steps.md) - Hard bounds on iterations
- [3.4.2 - Convergence Detection](./3.4.2-convergence.md) - Positive completion signals
- [3.4.5 - Early Exit Strategies](./3.4.5-early-exit.md) - Optimizing step usage

## Research & Resources

**Academic Papers**
- Autono Framework - "A ReAct-Based Highly Robust Autonomous Agent Framework" (Apr 2025) - [arxiv.org](https://arxiv.org/abs/2504.04650)
- ReflAct - "World-Grounded Decision Making via Goal-State Reflection" (May 2025) - [arxiv.org](https://arxiv.org/abs/2505.15182)

**Framework Documentation**
- AI SDK v6 - "Multi-Step Calls and Step Callbacks" (2025) - [v6.ai-sdk.dev](https://v6.ai-sdk.dev/docs/ai-sdk-core/generating-text#multi-step-calls)

**Industry Resources**
- GitHub browser-use - "Endless loop detection to avoid high LLM costs" (Jan 2025) - [github.com](https://github.com/browser-use/browser-use/issues/191)
- PlainEnglish.io - "The Rogue Agent Problem: How ReAct Fails" (Aug 2025) - [ai.plainenglish.io](https://ai.plainenglish.io/the-rogue-agent-problem-how-react-fails-how-to-fix-it)
