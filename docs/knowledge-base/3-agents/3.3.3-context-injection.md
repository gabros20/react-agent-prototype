# 3.3.3 - Context Injection

> **Layer**: Agent Architecture | **Topic**: Tool System
> **Version**: 2.0 | **Date Verified**: December 2025

---

## TL;DR

**Context injection enables tools to access runtime dependencies (databases, services, user sessions) without hardcoding.** AI SDK v6's `experimental_context` provides a clean, testable pattern for passing services, user identity, and request metadata to tool execution functions.

### Key Takeaways

- **`experimental_context`** is the native AI SDK v6 pattern for dependency injection
- **Loose coupling** makes tools reusable and testable
- **User context** enables permission-based filtering and audit trails
- **Service layer abstraction** decouples tools from implementation details
- **Context factory pattern** centralizes context creation per request

---

## Why It Matters

### The Problem

Without context injection, tools are tightly coupled:

```typescript
// ❌ BAD: Hardcoded dependencies
const cms_getPage = tool({
  execute: async ({ pageId }) => {
    // Problem 1: Global variable - untestable
    const page = await globalDb.pages.findOne({ id: pageId });

    // Problem 2: No user context - can't check permissions
    // Problem 3: Tied to specific database - not reusable
    return page;
  },
});
```

**Problems:**
- Can't mock database for testing
- No user context for permissions
- Tied to specific implementation
- Hard to add logging, caching, etc.

### Research Evidence

| Finding | Source | Year |
|---------|--------|------|
| Dependency injection improves testability by **70-90%** | AG2 docs | 2025 |
| Context isolation prevents cross-user data leaks | Security research | 2024 |
| Type-safe context with TypeScript prevents runtime errors | Industry practice | 2025 |
| MCP standardizing context sharing across frameworks | Anthropic | 2024-2025 |

---

## Core Concepts

### Context Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     AGENT EXECUTION                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Request → Context Factory → AgentContext                   │
│                                    ↓                         │
│              ┌─────────────────────────────────────┐        │
│              │         experimental_context         │        │
│              ├─────────────────────────────────────┤        │
│              │  • Services (CMS, Email, Search)    │        │
│              │  • User Identity (userId, roles)    │        │
│              │  • Session (sessionId, history)     │        │
│              │  • Metadata (requestId, traceId)    │        │
│              └─────────────────────────────────────┘        │
│                                    ↓                         │
│              ┌─────────────────────────────────────┐        │
│              │         Tool Execution               │        │
│              │  execute(input, { experimental_context })    │
│              └─────────────────────────────────────┘        │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Context Interface

```typescript
// server/types/agent-context.ts
export interface AgentContext {
  // Services
  cmsService: CMSService;
  emailService: EmailService;
  searchService: SearchService;

  // Infrastructure
  logger: Logger;
  cache: CacheService;

  // User Identity
  userId: string;
  userRoles: string[];
  tenantId?: string;  // Multi-tenancy

  // Session
  sessionId: string;
  conversationHistory: Message[];

  // Request Metadata
  requestId: string;
  traceId: string;
  timestamp: Date;
}
```

---

## Implementation Guide

### Step-by-Step

#### 1. Define Context Interface

```typescript
// server/types/agent-context.ts
export interface AgentContext {
  // Essential services
  cmsService: {
    getPage: (id: string, mode?: 'summary' | 'full') => Promise<Page | null>;
    createPage: (data: CreatePageInput) => Promise<Page>;
    updatePage: (id: string, data: UpdatePageInput) => Promise<Page>;
    deletePage: (id: string) => Promise<void>;
  };

  // User identity (always present)
  userId: string;
  userRoles: string[];

  // Session tracking
  sessionId: string;

  // Optional infrastructure
  logger?: Logger;
  cache?: CacheService;
}
```

#### 2. Create Context Factory

```typescript
// server/agent/context-factory.ts
import { Request } from 'express';
import { AgentContext } from '@/types';

export class AgentContextFactory {
  constructor(
    private db: Database,
    private cache: CacheService,
    private authService: AuthService
  ) {}

  async create(req: Request): Promise<AgentContext> {
    // 1. Authenticate user
    const user = await this.authService.verifyToken(
      req.headers.authorization
    );

    // 2. Generate request IDs
    const sessionId = req.headers['x-session-id'] as string || generateId();
    const requestId = generateId();
    const traceId = generateId();

    // 3. Initialize services with user context
    const cmsService = new CMSService(this.db, user.id, user.tenantId);
    const emailService = new EmailService(user.email);
    const searchService = new SearchService(user.tenantId);

    // 4. Build context
    return {
      // Services
      cmsService,
      emailService,
      searchService,

      // Infrastructure
      logger: createLogger({ userId: user.id, traceId }),
      cache: this.cache,

      // User
      userId: user.id,
      userRoles: user.roles,
      tenantId: user.tenantId,

      // Session
      sessionId,

      // Metadata
      requestId,
      traceId,
      timestamp: new Date(),
    };
  }
}
```

#### 3. Inject Context in Agent Call

```typescript
// server/routes/agent.ts
import { generateText, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';

export async function POST(req: Request) {
  const { prompt } = await req.json();

  // Create context for this request
  const contextFactory = new AgentContextFactory(db, cache, authService);
  const context = await contextFactory.create(req);

  // Run agent with context injection
  const result = await generateText({
    model: openai('gpt-4o'),
    prompt,
    tools: {
      cms_getPage,
      cms_createPage,
      cms_updatePage,
    },
    experimental_context: context,  // ← Context injection
    stopWhen: stepCountIs(15),
  });

  return Response.json({ text: result.text });
}
```

#### 4. Access Context in Tools

```typescript
// server/tools/cms/get-page.ts
import { tool } from 'ai';
import { z } from 'zod';
import type { AgentContext } from '@/types';

export const cms_getPage = tool({
  description: 'Retrieves CMS page by ID or slug',
  inputSchema: z.object({
    identifier: z.string(),
    fetchMode: z.enum(['summary', 'full']).default('summary'),
  }),

  execute: async ({ identifier, fetchMode }, { experimental_context }) => {
    // Type-cast context
    const ctx = experimental_context as AgentContext;

    // Access injected service
    const page = await ctx.cmsService.getPage(identifier, fetchMode);

    // Log with user context
    ctx.logger?.info('Page retrieved', {
      pageId: page?.id,
      userId: ctx.userId,
    });

    if (!page) {
      return { error: 'Page not found', identifier };
    }

    return { success: true, page };
  },
});
```

---

## Framework Integration

### AI SDK v6 Pattern

```typescript
import { generateText, tool, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';

// Context is passed via experimental_context
const result = await generateText({
  model: openai('gpt-4o'),
  prompt: userMessage,

  tools: {
    myTool: tool({
      description: 'Tool with context access',
      inputSchema: z.object({ input: z.string() }),

      execute: async ({ input }, { experimental_context }) => {
        // Type-cast for safety
        const ctx = experimental_context as AgentContext;

        // Access any injected dependency
        const result = await ctx.someService.doWork(input);

        return { success: true, result };
      },
    }),
  },

  // Inject context here
  experimental_context: {
    someService: new SomeService(),
    userId: 'user-123',
    sessionId: 'session-456',
  } satisfies AgentContext,

  stopWhen: stepCountIs(15),
});
```

### Service Layer Pattern

```typescript
// server/services/cms-service.ts
export class CMSService {
  constructor(
    private db: Database,
    private userId: string,
    private tenantId?: string
  ) {}

  async getPage(identifier: string, mode: 'summary' | 'full' = 'summary'): Promise<Page | null> {
    const page = await this.db.pages.findOne({
      where: {
        [identifier.includes('/') ? 'slug' : 'id']: identifier,
        tenantId: this.tenantId,  // Automatic tenant scoping
      },
    });

    if (!page) return null;

    return mode === 'summary' ? this.toSummary(page) : page;
  }

  async createPage(data: CreatePageInput): Promise<Page> {
    return this.db.pages.create({
      ...data,
      authorId: this.userId,      // Automatic author tracking
      tenantId: this.tenantId,    // Automatic tenant assignment
      createdAt: new Date(),
    });
  }

  private toSummary(page: Page): PageSummary {
    return {
      id: page.id,
      title: page.title,
      slug: page.slug,
      status: page.status,
    };
  }
}
```

---

## Testing Strategy

### Unit Testing with Mock Context

```typescript
// server/tools/__tests__/cms-get-page.test.ts
import { describe, it, expect, vi } from 'vitest';
import { cms_getPage } from '../cms/get-page';

describe('cms_getPage', () => {
  // Create mock context
  const createMockContext = () => ({
    cmsService: {
      getPage: vi.fn(),
      createPage: vi.fn(),
      updatePage: vi.fn(),
    },
    userId: 'test-user-123',
    userRoles: ['editor'],
    sessionId: 'test-session',
    logger: {
      info: vi.fn(),
      error: vi.fn(),
    },
  });

  it('returns page when found', async () => {
    const ctx = createMockContext();
    ctx.cmsService.getPage.mockResolvedValue({
      id: 'page-1',
      title: 'Test Page',
    });

    const result = await cms_getPage.execute(
      { identifier: 'page-1', fetchMode: 'summary' },
      { experimental_context: ctx }
    );

    expect(result.success).toBe(true);
    expect(result.page.title).toBe('Test Page');
    expect(ctx.cmsService.getPage).toHaveBeenCalledWith('page-1', 'summary');
  });

  it('returns error when not found', async () => {
    const ctx = createMockContext();
    ctx.cmsService.getPage.mockResolvedValue(null);

    const result = await cms_getPage.execute(
      { identifier: 'nonexistent', fetchMode: 'summary' },
      { experimental_context: ctx }
    );

    expect(result.error).toBe('Page not found');
  });

  it('logs with user context', async () => {
    const ctx = createMockContext();
    ctx.cmsService.getPage.mockResolvedValue({ id: 'page-1' });

    await cms_getPage.execute(
      { identifier: 'page-1', fetchMode: 'summary' },
      { experimental_context: ctx }
    );

    expect(ctx.logger.info).toHaveBeenCalledWith(
      'Page retrieved',
      expect.objectContaining({ userId: 'test-user-123' })
    );
  });
});
```

---

## Common Pitfalls

### ❌ Avoid

| Pitfall | Problem | Solution |
|---------|---------|----------|
| Global variables | Untestable, not isolated | Inject via context |
| Closures over services | Tight coupling | Use experimental_context |
| Mutable context | Race conditions | Keep context immutable |
| Secrets in context | Security risk | Use service abstractions |
| Reusing contexts | Stale data | Create fresh per request |

### ✅ Best Practices

1. **Type the context interface** - TypeScript prevents runtime errors
2. **Create context per request** - Fresh context for isolation
3. **Inject services, not implementations** - Loose coupling
4. **Include user identity** - Enable permissions and audit
5. **Add request metadata** - traceId, requestId for debugging

---

## Summary

### Quick Reference

```typescript
// 1. Define context interface
interface AgentContext {
  cmsService: CMSService;
  userId: string;
  sessionId: string;
}

// 2. Create context factory
const context: AgentContext = {
  cmsService: new CMSService(db, userId),
  userId: session.userId,
  sessionId: session.id,
};

// 3. Inject in generateText/streamText
const result = await generateText({
  model: openai('gpt-4o'),
  prompt,
  tools: { cms_getPage },
  experimental_context: context,
  stopWhen: stepCountIs(15),
});

// 4. Access in tool execute
execute: async (input, { experimental_context }) => {
  const ctx = experimental_context as AgentContext;
  return ctx.cmsService.getPage(input.id);
}
```

### Decision Tree

```
When designing context:

1. What services does the tool need?
   └─ Add to context interface

2. Does it need user identity?
   ├─ Yes → Add userId, userRoles
   └─ No → Consider if permissions matter

3. Is it multi-tenant?
   ├─ Yes → Add tenantId, scope services
   └─ No → Skip tenant scoping

4. Do you need debugging info?
   └─ Add requestId, traceId, logger
```

---

## Related Topics

- [3.3.1 - Tool Definition](./3.3.1-tool-definition.md) - Creating well-structured tools
- [3.3.2 - Tool Registry](./3.3.2-tool-registry.md) - Organizing and discovering tools
- [3.3.4 - Result Validation](./3.3.4-result-validation.md) - Verifying tool execution
- [3.3.5 - Tool Composition](./3.3.5-composition.md) - Chaining tools together

---

## Research Citations

1. **AG2 Documentation** - "Chat Context Dependency Injection" (Apr 2025)
   https://docs.ag2.ai/0.8.5/docs/use-cases/notebooks/notebooks/tools_chat_context

2. **AI SDK v6** - "Tools and Tool Calling" (2025)
   https://v6.ai-sdk.dev/docs/ai-sdk-core/tools-and-tool-calling

3. **Anthropic** - "Model Context Protocol (MCP)" (2024-2025)
   https://modelcontextprotocol.io/

4. **MintMCP** - "Vercel AI SDK with MCP: Connect Multiple AI Models" (Oct 2025)
   https://www.mintmcp.com/blog/connect-multiple-ai-models

5. **GitHub Issue** - "Allow experimental_context in client-side tools" (Oct 2025)
   https://github.com/vercel/ai/issues/9214
