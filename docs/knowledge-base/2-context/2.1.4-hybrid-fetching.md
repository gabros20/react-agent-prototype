# 2.1.4 Token Optimization: Hybrid Content Fetching

## Overview

Hybrid content fetching combines lightweight metadata retrieval with selective detail loading, enabling agents to efficiently navigate large content repositories without loading everything upfront. Your codebase already implements this pattern excellently with `cms_getPage(fetchMode: 'lightweight' | 'full')`—this document explores the strategy, benefits, and enhancements to maximize its effectiveness.

**Key Insight** (2024-2025): The most efficient fetch strategy depends on the query—lightweight browsing for exploration, full content only when needed for detailed work.

**Current Date**: November 17, 2025

## Why Hybrid Fetching Matters

### The Content Fetching Dilemma

**Option 1: Always Fetch Full Content**:
```typescript
// Load everything eagerly
const page = await prisma.page.findUnique({
  where: { slug },
  include: {
    content: true,        // 5,000+ tokens
    sections: {
      include: { content: true }  // Another 3,000+ tokens
    },
    metadata: true,
    revisions: true       // Historical data (rarely needed)
  }
});

// Cost per page: ~8,000 tokens
// 10 page lookups: 80,000 tokens ($1.20 with GPT-4o)
```

**Problems**:
- ❌ Massive token waste when browsing
- ❌ Slow responses (DB + token processing)
- ❌ High costs for simple queries
- ❌ Context window overflow risk

**Option 2: Always Fetch Minimal**:
```typescript
// Load only metadata
const page = await prisma.page.findUnique({
  where: { slug },
  select: { id: true, title: true, slug: true }
});

// Cost per page: ~10 tokens
// 10 page lookups: 100 tokens ($0.0015 with GPT-4o)
```

**Problems**:
- ❌ Can't answer detailed questions
- ❌ Requires follow-up fetches
- ❌ Multiple round trips = latency
- ❌ Poor UX for content-heavy queries

**Solution: Hybrid Approach**:
```typescript
// Start lightweight, upgrade when needed
const summary = await getPage(slug, 'lightweight'); // 50 tokens
// Agent decides: "I need full content to answer this"
const full = await getPage(slug, 'full'); // 1,000 tokens only when needed

// Average: 50 tokens (browsing) or 1,050 tokens (detailed)
// 10 page lookups (8 lightweight + 2 full): 2,400 tokens vs 80,000
// Savings: 97% token reduction!
```

### Your Codebase Implementation ✅

**Already Implemented** (`server/tools/all-tools.ts`):
```typescript
{
  name: 'cms_getPage',
  description: 'Retrieve page information with configurable detail level',
  parameters: {
    slug: { type: 'string', required: true },
    fetchMode: {
      type: 'string',
      enum: ['lightweight', 'full'],
      default: 'lightweight',
      description: 'lightweight: metadata + summary only (fast, ~50 tokens). full: complete content (slower, ~1000 tokens)'
    }
  }
}
```

**Token Characteristics**:
- **Lightweight**: ~50 tokens (title, slug, summary, metadata)
- **Full**: ~1,000 tokens (complete content, sections, rich metadata)
- **Savings**: 95% when full content not needed

**Usage Pattern**:
```xml
User: What pages do we have about React?

Agent:
Thought: I'll search for React pages using lightweight mode first
Action: cms_listPages
Action Input: { "query": "React" }
Observation: Found 10 pages. Titles: "React Basics", "React Hooks Guide", ...

Thought: User just wants to know what pages exist, lightweight is sufficient
Response: We have 10 pages about React: React Basics, React Hooks Guide, ...

---

User: Show me the complete content of the React Hooks Guide

Agent:
Thought: User wants full content, I need to upgrade to full mode
Action: cms_getPage
Action Input: { "slug": "react-hooks-guide", "fetchMode": "full" }
Observation: [Full 1,000 token content]
Response: Here's the complete React Hooks Guide: [content]
```

## Enhanced Hybrid Fetching Strategies

### Strategy 1: Three-Tier Fetching

**Add intermediate "summary" level between lightweight and full**:

**Implementation**:
```typescript
// Level 1: Metadata only (10-20 tokens)
interface PageMetadata {
  id: string;
  title: string;
  slug: string;
  updatedAt: string;
}

// Level 2: Summary (50-100 tokens)
interface PageSummary extends PageMetadata {
  summary: string;
  tags: string[];
  author: string;
  sectionCount: number;
}

// Level 3: Full content (1,000+ tokens)
interface PageFull extends PageSummary {
  content: string;
  sections: Section[];
  metadata: Record<string, any>;
  relatedPages: string[];
}

// Tool implementation
export const cms_getPage = {
  name: 'cms_getPage',
  description: 'Get page with configurable detail level',
  parameters: {
    slug: { type: 'string', required: true },
    fetchMode: {
      type: 'string',
      enum: ['metadata', 'summary', 'full'],
      default: 'summary',
      description: `
        - metadata: Just title and ID (fastest, ~10 tokens)
        - summary: Add description, tags, author (~50 tokens)
        - full: Complete content with sections (~1,000+ tokens)
      `
    }
  },
  handler: async (slug: string, fetchMode: 'metadata' | 'summary' | 'full' = 'summary') => {
    switch (fetchMode) {
      case 'metadata':
        return prisma.page.findUnique({
          where: { slug },
          select: {
            id: true,
            title: true,
            slug: true,
            updatedAt: true
          }
        });
      
      case 'summary':
        return prisma.page.findUnique({
          where: { slug },
          select: {
            id: true,
            title: true,
            slug: true,
            updatedAt: true,
            summary: true,
            tags: true,
            author: true,
            _count: { select: { sections: true } }
          }
        });
      
      case 'full':
        return prisma.page.findUnique({
          where: { slug },
          include: {
            sections: true,
            content: true,
            metadata: true,
            relatedPages: true
          }
        });
    }
  }
};
```

**Benefits**:
- **Metadata**: Fast scanning (10 tokens)
- **Summary**: Quick overview (50 tokens) - good default
- **Full**: Complete content (1,000 tokens) - only when necessary

**Usage**:
```
User: What pages were updated this week?

Agent:
Action: cms_listPages
Input: { "updatedAfter": "2025-11-10", "fetchMode": "metadata" }
Observation: 15 pages updated. [titles and dates only, 150 tokens total]

---

User: What's the React Hooks page about?

Agent:
Action: cms_getPage
Input: { "slug": "react-hooks", "fetchMode": "summary" }
Observation: React Hooks are functions that let you use state... [summary, 50 tokens]

---

User: Show me the complete hooks tutorial

Agent:
Action: cms_getPage
Input: { "slug": "react-hooks", "fetchMode": "full" }
Observation: [Complete content, 1,000 tokens]
```

### Strategy 2: Progressive Disclosure

**Load incrementally: outline → sections → full**:

**Implementation**:
```typescript
interface PageOutline {
  title: string;
  sections: Array<{
    id: string;
    title: string;
    wordCount: number;
  }>;
}

interface PageSection {
  id: string;
  title: string;
  content: string;
  subsections?: string[];
}

// Tools
const tools = {
  cms_getPageOutline: async (slug: string): Promise<PageOutline> => {
    // ~100 tokens: page title + section titles
    const page = await prisma.page.findUnique({
      where: { slug },
      select: {
        title: true,
        sections: {
          select: {
            id: true,
            title: true,
            content: true // Just to count words
          }
        }
      }
    });
    
    return {
      title: page.title,
      sections: page.sections.map(s => ({
        id: s.id,
        title: s.title,
        wordCount: estimateWords(s.content)
      }))
    };
  },
  
  cms_getPageSection: async (sectionId: string): Promise<PageSection> => {
    // ~200-500 tokens per section
    return prisma.section.findUnique({
      where: { id: sectionId },
      include: { subsections: { select: { title: true } } }
    });
  },
  
  cms_getFullPage: async (slug: string): Promise<PageFull> => {
    // ~1,000+ tokens
    return prisma.page.findUnique({
      where: { slug },
      include: { sections: true, content: true }
    });
  }
};
```

**Usage Pattern**:
```
User: Explain the useState section from React Hooks

Agent:
Step 1: Get outline (100 tokens)
Action: cms_getPageOutline
Input: { "slug": "react-hooks" }
Observation: Page has 5 sections: Introduction, useState, useEffect, Custom Hooks, Best Practices

Step 2: Get specific section (300 tokens)
Action: cms_getPageSection  
Input: { "sectionId": "section-usestate" }
Observation: [useState section content only]
Response: Here's the useState section: [content]

Total: 400 tokens vs 1,000 tokens (60% savings)
```

### Strategy 3: Query-Adaptive Fetching

**Automatically select fetch mode based on query intent**:

**Implementation**:
```typescript
class QueryAdaptiveFetcher {
  async fetchPage(slug: string, query: string): Promise<any> {
    const intent = this.analyzeIntent(query);
    
    switch (intent.type) {
      case 'browse':
        // User just wants to see what's available
        return this.fetch(slug, 'metadata');
      
      case 'overview':
        // User wants to know what page is about
        return this.fetch(slug, 'summary');
      
      case 'detailed':
        // User wants specific information from content
        return this.fetch(slug, 'full');
      
      case 'targeted':
        // User wants specific section
        const outline = await this.fetchOutline(slug);
        const relevantSection = this.findRelevantSection(outline, query);
        return this.fetchSection(relevantSection.id);
    }
  }
  
  private analyzeIntent(query: string): { type: string; confidence: number } {
    // Simple heuristics (could use ML classifier)
    const browseKeywords = ['list', 'show all', 'what pages', 'which'];
    const overviewKeywords = ['about', 'summary', 'what is', 'overview'];
    const detailedKeywords = ['full', 'complete', 'entire', 'all details'];
    const targetedKeywords = ['section', 'chapter', 'part about'];
    
    if (browseKeywords.some(kw => query.toLowerCase().includes(kw))) {
      return { type: 'browse', confidence: 0.8 };
    }
    if (overviewKeywords.some(kw => query.toLowerCase().includes(kw))) {
      return { type: 'overview', confidence: 0.8 };
    }
    if (detailedKeywords.some(kw => query.toLowerCase().includes(kw))) {
      return { type: 'detailed', confidence: 0.9 };
    }
    if (targetedKeywords.some(kw => query.toLowerCase().includes(kw))) {
      return { type: 'targeted', confidence: 0.85 };
    }
    
    // Default to summary for ambiguous queries
    return { type: 'overview', confidence: 0.5 };
  }
  
  private findRelevantSection(outline: PageOutline, query: string): Section {
    // Use semantic similarity to find most relevant section
    const queryEmb = await embed(query);
    const sectionEmbs = await Promise.all(
      outline.sections.map(s => embed(s.title))
    );
    
    const scores = sectionEmbs.map(emb => cosineSimilarity(queryEmb, emb));
    const maxIdx = scores.indexOf(Math.max(...scores));
    
    return outline.sections[maxIdx];
  }
}

// Usage
const fetcher = new QueryAdaptiveFetcher();

// Automatically selects appropriate mode
const result1 = await fetcher.fetchPage('react-hooks', 'What pages do we have?'); // → metadata
const result2 = await fetcher.fetchPage('react-hooks', 'What is this page about?'); // → summary
const result3 = await fetcher.fetchPage('react-hooks', 'Show me the complete tutorial'); // → full
const result4 = await fetcher.fetchPage('react-hooks', 'Explain the useState section'); // → section
```

### Strategy 4: Predictive Prefetching

**Predict likely next fetch and prefetch in background**:

**Implementation**:
```typescript
class PredictiveFetcher {
  private cache = new Map<string, any>();
  private prefetchQueue: Array<{ slug: string; mode: string }> = [];
  
  async fetch(slug: string, mode: string): Promise<any> {
    const cacheKey = `${slug}:${mode}`;
    
    // Check cache first
    if (this.cache.has(cacheKey)) {
      metrics.increment('fetch.cache.hit');
      return this.cache.get(cacheKey);
    }
    
    metrics.increment('fetch.cache.miss');
    
    // Fetch requested content
    const content = await this.fetchFromDB(slug, mode);
    this.cache.set(cacheKey, content);
    
    // Predict and prefetch likely next requests
    await this.prefetchLikely(slug, mode, content);
    
    return content;
  }
  
  private async prefetchLikely(
    slug: string,
    currentMode: string,
    content: any
  ): Promise<void> {
    // Heuristic: If fetched summary, user likely wants full next
    if (currentMode === 'summary') {
      this.prefetchQueue.push({ slug, mode: 'full' });
    }
    
    // If fetched page, prefetch related pages (lightweight)
    if (content.relatedPages) {
      for (const relatedSlug of content.relatedPages.slice(0, 3)) {
        this.prefetchQueue.push({ slug: relatedSlug, mode: 'summary' });
      }
    }
    
    // Process prefetch queue in background
    this.processPrefetchQueue();
  }
  
  private processPrefetchQueue(): void {
    // Process queue asynchronously (don't block main request)
    setTimeout(async () => {
      while (this.prefetchQueue.length > 0) {
        const { slug, mode } = this.prefetchQueue.shift()!;
        const cacheKey = `${slug}:${mode}`;
        
        if (!this.cache.has(cacheKey)) {
          try {
            const content = await this.fetchFromDB(slug, mode);
            this.cache.set(cacheKey, content, 60); // 1 min TTL
            metrics.increment('fetch.prefetch.success');
          } catch (error) {
            metrics.increment('fetch.prefetch.error');
          }
        }
      }
    }, 0);
  }
}
```

**Benefits**:
- Summary fetch triggers background full fetch
- Related pages prefetched in background
- Subsequent requests served from cache (instant)

### Strategy 5: Batch Hybrid Fetching

**Fetch multiple items with mixed detail levels efficiently**:

**Implementation**:
```typescript
interface FetchRequest {
  slug: string;
  mode: 'metadata' | 'summary' | 'full';
}

async function batchFetch(requests: FetchRequest[]): Promise<any[]> {
  // Group by mode for efficient DB queries
  const byMode = requests.reduce((acc, req) => {
    if (!acc[req.mode]) acc[req.mode] = [];
    acc[req.mode].push(req.slug);
    return acc;
  }, {} as Record<string, string[]>);
  
  // Fetch each mode in parallel
  const results = await Promise.all([
    byMode.metadata ? prisma.page.findMany({
      where: { slug: { in: byMode.metadata } },
      select: { id: true, title: true, slug: true }
    }) : [],
    
    byMode.summary ? prisma.page.findMany({
      where: { slug: { in: byMode.summary } },
      select: { id: true, title: true, slug: true, summary: true, tags: true }
    }) : [],
    
    byMode.full ? prisma.page.findMany({
      where: { slug: { in: byMode.full } },
      include: { content: true, sections: true }
    }) : []
  ]);
  
  // Reconstruct in original order
  const resultMap = new Map();
  results.flat().forEach(r => resultMap.set(r.slug, r));
  
  return requests.map(req => resultMap.get(req.slug));
}

// Usage
const pages = await batchFetch([
  { slug: 'page-1', mode: 'metadata' },   // 10 tokens
  { slug: 'page-2', mode: 'metadata' },   // 10 tokens
  { slug: 'page-3', mode: 'summary' },    // 50 tokens
  { slug: 'page-4', mode: 'full' }        // 1,000 tokens
]);

// Total: 1,070 tokens vs 4,000 tokens (73% savings)
```

## Production Best Practices

### 1. Instrument Fetch Modes

```typescript
class FetchAnalytics {
  trackFetch(slug: string, mode: string, tokens: number, duration: number) {
    metrics.histogram('fetch.duration', duration, { mode });
    metrics.histogram('fetch.tokens', tokens, { mode });
    metrics.increment('fetch.count', { mode });
  }
  
  trackUpgrade(from: string, to: string) {
    // Track when agent upgrades from lightweight to full
    metrics.increment('fetch.upgrade', { from, to });
  }
  
  async reportStats() {
    const stats = {
      metadataCount: await metrics.get('fetch.count', { mode: 'metadata' }),
      summaryCount: await metrics.get('fetch.count', { mode: 'summary' }),
      fullCount: await metrics.get('fetch.count', { mode: 'full' }),
      avgTokensByMode: {
        metadata: await metrics.avg('fetch.tokens', { mode: 'metadata' }),
        summary: await metrics.avg('fetch.tokens', { mode: 'summary' }),
        full: await metrics.avg('fetch.tokens', { mode: 'full' })
      }
    };
    
    console.log('Fetch Mode Distribution:', stats);
    // Example output:
    // metadata: 45%, summary: 40%, full: 15%
    // Avg tokens: metadata 12, summary 48, full 980
  }
}
```

### 2. Cache Frequently Accessed Content

```typescript
const cache = new Map<string, { content: any; mode: string; timestamp: number }>();
const TTL = 5 * 60 * 1000; // 5 minutes

async function fetchWithCache(slug: string, mode: string): Promise<any> {
  const cacheKey = `${slug}:${mode}`;
  const cached = cache.get(cacheKey);
  
  if (cached && Date.now() - cached.timestamp < TTL) {
    metrics.increment('fetch.cache.hit', { mode });
    return cached.content;
  }
  
  metrics.increment('fetch.cache.miss', { mode });
  const content = await fetchFromDB(slug, mode);
  
  cache.set(cacheKey, { content, mode, timestamp: Date.now() });
  return content;
}
```

### 3. Agent Prompt Guidance

```xml
<tool>
  <name>cms_getPage</name>
  <description>Retrieve page information with configurable detail level</description>
  <parameters>
    <slug>Page identifier (e.g., "react-hooks")</slug>
    <fetchMode>
      - 'metadata': Just title and ID (fastest, ~10 tokens) - USE FOR: browsing, listing
      - 'summary': Add description and tags (~50 tokens) - USE FOR: quick overview, search results
      - 'full': Complete content (~1,000+ tokens) - USE FOR: answering detailed questions, content analysis
    </fetchMode>
  </parameters>
  <strategy>
    **IMPORTANT**: Start with 'summary' mode (default). Only upgrade to 'full' if:
    - User explicitly asks for complete/full content
    - You need to answer a detailed question requiring full text
    - User asks to edit/modify content (need to see all of it)
    
    NEVER use 'full' mode just for browsing or listing pages.
  </strategy>
</tool>
```

### 4. Monitor Token Efficiency

```typescript
class HybridFetchingMetrics {
  private totalTokens = 0;
  private potentialTokens = 0; // If everything was full mode
  
  trackFetch(mode: string, actualTokens: number) {
    this.totalTokens += actualTokens;
    
    // Calculate what it would have cost in full mode
    const fullModeTokens = mode === 'full' ? actualTokens : actualTokens * 20; // 20x multiplier
    this.potentialTokens += fullModeTokens;
  }
  
  getEfficiency(): { savings: number; percentage: number } {
    const savings = this.potentialTokens - this.totalTokens;
    const percentage = (savings / this.potentialTokens) * 100;
    
    return { savings, percentage };
  }
}

// Track over time
setInterval(() => {
  const efficiency = metrics.getEfficiency();
  console.log(`Hybrid fetching saved ${efficiency.savings} tokens (${efficiency.percentage}%)`);
}, 60000);
```

## Key Takeaways

**What is Hybrid Content Fetching**:
- Combine lightweight and detailed fetching
- Start minimal, upgrade when needed
- Match fetch detail to query requirements

**Your Codebase** ✅:
- Already implements excellent two-tier pattern
- `fetchMode: 'lightweight' | 'full'`
- 95% token savings when lightweight sufficient

**Enhancements**:
1. **Three-tier**: Add 'metadata' level (10 tokens)
2. **Progressive**: Outline → sections → full
3. **Query-adaptive**: Auto-select mode from query
4. **Predictive**: Prefetch likely next requests
5. **Batch**: Mixed-mode bulk fetching

**Production Practices**:
- Instrument fetch modes (track distribution)
- Cache frequently accessed content
- Guide agent with clear tool descriptions
- Monitor token efficiency gains

**Real Impact**:
```
Without hybrid: 10 pages × 1,000 tokens = 10,000 tokens
With hybrid: 8 lightweight (400 tokens) + 2 full (2,000 tokens) = 2,400 tokens
Savings: 76% token reduction, 76% cost savings
```

## Navigation

- [← Previous: 2.1.3 Lazy Loading](./2.1.3-lazy-loading.md)
- [↑ Back to Knowledge Base TOC](../../AI_KNOWLEDGE_BASE_TOC.md)
- [→ Next: 2.2.1 Sliding Window Context Management](./2.2.1-sliding-window.md)

---

*Part of Layer 2: Context Engineering - Smart content fetching strategies*
