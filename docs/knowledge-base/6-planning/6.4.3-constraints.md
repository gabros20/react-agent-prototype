# 6.4.3 Constraint Satisfaction

## TL;DR

Constraint satisfaction checks verify that actions won't violate business rules, invariants, or domain constraints before execution—catching problems like duplicate slugs, invalid state transitions, and relationship violations before they cause runtime failures.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-12
- **Prerequisites**: [6.4.1 Check Before Execute](./6.4.1-check-before-execute.md), [6.4.2 Resource Existence](./6.4.2-resource-existence.md)
- **Grounded In**: Design by Contract, Invariant Checking, Domain-Driven Design

## Overview

While existence checks verify resources exist, constraint checks verify that the proposed action is valid within the domain. This includes uniqueness constraints, state machine rules, relationship cardinality, and business logic invariants.

**Key Insight**: Constraint violations often have complex error messages that confuse LLMs. Preflight constraint checking provides clear, actionable feedback.

**Date Verified**: 2025-12-12

## Common Constraint Types

```
┌─────────────────────────────────────────────────────────────┐
│                  CONSTRAINT CATEGORIES                       │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. UNIQUENESS CONSTRAINTS                                   │
│     ─────────────────────                                    │
│     • Slug/URL uniqueness                                   │
│     • Email uniqueness                                      │
│     • Order numbers                                         │
│     Example: "Page with slug 'about' already exists"        │
│                                                              │
│  2. STATE TRANSITIONS                                        │
│     ──────────────────                                       │
│     • Draft → Published → Archived                          │
│     • Order: Pending → Paid → Shipped → Delivered          │
│     Example: "Cannot archive draft post (must publish first)"│
│                                                              │
│  3. RELATIONSHIP RULES                                       │
│     ──────────────────                                       │
│     • Max children per parent                               │
│     • Required parent exists                                │
│     • Circular reference prevention                         │
│     Example: "Page cannot be its own parent"                │
│                                                              │
│  4. BUSINESS INVARIANTS                                      │
│     ───────────────────                                      │
│     • Price must be positive                                │
│     • Dates must be in valid range                         │
│     • Required fields for status                            │
│     Example: "Published posts require featured image"       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

## Implementation

### Constraint Checker Framework

```typescript
interface ConstraintCheck {
  name: string;
  check: (params: Record<string, unknown>, context: Context) => Promise<{
    satisfied: boolean;
    message: string;
    fix?: string;
  }>;
}

class ConstraintChecker {
  private constraints = new Map<string, ConstraintCheck[]>();

  register(toolName: string, constraint: ConstraintCheck): void {
    const existing = this.constraints.get(toolName) ?? [];
    this.constraints.set(toolName, [...existing, constraint]);
  }

  async checkAll(
    toolName: string,
    params: Record<string, unknown>,
    context: Context
  ): Promise<{
    satisfied: boolean;
    violations: Array<{ constraint: string; message: string; fix?: string }>;
  }> {
    const toolConstraints = this.constraints.get(toolName) ?? [];
    const violations: Array<{ constraint: string; message: string; fix?: string }> = [];

    for (const constraint of toolConstraints) {
      const result = await constraint.check(params, context);
      if (!result.satisfied) {
        violations.push({
          constraint: constraint.name,
          message: result.message,
          fix: result.fix,
        });
      }
    }

    return {
      satisfied: violations.length === 0,
      violations,
    };
  }
}
```

### Common Constraint Implementations

```typescript
// Uniqueness constraint
const slugUniqueness: ConstraintCheck = {
  name: 'slug_uniqueness',
  check: async (params, ctx) => {
    if (!params.slug) return { satisfied: true, message: 'No slug provided' };

    const existing = await ctx.db.pages.findBySlug(params.slug as string);

    // Allow if updating same resource
    if (existing && existing.id === params.id) {
      return { satisfied: true, message: 'Slug unchanged' };
    }

    if (existing) {
      const suggestedSlug = await generateUniqueSlug(params.slug as string, ctx.db);
      return {
        satisfied: false,
        message: `Slug "${params.slug}" already exists`,
        fix: `Use "${suggestedSlug}" instead`,
      };
    }

    return { satisfied: true, message: 'Slug is unique' };
  },
};

// State transition constraint
const validStateTransition: ConstraintCheck = {
  name: 'valid_state_transition',
  check: async (params, ctx) => {
    if (!params.status || !params.id) {
      return { satisfied: true, message: 'No state change' };
    }

    const current = await ctx.db.posts.findById(params.id as string);
    if (!current) return { satisfied: true, message: 'Resource not found' };

    const transitions: Record<string, string[]> = {
      draft: ['published', 'deleted'],
      published: ['draft', 'archived'],
      archived: ['published', 'deleted'],
    };

    const allowed = transitions[current.status] ?? [];
    const newStatus = params.status as string;

    if (!allowed.includes(newStatus)) {
      return {
        satisfied: false,
        message: `Cannot transition from "${current.status}" to "${newStatus}"`,
        fix: `Valid transitions: ${allowed.join(', ')}`,
      };
    }

    return { satisfied: true, message: 'Valid state transition' };
  },
};

// Relationship constraint
const noCircularReference: ConstraintCheck = {
  name: 'no_circular_reference',
  check: async (params, ctx) => {
    if (!params.parentId || !params.id) {
      return { satisfied: true, message: 'No parent relationship' };
    }

    // Walk up the parent chain
    let currentId = params.parentId as string;
    const visited = new Set<string>();

    while (currentId) {
      if (currentId === params.id) {
        return {
          satisfied: false,
          message: 'Circular reference detected',
          fix: 'Choose a different parent that is not a descendant',
        };
      }

      if (visited.has(currentId)) break; // Already checked
      visited.add(currentId);

      const parent = await ctx.db.pages.findById(currentId);
      currentId = parent?.parentId;
    }

    return { satisfied: true, message: 'No circular reference' };
  },
};

// Business invariant
const publishRequirements: ConstraintCheck = {
  name: 'publish_requirements',
  check: async (params, ctx) => {
    if (params.status !== 'published') {
      return { satisfied: true, message: 'Not publishing' };
    }

    const post = params.id
      ? await ctx.db.posts.findById(params.id as string)
      : params;

    const missing: string[] = [];

    if (!post.title) missing.push('title');
    if (!post.content) missing.push('content');
    if (!post.featuredImage) missing.push('featured image');

    if (missing.length > 0) {
      return {
        satisfied: false,
        message: `Cannot publish: missing ${missing.join(', ')}`,
        fix: `Add ${missing.join(', ')} before publishing`,
      };
    }

    return { satisfied: true, message: 'All publish requirements met' };
  },
};
```

### Registration Example

```typescript
const constraintChecker = new ConstraintChecker();

// Register constraints for each tool
constraintChecker.register('createPage', slugUniqueness);
constraintChecker.register('updatePage', slugUniqueness);
constraintChecker.register('updatePage', noCircularReference);

constraintChecker.register('updatePost', validStateTransition);
constraintChecker.register('updatePost', publishRequirements);
constraintChecker.register('publishPost', publishRequirements);
```

## Integration with Preflight

```typescript
class PreflightChecker {
  constructor(
    private constraintChecker: ConstraintChecker,
    // ... other dependencies
  ) {}

  async check(
    toolName: string,
    params: Record<string, unknown>,
    context: Context
  ): Promise<PreflightResult> {
    const checks: PreflightResult['checks'] = [];

    // Check constraints
    const constraints = await this.constraintChecker.checkAll(
      toolName,
      params,
      context
    );

    if (!constraints.satisfied) {
      for (const violation of constraints.violations) {
        checks.push({
          name: `constraint:${violation.constraint}`,
          passed: false,
          message: violation.message,
          suggestions: violation.fix ? [violation.fix] : [],
        });
      }
    } else {
      checks.push({
        name: 'constraints',
        passed: true,
        message: 'All constraints satisfied',
      });
    }

    // ... other checks

    return {
      canExecute: checks.every(c => c.passed),
      checks,
      blockers: checks.filter(c => !c.passed).map(c => c.message),
    };
  }
}
```

## Key Takeaways

1. **Categorize constraints**: Uniqueness, state, relationships, business rules
2. **Provide fixes**: Don't just say what's wrong—suggest how to fix it
3. **Check early**: Constraint violations are cheaper to catch in preflight
4. **Register per-tool**: Different tools have different constraint sets
5. **Order matters**: Check cheap constraints first (uniqueness before complex invariants)

## References

1. **Meyer, B.** (1992). "Design by Contract". IEEE Computer.
2. **Evans, E.** (2003). "Domain-Driven Design". Addison-Wesley.

**Related Topics**: [6.4.2 Resource Existence](./6.4.2-resource-existence.md), [6.4.4 Schema Compatibility](./6.4.4-schema.md)

**Layer Index**: [Layer 6: Planning & Orchestration](../AI_KNOWLEDGE_BASE_TOC.md#layer-6-planning--orchestration)
