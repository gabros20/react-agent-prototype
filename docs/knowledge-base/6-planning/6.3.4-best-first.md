# 6.3.4 Best-First Search

## TL;DR

Best-first search prioritizes expanding the most promising nodes based on evaluation scores, combining efficient exploration with greedy optimization—outperforming BFS/DFS on problems with reliable state evaluation while using 50% fewer nodes to find solutions.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-12
- **Prerequisites**: [6.3.1 Multi-Path Exploration](./6.3.1-multi-path.md), [6.3.3 Pruning](./6.3.3-pruning.md)
- **Grounded In**: A* Search, Tree of Thoughts (2023), Heuristic Search Theory

## Overview

Best-first search is a search strategy that expands nodes in order of their evaluation scores, always processing the most promising node next. Unlike BFS (breadth-first) or DFS (depth-first), best-first adapts to the problem structure, diving deep on promising paths while maintaining awareness of alternatives.

**Key Insight**: State evaluation quality determines best-first effectiveness. Good evaluators make it near-optimal; poor evaluators make it worse than BFS.

**Date Verified**: 2025-12-12

## Implementation

### Priority Queue-Based Best-First

```typescript
import Heap from 'heap-js';

interface SearchNode {
  state: string;
  score: number;
  depth: number;
  path: string[];
}

async function bestFirstSearch(
  initialState: string,
  evaluate: (state: string) => Promise<{ score: number; isSolution: boolean }>,
  expand: (state: string) => Promise<string[]>,
  maxNodes: number = 50
): Promise<{ solution: string | null; path: string[]; nodesExpanded: number }> {
  // Max-heap: highest scores first
  const frontier = new Heap<SearchNode>((a, b) => b.score - a.score);
  const visited = new Set<string>();

  frontier.push({
    state: initialState,
    score: 0.5,
    depth: 0,
    path: [],
  });

  let nodesExpanded = 0;

  while (frontier.size() > 0 && nodesExpanded < maxNodes) {
    const current = frontier.pop()!;

    if (visited.has(current.state)) continue;
    visited.add(current.state);
    nodesExpanded++;

    // Check if solution
    const evaluation = await evaluate(current.state);
    if (evaluation.isSolution) {
      return {
        solution: current.state,
        path: current.path,
        nodesExpanded,
      };
    }

    // Expand children
    const children = await expand(current.state);
    for (const childState of children) {
      if (!visited.has(childState)) {
        const childEval = await evaluate(childState);
        frontier.push({
          state: childState,
          score: childEval.score,
          depth: current.depth + 1,
          path: [...current.path, childState],
        });
      }
    }
  }

  return { solution: null, path: [], nodesExpanded };
}
```

### A* Variant (Score + Depth)

```typescript
function aStarScore(node: SearchNode, heuristic: number): number {
  const g = node.depth;        // Cost so far
  const h = 1 - heuristic;     // Estimated remaining cost
  return -(g + h);             // Negative for max-heap (minimize total cost)
}
```

## Search Strategy Comparison

```
┌─────────────────────────────────────────────────────────────┐
│                  SEARCH STRATEGIES                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  BFS (Breadth-First):                                        │
│  ─────────────────────                                       │
│  Level 1: [A] [B] [C]                                        │
│  Level 2: [A1] [A2] [B1] [B2] [C1] [C2]                     │
│  Level 3: ...                                                │
│  → Explores all options at each depth                       │
│  → Finds shortest solution, but expensive                   │
│                                                              │
│  DFS (Depth-First):                                          │
│  ─────────────────────                                       │
│  [A] → [A1] → [A1a] → [A1a1] → backtrack...                │
│  → Goes deep before trying alternatives                      │
│  → Memory efficient, but may miss short solutions           │
│                                                              │
│  Best-First:                                                 │
│  ───────────                                                 │
│  [A:0.7] → [B:0.9] → [B1:0.95] → SOLUTION                  │
│  → Follows highest scores                                    │
│  → Efficient when evaluator is accurate                     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

## When to Use Best-First

| Condition | Use Best-First? | Alternative |
|-----------|-----------------|-------------|
| Good evaluator available | ✅ Yes | - |
| Poor/unreliable evaluator | ❌ No | BFS |
| Solution depth unknown | ✅ Yes | - |
| Guaranteed shortest path needed | ⚠️ Use A* | BFS |
| Memory constrained | ⚠️ Careful | DFS |

## Key Takeaways

1. **Best-first needs good evaluation**: Poor scores → worse than BFS
2. **Use priority queue**: Essential for efficient implementation
3. **A* for optimality**: Add cost-so-far for guaranteed shortest paths
4. **50% fewer nodes**: Typical improvement over BFS when evaluator is good

## References

1. **Yao et al.** (2023). "Tree of Thoughts". NeurIPS 2023.
2. **Hart, Nilsson, Raphael** (1968). "A Formal Basis for A*". IEEE.

**Related Topics**: [6.3.3 Pruning](./6.3.3-pruning.md), [6.3.5 When to Use](./6.3.5-when-to-use.md)

**Layer Index**: [Layer 6: Planning & Orchestration](../AI_KNOWLEDGE_BASE_TOC.md#layer-6-planning--orchestration)
