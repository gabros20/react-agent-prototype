# 6.1.5 Implementation Patterns

## TL;DR

This document provides production-ready implementation patterns for Plan-and-Execute agents, combining the concepts from the previous sections into complete, deployable architectures using AI SDK v6 and common frameworks.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-12
- **Versions**: AI SDK 6.0+
- **Prerequisites**: [6.1.1 Separation](./6.1.1-separation.md), [6.1.2 Alternatives](./6.1.2-alternatives.md), [6.1.3 Feasibility](./6.1.3-feasibility.md), [6.1.4 Fallbacks](./6.1.4-fallbacks.md)
- **Grounded In**: LangGraph (2024), AI SDK v6 Agent Abstraction, Production Agent Patterns

## Table of Contents

- [Overview](#overview)
- [Architecture Patterns](#architecture-patterns)
- [Implementation Patterns](#implementation-patterns)
- [Framework Integration](#framework-integration)
- [Production Best Practices](#production-best-practices)
- [Observability & Debugging](#observability--debugging)
- [Key Takeaways](#key-takeaways)
- [References](#references)

## Overview

This document synthesizes the Plan-and-Execute concepts into practical implementation patterns. We cover three main architectures:

1. **Simple Planner-Executor**: Basic two-phase pattern for straightforward workflows
2. **Full Plan-Execute-Replan**: Dynamic replanning with fallback support
3. **Parallel Plan Execution**: Concurrent execution with dependency tracking

Each pattern includes complete TypeScript implementations using AI SDK v6's `ToolLoopAgent` abstraction.

**Implementation Principles**:

- **Separate Concerns**: Planning, execution, and replanning are distinct components
- **Type Safety**: Full Zod schema validation at every boundary
- **Streaming Support**: Real-time progress updates to users
- **Cost Awareness**: Token and latency tracking built in
- **Testability**: Each component can be tested in isolation

## Architecture Patterns

### Pattern Overview

```
┌─────────────────────────────────────────────────────────────┐
│               PLAN-AND-EXECUTE ARCHITECTURES                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  SIMPLE (2-Phase)           FULL (3-Phase + Fallbacks)      │
│  ─────────────────          ────────────────────────────     │
│                                                              │
│  ┌─────────┐                ┌─────────┐                     │
│  │ Planner │                │ Planner │                     │
│  └────┬────┘                └────┬────┘                     │
│       ↓                          ↓                          │
│  ┌─────────┐                ┌─────────┐    ┌──────────┐    │
│  │Executor │                │Executor │←───│Replanner │    │
│  └────┬────┘                └────┬────┘    └────┬─────┘    │
│       ↓                          ↓              ↑           │
│    Result                   ┌─────────┐         │           │
│                             │Fallback │─────────┘           │
│                             │ Manager │                     │
│                             └────┬────┘                     │
│                                  ↓                          │
│                               Result                         │
│                                                              │
│  Use: Simple workflows      Use: Complex, error-prone tasks │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Component Responsibilities

```
┌─────────────────────────────────────────────────────────────┐
│                  COMPONENT RESPONSIBILITIES                  │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  PLANNER                                                     │
│  ├─ Analyze task requirements                                │
│  ├─ Generate step-by-step plan                               │
│  ├─ Identify tool dependencies                               │
│  ├─ Estimate complexity and cost                             │
│  └─ Output: Structured Plan object                           │
│                                                              │
│  EXECUTOR                                                    │
│  ├─ Execute steps sequentially or in parallel                │
│  ├─ Track completed work                                     │
│  ├─ Handle step-level errors                                 │
│  ├─ Report progress                                          │
│  └─ Output: Step results + state                             │
│                                                              │
│  REPLANNER                                                   │
│  ├─ Analyze execution failures                               │
│  ├─ Consider completed work                                  │
│  ├─ Generate revised plan                                    │
│  ├─ Preserve successful steps                                │
│  └─ Output: Updated Plan object                              │
│                                                              │
│  FALLBACK MANAGER                                            │
│  ├─ Classify errors                                          │
│  ├─ Select appropriate fallback                              │
│  ├─ Execute fallback actions                                 │
│  ├─ Track fallback budget                                    │
│  └─ Escalate when exhausted                                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

## Implementation Patterns

### Pattern 1: Simple Planner-Executor

**Use Case**: Straightforward multi-step tasks with reliable tools

```typescript
import { generateObject, generateText } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';

// Schema definitions
const StepSchema = z.object({
  id: z.number(),
  action: z.string(),
  tool: z.string(),
  parameters: z.record(z.unknown()),
  dependsOn: z.array(z.number()).default([]),
});

const PlanSchema = z.object({
  goal: z.string(),
  steps: z.array(StepSchema),
  estimatedTokens: z.number(),
  reasoning: z.string(),
});

type Plan = z.infer<typeof PlanSchema>;
type Step = z.infer<typeof StepSchema>;

// Tool registry interface
interface ToolRegistry {
  has(name: string): boolean;
  describe(): string;
  execute(name: string, params: Record<string, unknown>): Promise<unknown>;
  getSchema(name: string): z.ZodSchema | undefined;
}

// Simple Planner
async function generatePlan(
  task: string,
  tools: ToolRegistry,
  model = openai('gpt-4o')
): Promise<Plan> {
  const { object } = await generateObject({
    model,
    schema: PlanSchema,
    prompt: `Create a step-by-step plan for this task:

Task: ${task}

Available tools:
${tools.describe()}

Requirements:
1. Each step should use exactly one tool
2. Include all required parameters for each tool
3. Order steps logically (dependencies first)
4. Estimate total token usage

Return a structured plan.`,
  });

  return object;
}

// Simple Executor
async function executePlan(
  plan: Plan,
  tools: ToolRegistry,
  onProgress?: (step: number, total: number, result: unknown) => void
): Promise<Map<number, unknown>> {
  const results = new Map<number, unknown>();

  // Topological sort for dependency order
  const sortedSteps = topologicalSort(plan.steps);

  for (const step of sortedSteps) {
    // Wait for dependencies
    const deps = step.dependsOn.map(id => results.get(id));

    // Execute step
    const result = await tools.execute(step.tool, {
      ...step.parameters,
      _dependencies: deps,
    });

    results.set(step.id, result);
    onProgress?.(step.id, plan.steps.length, result);
  }

  return results;
}

// Topological sort helper
function topologicalSort(steps: Step[]): Step[] {
  const sorted: Step[] = [];
  const visited = new Set<number>();

  function visit(step: Step) {
    if (visited.has(step.id)) return;
    visited.add(step.id);

    for (const depId of step.dependsOn) {
      const dep = steps.find(s => s.id === depId);
      if (dep) visit(dep);
    }

    sorted.push(step);
  }

  for (const step of steps) {
    visit(step);
  }

  return sorted;
}

// Main orchestration
async function simplePlanAndExecute(
  task: string,
  tools: ToolRegistry
): Promise<{ plan: Plan; results: Map<number, unknown> }> {
  console.log('Planning...');
  const plan = await generatePlan(task, tools);
  console.log(`Generated ${plan.steps.length} step plan`);

  console.log('Executing...');
  const results = await executePlan(plan, tools, (step, total, result) => {
    console.log(`Step ${step}/${total} complete`);
  });

  return { plan, results };
}
```

### Pattern 2: Full Plan-Execute-Replan with Fallbacks

**Use Case**: Complex tasks with external dependencies and error handling

```typescript
import { generateObject } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';

// Extended schemas
const ExecutionStateSchema = z.object({
  goal: z.string(),
  currentPlan: PlanSchema,
  completedSteps: z.array(z.object({
    step: StepSchema,
    result: z.unknown(),
    timestamp: z.number(),
  })),
  failedSteps: z.array(z.object({
    step: StepSchema,
    error: z.string(),
    timestamp: z.number(),
  })),
  replanCount: z.number(),
  fallbacksUsed: z.number(),
});

type ExecutionState = z.infer<typeof ExecutionStateSchema>;

// Configuration
interface PlanExecuteConfig {
  maxReplans: number;
  maxFallbacks: number;
  timeoutMs: number;
  onProgress?: (state: ExecutionState) => void;
  onReplan?: (reason: string, newPlan: Plan) => void;
}

const DEFAULT_CONFIG: PlanExecuteConfig = {
  maxReplans: 3,
  maxFallbacks: 5,
  timeoutMs: 60000,
};

// Replanner
async function replan(
  state: ExecutionState,
  error: Error,
  tools: ToolRegistry
): Promise<Plan> {
  const completedSummary = state.completedSteps
    .map(s => `✓ ${s.step.action}: ${JSON.stringify(s.result).slice(0, 100)}`)
    .join('\n');

  const failedSummary = state.failedSteps
    .map(s => `✗ ${s.step.action}: ${s.error}`)
    .join('\n');

  const { object } = await generateObject({
    model: openai('gpt-4o'),
    schema: PlanSchema,
    prompt: `The previous plan failed. Create a new plan that avoids the same failure.

Original Goal: ${state.goal}

Completed Steps:
${completedSummary || 'None'}

Failed Steps:
${failedSummary}

Current Error: ${error.message}

Available Tools:
${tools.describe()}

Requirements:
1. Don't repeat approaches that already failed
2. Consider what was learned from the error
3. Reuse results from completed steps where possible
4. Find an alternative approach if direct path is blocked

Create a revised plan starting from the current state.`,
  });

  return object;
}

// Error classification
type ErrorType =
  | 'TOOL_NOT_FOUND'
  | 'RESOURCE_NOT_FOUND'
  | 'PERMISSION_DENIED'
  | 'RATE_LIMITED'
  | 'SERVICE_UNAVAILABLE'
  | 'VALIDATION_ERROR'
  | 'TIMEOUT'
  | 'UNKNOWN';

function classifyError(error: Error): ErrorType {
  const msg = error.message.toLowerCase();
  if (msg.includes('not found') && msg.includes('tool')) return 'TOOL_NOT_FOUND';
  if (msg.includes('not found') || msg.includes('404')) return 'RESOURCE_NOT_FOUND';
  if (msg.includes('permission') || msg.includes('403')) return 'PERMISSION_DENIED';
  if (msg.includes('rate') || msg.includes('429')) return 'RATE_LIMITED';
  if (msg.includes('unavailable') || msg.includes('503')) return 'SERVICE_UNAVAILABLE';
  if (msg.includes('validation') || msg.includes('invalid')) return 'VALIDATION_ERROR';
  if (msg.includes('timeout')) return 'TIMEOUT';
  return 'UNKNOWN';
}

// Fallback handler
interface FallbackResult {
  success: boolean;
  result?: unknown;
  shouldReplan: boolean;
}

async function attemptFallback(
  step: Step,
  error: Error,
  tools: ToolRegistry,
  state: ExecutionState
): Promise<FallbackResult> {
  const errorType = classifyError(error);

  switch (errorType) {
    case 'RATE_LIMITED':
      // Exponential backoff retry
      const delay = Math.pow(2, state.fallbacksUsed) * 1000;
      await sleep(Math.min(delay, 30000));
      try {
        const result = await tools.execute(step.tool, step.parameters);
        return { success: true, result, shouldReplan: false };
      } catch {
        return { success: false, shouldReplan: true };
      }

    case 'RESOURCE_NOT_FOUND':
      // Try to search for alternative
      if (tools.has('search')) {
        try {
          const searchResult = await tools.execute('search', {
            query: JSON.stringify(step.parameters),
          });
          return { success: true, result: searchResult, shouldReplan: false };
        } catch {
          return { success: false, shouldReplan: true };
        }
      }
      return { success: false, shouldReplan: true };

    case 'SERVICE_UNAVAILABLE':
      // Single retry after short delay
      await sleep(2000);
      try {
        const result = await tools.execute(step.tool, step.parameters);
        return { success: true, result, shouldReplan: false };
      } catch {
        return { success: false, shouldReplan: true };
      }

    default:
      return { success: false, shouldReplan: true };
  }
}

// Main orchestrator
async function fullPlanExecuteReplan(
  task: string,
  tools: ToolRegistry,
  config: Partial<PlanExecuteConfig> = {}
): Promise<ExecutionState> {
  const cfg = { ...DEFAULT_CONFIG, ...config };

  // Initialize state
  let state: ExecutionState = {
    goal: task,
    currentPlan: await generatePlan(task, tools),
    completedSteps: [],
    failedSteps: [],
    replanCount: 0,
    fallbacksUsed: 0,
  };

  const startTime = Date.now();

  while (true) {
    // Check timeout
    if (Date.now() - startTime > cfg.timeoutMs) {
      throw new Error(`Execution timeout after ${cfg.timeoutMs}ms`);
    }

    // Get next step to execute
    const completedIds = new Set(state.completedSteps.map(s => s.step.id));
    const nextStep = state.currentPlan.steps.find(s => !completedIds.has(s.id));

    if (!nextStep) {
      // All steps complete
      return state;
    }

    // Check dependencies are satisfied
    const depsSatisfied = nextStep.dependsOn.every(id => completedIds.has(id));
    if (!depsSatisfied) {
      throw new Error(`Dependency not satisfied for step ${nextStep.id}`);
    }

    try {
      // Execute step
      const result = await tools.execute(nextStep.tool, nextStep.parameters);

      state.completedSteps.push({
        step: nextStep,
        result,
        timestamp: Date.now(),
      });

      cfg.onProgress?.(state);

    } catch (error) {
      // Step failed - try fallback
      if (state.fallbacksUsed < cfg.maxFallbacks) {
        state.fallbacksUsed++;
        const fallbackResult = await attemptFallback(
          nextStep,
          error as Error,
          tools,
          state
        );

        if (fallbackResult.success) {
          state.completedSteps.push({
            step: nextStep,
            result: fallbackResult.result,
            timestamp: Date.now(),
          });
          cfg.onProgress?.(state);
          continue;
        }
      }

      // Fallback failed or exhausted - try replan
      state.failedSteps.push({
        step: nextStep,
        error: (error as Error).message,
        timestamp: Date.now(),
      });

      if (state.replanCount < cfg.maxReplans) {
        state.replanCount++;
        const newPlan = await replan(state, error as Error, tools);
        state.currentPlan = newPlan;
        cfg.onReplan?.((error as Error).message, newPlan);
      } else {
        throw new Error(
          `Max replans (${cfg.maxReplans}) exceeded. Last error: ${error}`
        );
      }
    }
  }
}

// Helper
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

### Pattern 3: Parallel Execution with Dependencies

**Use Case**: Maximize throughput for independent steps

```typescript
import { generateObject } from 'ai';
import { z } from 'zod';

interface DependencyGraph {
  steps: Map<number, Step>;
  dependencies: Map<number, Set<number>>;
  dependents: Map<number, Set<number>>;
}

function buildDependencyGraph(plan: Plan): DependencyGraph {
  const steps = new Map<number, Step>();
  const dependencies = new Map<number, Set<number>>();
  const dependents = new Map<number, Set<number>>();

  for (const step of plan.steps) {
    steps.set(step.id, step);
    dependencies.set(step.id, new Set(step.dependsOn));
    dependents.set(step.id, new Set());
  }

  // Build reverse mapping
  for (const step of plan.steps) {
    for (const depId of step.dependsOn) {
      dependents.get(depId)?.add(step.id);
    }
  }

  return { steps, dependencies, dependents };
}

async function parallelExecute(
  plan: Plan,
  tools: ToolRegistry,
  maxConcurrency = 5
): Promise<Map<number, unknown>> {
  const graph = buildDependencyGraph(plan);
  const results = new Map<number, unknown>();
  const inProgress = new Set<number>();
  const completed = new Set<number>();

  // Find steps ready to execute (no unmet dependencies)
  function getReadySteps(): Step[] {
    const ready: Step[] = [];

    for (const [id, step] of graph.steps) {
      if (completed.has(id) || inProgress.has(id)) continue;

      const deps = graph.dependencies.get(id)!;
      const allDepsMet = [...deps].every(d => completed.has(d));

      if (allDepsMet) {
        ready.push(step);
      }
    }

    return ready;
  }

  // Execute until all complete
  while (completed.size < plan.steps.length) {
    const ready = getReadySteps();

    if (ready.length === 0 && inProgress.size === 0) {
      throw new Error('Deadlock: no steps ready and none in progress');
    }

    // Start new steps up to concurrency limit
    const toStart = ready.slice(0, maxConcurrency - inProgress.size);

    const executions = toStart.map(async (step) => {
      inProgress.add(step.id);

      try {
        // Get dependency results
        const depResults = step.dependsOn.map(id => results.get(id));

        const result = await tools.execute(step.tool, {
          ...step.parameters,
          _dependencies: depResults,
        });

        results.set(step.id, result);
        completed.add(step.id);
        inProgress.delete(step.id);

        return { stepId: step.id, success: true };
      } catch (error) {
        inProgress.delete(step.id);
        throw error;
      }
    });

    // Wait for at least one to complete
    await Promise.race(executions);
  }

  return results;
}

// Parallel plan and execute
async function parallelPlanAndExecute(
  task: string,
  tools: ToolRegistry,
  options: {
    maxConcurrency?: number;
    onStepComplete?: (stepId: number, result: unknown) => void;
  } = {}
): Promise<{ plan: Plan; results: Map<number, unknown> }> {
  // Generate plan optimized for parallelism
  const plan = await generatePlan(task, tools);

  // Analyze parallelism potential
  const graph = buildDependencyGraph(plan);
  const levels = computeParallelLevels(graph);
  console.log(`Plan has ${levels.length} parallel levels`);

  // Execute with parallelism
  const results = await parallelExecute(
    plan,
    tools,
    options.maxConcurrency ?? 5
  );

  return { plan, results };
}

// Compute parallel execution levels
function computeParallelLevels(graph: DependencyGraph): Step[][] {
  const levels: Step[][] = [];
  const assigned = new Set<number>();

  while (assigned.size < graph.steps.size) {
    const level: Step[] = [];

    for (const [id, step] of graph.steps) {
      if (assigned.has(id)) continue;

      const deps = graph.dependencies.get(id)!;
      const allDepsAssigned = [...deps].every(d => assigned.has(d));

      if (allDepsAssigned) {
        level.push(step);
      }
    }

    for (const step of level) {
      assigned.add(step.id);
    }

    levels.push(level);
  }

  return levels;
}
```

## Framework Integration

### AI SDK v6 Agent Implementation

```typescript
import { ToolLoopAgent, tool, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';

// Plan-aware agent with structured planning
const planningAgent = new ToolLoopAgent({
  model: openai('gpt-4o'),
  instructions: `You are a planning agent that creates and executes multi-step plans.

When given a task:
1. First use createPlan to generate a structured plan
2. Then execute each step using the appropriate tools
3. If a step fails, use revisePlan to create an alternative approach
4. Report progress after each step

Always plan before acting. Never skip the planning phase.`,

  tools: {
    createPlan: tool({
      description: 'Create a structured plan for a complex task',
      inputSchema: z.object({
        task: z.string().describe('The task to plan'),
        constraints: z.array(z.string()).optional().describe('Any constraints'),
      }),
      execute: async ({ task, constraints }) => {
        const plan = await generatePlan(task, globalToolRegistry);
        return {
          planId: crypto.randomUUID(),
          steps: plan.steps.map(s => ({
            id: s.id,
            action: s.action,
            tool: s.tool,
          })),
          reasoning: plan.reasoning,
        };
      },
    }),

    revisePlan: tool({
      description: 'Revise a plan after a failure',
      inputSchema: z.object({
        originalPlan: z.string().describe('The original plan ID'),
        failedStep: z.number().describe('The step that failed'),
        error: z.string().describe('The error message'),
        completedSteps: z.array(z.number()).describe('Successfully completed steps'),
      }),
      execute: async ({ originalPlan, failedStep, error, completedSteps }) => {
        // Implementation would track state and replan
        return {
          newPlanId: crypto.randomUUID(),
          message: 'Plan revised to avoid the failure',
        };
      },
    }),

    // Domain-specific tools would be added here
    searchContent: tool({
      description: 'Search for content',
      inputSchema: z.object({
        query: z.string(),
        type: z.enum(['post', 'page', 'image']).optional(),
      }),
      execute: async ({ query, type }) => {
        // Implementation
        return { results: [] };
      },
    }),
  },

  stopWhen: stepCountIs(30),
});

// Usage
const result = await planningAgent.generate({
  prompt: 'Create a blog post about AI trends with relevant images',
});
```

### Streaming Plan Execution

```typescript
import { createAgentUIStreamResponse } from 'ai';

// API route for streaming plan execution
export async function POST(request: Request) {
  const { task, options } = await request.json();

  // Create stream for progress updates
  const encoder = new TextEncoder();
  const stream = new TransformStream();
  const writer = stream.writable.getWriter();

  // Execute in background, stream progress
  (async () => {
    try {
      const result = await fullPlanExecuteReplan(
        task,
        globalToolRegistry,
        {
          ...options,
          onProgress: async (state) => {
            await writer.write(encoder.encode(
              `data: ${JSON.stringify({
                type: 'progress',
                completed: state.completedSteps.length,
                total: state.currentPlan.steps.length,
                lastStep: state.completedSteps.at(-1)?.step.action,
              })}\n\n`
            ));
          },
          onReplan: async (reason, newPlan) => {
            await writer.write(encoder.encode(
              `data: ${JSON.stringify({
                type: 'replan',
                reason,
                newSteps: newPlan.steps.length,
              })}\n\n`
            ));
          },
        }
      );

      await writer.write(encoder.encode(
        `data: ${JSON.stringify({
          type: 'complete',
          results: Object.fromEntries(
            state.completedSteps.map(s => [s.step.id, s.result])
          ),
        })}\n\n`
      ));
    } catch (error) {
      await writer.write(encoder.encode(
        `data: ${JSON.stringify({
          type: 'error',
          message: (error as Error).message,
        })}\n\n`
      ));
    } finally {
      await writer.close();
    }
  })();

  return new Response(stream.readable, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

## Production Best Practices

### 1. State Persistence

Persist execution state for recovery:

```typescript
interface PersistentState {
  id: string;
  task: string;
  state: ExecutionState;
  createdAt: Date;
  updatedAt: Date;
}

class StatePersistence {
  constructor(private db: Database) {}

  async save(state: ExecutionState): Promise<string> {
    const id = crypto.randomUUID();
    await this.db.insert({
      id,
      task: state.goal,
      state: JSON.stringify(state),
      createdAt: new Date(),
      updatedAt: new Date(),
    });
    return id;
  }

  async update(id: string, state: ExecutionState): Promise<void> {
    await this.db.update(id, {
      state: JSON.stringify(state),
      updatedAt: new Date(),
    });
  }

  async load(id: string): Promise<ExecutionState | null> {
    const record = await this.db.findById(id);
    if (!record) return null;
    return JSON.parse(record.state);
  }

  async resume(id: string, tools: ToolRegistry): Promise<ExecutionState> {
    const state = await this.load(id);
    if (!state) throw new Error(`No state found for ${id}`);

    return fullPlanExecuteReplan(state.goal, tools, {
      initialState: state, // Resume from persisted state
    });
  }
}
```

### 2. Cost Tracking

Monitor token usage and execution costs:

```typescript
interface CostTracker {
  planningTokens: number;
  executionTokens: number;
  replanningTokens: number;
  totalCost: number;
}

function createCostTracker(): CostTracker {
  return {
    planningTokens: 0,
    executionTokens: 0,
    replanningTokens: 0,
    get totalCost() {
      const inputCost = 0.000003; // $3/1M tokens
      const outputCost = 0.000015; // $15/1M tokens
      return (this.planningTokens + this.executionTokens + this.replanningTokens) * inputCost;
    },
  };
}

async function trackedPlanAndExecute(
  task: string,
  tools: ToolRegistry
): Promise<{ result: ExecutionState; costs: CostTracker }> {
  const costs = createCostTracker();

  // Wrap tools to track tokens
  const trackedTools = wrapToolsWithTracking(tools, costs);

  const result = await fullPlanExecuteReplan(task, trackedTools);

  console.log(`Total cost: $${costs.totalCost.toFixed(4)}`);

  return { result, costs };
}
```

### 3. Execution Timeouts

Prevent runaway executions:

```typescript
async function withTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number,
  onTimeout?: () => void
): Promise<T> {
  let timeoutId: NodeJS.Timeout;

  const timeoutPromise = new Promise<never>((_, reject) => {
    timeoutId = setTimeout(() => {
      onTimeout?.();
      reject(new Error(`Operation timed out after ${timeoutMs}ms`));
    }, timeoutMs);
  });

  try {
    return await Promise.race([promise, timeoutPromise]);
  } finally {
    clearTimeout(timeoutId);
  }
}

// Usage
const result = await withTimeout(
  fullPlanExecuteReplan(task, tools),
  60000, // 60 second timeout
  () => console.log('Execution timing out, cleaning up...')
);
```

## Observability & Debugging

### Structured Logging

```typescript
interface PlanExecutionLog {
  traceId: string;
  task: string;
  phases: Array<{
    phase: 'planning' | 'execution' | 'replanning';
    startTime: number;
    endTime: number;
    tokens: number;
    success: boolean;
    details: unknown;
  }>;
  totalDuration: number;
  totalTokens: number;
  outcome: 'success' | 'partial' | 'failed';
}

class ExecutionLogger {
  private log: PlanExecutionLog;

  constructor(task: string) {
    this.log = {
      traceId: crypto.randomUUID(),
      task,
      phases: [],
      totalDuration: 0,
      totalTokens: 0,
      outcome: 'success',
    };
  }

  startPhase(phase: PlanExecutionLog['phases'][0]['phase']): () => void {
    const startTime = Date.now();

    return (details: unknown = {}, tokens = 0, success = true) => {
      this.log.phases.push({
        phase,
        startTime,
        endTime: Date.now(),
        tokens,
        success,
        details,
      });
    };
  }

  finalize(): PlanExecutionLog {
    this.log.totalDuration = this.log.phases.reduce(
      (sum, p) => sum + (p.endTime - p.startTime),
      0
    );
    this.log.totalTokens = this.log.phases.reduce(
      (sum, p) => sum + p.tokens,
      0
    );
    return this.log;
  }
}
```

### Debugging Tools

```typescript
// Dry-run mode for testing plans
async function dryRunPlan(
  task: string,
  tools: ToolRegistry
): Promise<{ plan: Plan; issues: string[] }> {
  const plan = await generatePlan(task, tools);
  const issues: string[] = [];

  // Validate each step
  for (const step of plan.steps) {
    if (!tools.has(step.tool)) {
      issues.push(`Step ${step.id}: Unknown tool "${step.tool}"`);
    }

    const schema = tools.getSchema(step.tool);
    if (schema) {
      const validation = schema.safeParse(step.parameters);
      if (!validation.success) {
        issues.push(`Step ${step.id}: Invalid params - ${validation.error.message}`);
      }
    }

    // Check dependencies exist
    for (const dep of step.dependsOn) {
      if (!plan.steps.some(s => s.id === dep)) {
        issues.push(`Step ${step.id}: Missing dependency ${dep}`);
      }
    }
  }

  return { plan, issues };
}
```

## Key Takeaways

1. **Start simple**: Use basic planner-executor for straightforward workflows
2. **Add complexity incrementally**: Layer in replanning and fallbacks as needed
3. **Parallelize where possible**: Independent steps should run concurrently
4. **Persist state**: Enable resume from failures
5. **Track costs**: Monitor token usage and execution time
6. **Log everything**: Structured logging enables debugging

**Quick Implementation Checklist**:

- [ ] Choose appropriate pattern (simple/full/parallel)
- [ ] Define tool registry with Zod schemas
- [ ] Implement planning with structured output
- [ ] Add execution with progress tracking
- [ ] Implement error classification and fallbacks
- [ ] Add state persistence for recovery
- [ ] Set up cost tracking and timeouts
- [ ] Configure structured logging

## References

1. **AI SDK v6** (2025). "Agent Abstraction Documentation". https://ai-sdk.dev/docs/agents
2. **LangGraph** (2024). "Plan-and-Execute Tutorial". https://langchain-ai.github.io/langgraph/tutorials/plan-and-execute/
3. **Anthropic** (2024). "Tool Use Best Practices". https://docs.anthropic.com/
4. **Wang et al.** (2023). "Plan-and-Solve Prompting". ACL 2023.
5. **Xu et al.** (2023). "ReWOO: Decoupling Reasoning from Observations". arXiv.

**Related Topics**:

- [6.1.1 Separate Planning from Execution](./6.1.1-separation.md)
- [6.2.1 Reflexion Loop](./6.2.1-reflexion-loop.md)
- [3.1.1 ReAct Pattern](../3-agents/3.1.1-react-pattern.md)

**Layer Index**: [Layer 6: Planning & Orchestration](../AI_KNOWLEDGE_BASE_TOC.md#layer-6-planning--orchestration)
