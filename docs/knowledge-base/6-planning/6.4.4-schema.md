# 6.4.4 Schema Compatibility

## TL;DR

Schema validation ensures tool parameters match expected types, formats, and structures before execution—catching malformed inputs instantly with Zod parsing, preventing runtime type errors, and providing clear feedback on exactly what's wrong.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-12
- **Prerequisites**: [6.4.1 Check Before Execute](./6.4.1-check-before-execute.md)
- **Grounded In**: AI SDK Tool Schemas, Zod Validation, TypeScript Type Safety

## Overview

Schema validation is the fastest and cheapest preflight check—pure CPU validation with no I/O. It catches type mismatches, missing required fields, and format violations before any database or API calls.

**Key Insight**: LLMs frequently generate malformed tool parameters. Schema validation catches these immediately with actionable error messages.

**Date Verified**: 2025-12-12

## Schema Definition Patterns

### Basic Zod Schema

```typescript
import { z } from 'zod';
import { tool } from 'ai';

const updatePageSchema = z.object({
  pageId: z.string().uuid('Page ID must be a valid UUID'),
  title: z.string().min(1).max(200).optional(),
  slug: z
    .string()
    .regex(/^[a-z0-9-]+$/, 'Slug must be lowercase alphanumeric with hyphens')
    .optional(),
  content: z.string().optional(),
  status: z.enum(['draft', 'published', 'archived']).optional(),
  metadata: z
    .object({
      description: z.string().max(300).optional(),
      keywords: z.array(z.string()).max(10).optional(),
    })
    .optional(),
});

const updatePageTool = tool({
  description: 'Update an existing page',
  inputSchema: updatePageSchema,
  execute: async (params) => {
    // params is fully typed and validated
    return updatePage(params);
  },
});
```

### Schema with Transformations

```typescript
const createPostSchema = z.object({
  title: z.string().min(1).transform(s => s.trim()),
  slug: z
    .string()
    .optional()
    .transform((s, ctx) => {
      if (s) return s.toLowerCase().replace(/\s+/g, '-');
      // Auto-generate from title if not provided
      return ctx.parent?.title?.toLowerCase().replace(/\s+/g, '-') ?? 'untitled';
    }),
  publishAt: z
    .string()
    .datetime()
    .optional()
    .transform(s => (s ? new Date(s) : undefined)),
});
```

### Schema with Refinements

```typescript
const dateRangeSchema = z
  .object({
    startDate: z.string().datetime(),
    endDate: z.string().datetime(),
  })
  .refine(data => new Date(data.startDate) < new Date(data.endDate), {
    message: 'Start date must be before end date',
    path: ['endDate'],
  });

const priceSchema = z
  .object({
    price: z.number(),
    currency: z.enum(['USD', 'EUR', 'GBP']),
    discount: z.number().min(0).max(100).optional(),
  })
  .refine(
    data => {
      if (data.discount && data.discount > 50 && data.price < 10) {
        return false; // No >50% discount on items under $10
      }
      return true;
    },
    { message: 'Discount too high for low-priced item' }
  );
```

## Validation Integration

### Schema Validation in Preflight

```typescript
class SchemaValidator {
  private schemas = new Map<string, z.ZodSchema>();

  register(toolName: string, schema: z.ZodSchema): void {
    this.schemas.set(toolName, schema);
  }

  validate(
    toolName: string,
    params: unknown
  ): {
    valid: boolean;
    data?: unknown;
    errors?: Array<{ path: string; message: string }>;
  } {
    const schema = this.schemas.get(toolName);
    if (!schema) {
      return { valid: true, data: params }; // No schema = no validation
    }

    const result = schema.safeParse(params);

    if (result.success) {
      return { valid: true, data: result.data };
    }

    return {
      valid: false,
      errors: result.error.issues.map(issue => ({
        path: issue.path.join('.'),
        message: issue.message,
      })),
    };
  }
}
```

### Error Formatting

```typescript
function formatSchemaErrors(
  errors: Array<{ path: string; message: string }>
): string {
  if (errors.length === 0) return 'No errors';

  if (errors.length === 1) {
    const e = errors[0];
    return e.path ? `${e.path}: ${e.message}` : e.message;
  }

  return errors.map(e => (e.path ? `• ${e.path}: ${e.message}` : `• ${e.message}`)).join('\n');
}

// Example output:
// Single error: "slug: Slug must be lowercase alphanumeric with hyphens"
// Multiple errors:
// • title: Required
// • slug: Slug must be lowercase alphanumeric with hyphens
// • publishAt: Invalid datetime format
```

## Common Validation Patterns

### ID Formats

```typescript
const idSchemas = {
  uuid: z.string().uuid(),
  cuid: z.string().cuid(),
  nanoid: z.string().length(21),
  numeric: z.string().regex(/^\d+$/),
  slug: z.string().regex(/^[a-z0-9-]+$/),
};
```

### Content Types

```typescript
const contentSchemas = {
  html: z.string().refine(
    s => !/<script/i.test(s),
    'HTML cannot contain script tags'
  ),
  markdown: z.string(),
  json: z.string().refine(s => {
    try {
      JSON.parse(s);
      return true;
    } catch {
      return false;
    }
  }, 'Must be valid JSON'),
  url: z.string().url(),
  email: z.string().email(),
};
```

### Arrays and Limits

```typescript
const arraySchemas = {
  tags: z.array(z.string()).min(1).max(10),
  ids: z.array(z.string().uuid()).min(1).max(100),
  items: z.array(itemSchema).nonempty(),
};
```

## Integration with Preflight Checker

```typescript
class PreflightChecker {
  constructor(private schemaValidator: SchemaValidator) {}

  async check(
    toolName: string,
    params: Record<string, unknown>
  ): Promise<PreflightResult> {
    const checks: PreflightResult['checks'] = [];

    // Schema validation (first, cheapest check)
    const schemaResult = this.schemaValidator.validate(toolName, params);

    if (!schemaResult.valid) {
      checks.push({
        name: 'schema_validation',
        passed: false,
        message: `Invalid parameters:\n${formatSchemaErrors(schemaResult.errors!)}`,
        suggestions: this.generateSchemaSuggestions(toolName, schemaResult.errors!),
      });

      // Early return - no point checking other things with invalid params
      return {
        canExecute: false,
        checks,
        blockers: [checks[0].message],
      };
    }

    checks.push({
      name: 'schema_validation',
      passed: true,
      message: 'Parameters valid',
    });

    // Continue with other checks using validated data
    // ...

    return {
      canExecute: checks.every(c => c.passed),
      checks,
      blockers: checks.filter(c => !c.passed).map(c => c.message),
    };
  }

  private generateSchemaSuggestions(
    toolName: string,
    errors: Array<{ path: string; message: string }>
  ): string[] {
    const suggestions: string[] = [];

    for (const error of errors) {
      if (error.message.includes('Required')) {
        suggestions.push(`Provide a value for "${error.path}"`);
      }
      if (error.message.includes('uuid')) {
        suggestions.push(`"${error.path}" should be a UUID like "123e4567-e89b-12d3-a456-426614174000"`);
      }
      if (error.message.includes('datetime')) {
        suggestions.push(`"${error.path}" should be ISO 8601 format like "2024-01-15T10:30:00Z"`);
      }
    }

    return suggestions;
  }
}
```

## Key Takeaways

1. **Validate first**: Schema validation is instant—always do it first
2. **Clear error messages**: Custom Zod messages help LLMs understand what's wrong
3. **Use transformations**: Clean/normalize input during validation
4. **Refinements for logic**: Cross-field validation with `.refine()`
5. **Early return on failure**: Don't check other things if schema fails

## References

1. **Zod** (2024). "TypeScript-first Schema Validation".
2. **AI SDK** (2024). "Tool Definition Patterns".

**Related Topics**: [6.4.1 Check Before Execute](./6.4.1-check-before-execute.md), [6.4.5 Suggestions](./6.4.5-suggestions.md)

**Layer Index**: [Layer 6: Planning & Orchestration](../AI_KNOWLEDGE_BASE_TOC.md#layer-6-planning--orchestration)
