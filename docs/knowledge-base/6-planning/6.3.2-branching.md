# 6.3.2 Branching Strategies

## TL;DR

Branching strategies determine how many and which alternative paths to explore at each decision point—fixed branching generates K alternatives per node while adaptive branching adjusts based on state uncertainty, with 3-5 branches typically optimal for quality/cost balance.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-12
- **Prerequisites**: [6.3.1 Multi-Path Exploration](./6.3.1-multi-path.md)
- **Grounded In**: Tree of Thoughts (2023), MCTS (Monte Carlo Tree Search), Search Algorithm Theory

## Overview

Branching strategies control the "width" of exploration in Tree of Thoughts and related methods. The branching factor directly impacts both solution quality (more branches = more options) and cost (more branches = more LLM calls). Effective strategies balance exploration breadth against computational budget.

**Key Trade-offs**:
- **Fixed K=3**: Predictable cost, may miss better options
- **Adaptive**: Explore more when uncertain, less when confident
- **Constrained**: Domain-specific rules limit valid branches

**Date Verified**: 2025-12-12

## Core Strategies

### Fixed Branching (K-way)

```typescript
async function fixedBranching(
  state: string,
  k: number = 3
): Promise<Thought[]> {
  const { object } = await generateObject({
    model: openai('gpt-4o'),
    schema: z.object({
      thoughts: z.array(z.object({
        action: z.string(),
        newState: z.string(),
      })).length(k),
    }),
    prompt: `Generate exactly ${k} different next steps from: ${state}`,
  });
  return object.thoughts;
}
```

**Pros**: Predictable cost, simple to implement
**Cons**: May generate low-quality branches to fill quota

### Adaptive Branching

```typescript
async function adaptiveBranching(
  state: string,
  confidence: number // 0-1: how certain we are about direction
): Promise<Thought[]> {
  // Low confidence = explore more, high confidence = explore less
  const k = Math.max(2, Math.round(5 * (1 - confidence)));

  return generateThoughts(state, k);
}
```

**Pros**: Efficient resource allocation
**Cons**: Requires confidence estimation

### Constrained Branching

```typescript
async function constrainedBranching(
  state: string,
  validActions: string[] // Domain-specific constraints
): Promise<Thought[]> {
  return validActions.map(action => ({
    action,
    newState: applyAction(state, action),
  }));
}
```

**Pros**: Only explores valid paths
**Cons**: Requires domain knowledge

## Optimal Branching Factor

| Task Type | Optimal K | Reasoning |
|-----------|-----------|-----------|
| Math/Logic | 3-4 | Limited valid operations |
| Code | 3-5 | Multiple approaches common |
| Creative | 5-7 | Diversity valuable |
| Planning | 2-3 | High per-branch cost |

## Key Takeaways

1. **K=3 is a good default**: Balances exploration and cost
2. **Adapt to confidence**: More branches when uncertain
3. **Domain constraints help**: Limit to valid options
4. **Quality > quantity**: Better to have 3 good branches than 5 mediocre

## References

1. **Yao et al.** (2023). "Tree of Thoughts". NeurIPS 2023.
2. **Browne et al.** (2012). "A Survey of Monte Carlo Tree Search Methods". IEEE.

**Related Topics**: [6.3.1 Multi-Path](./6.3.1-multi-path.md), [6.3.3 Pruning](./6.3.3-pruning.md)

**Layer Index**: [Layer 6: Planning & Orchestration](../AI_KNOWLEDGE_BASE_TOC.md#layer-6-planning--orchestration)
