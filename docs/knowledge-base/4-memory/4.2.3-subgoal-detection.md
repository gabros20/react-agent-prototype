# 4.2.3 - Subgoal Detection

## TL;DR

**Subgoal detection identifies when an agent transitions between intermediate goals within a task, enabling hierarchical memory compression by grouping related actions into meaningful chunks—LLM-based generation achieves 95% accuracy while heuristic detection offers 60-70% accuracy at zero cost.**

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-11
- **Prerequisites**: [4.2.1 HiAgent Hierarchical Memory](./4.2.1-hiagent-hierarchical-memory.md), [4.2.2 Compression Triggers](./4.2.2-compression-triggers.md)
- **Grounded In**: HiAgent (ACL 2025), ReAcTree (ICLR 2025), SelfGoal (2024)

## Table of Contents

- [Overview](#overview)
- [The Problem: Flat Action History](#the-problem-flat-action-history)
- [Core Concept](#core-concept)
- [Implementation Patterns](#implementation-patterns)
- [Framework Integration](#framework-integration)
- [Research & Benchmarks](#research--benchmarks)
- [When to Use This Pattern](#when-to-use-this-pattern)
- [Production Best Practices](#production-best-practices)
- [Key Takeaways](#key-takeaways)
- [References](#references)

## Overview

Subgoal detection is the process of identifying meaningful boundaries within a sequence of agent actions. When an agent completes one intermediate objective and moves to another, detection mechanisms recognize this transition and trigger memory compression of the completed work.

The approach mirrors human cognition—we don't remember every keystroke when writing a document, we remember "wrote the introduction" and "added the conclusion." Effective subgoal detection enables this same level of abstraction for AI agents.

**Key Research Findings (2024-2025)**:

- **HiAgent (ACL 2025)**: Explicit subgoal generation achieves 95% detection accuracy
- **Heuristic Detection**: Pattern-based approaches achieve 60-70% accuracy at zero cost
- **Performance Impact**: Proper subgoals yield 42% task success vs 21% without
- **Compression Benefit**: 75% token reduction when grouping actions by subgoal

## The Problem: Flat Action History

### The Classic Challenge

Without subgoal detection, all actions are treated equally—no structure, no grouping, no meaningful compression:

```
Action sequence (flat):
1. open_boot → Boot opened
2. get_jack → Jack retrieved
3. get_wrench → Wrench retrieved
4. loosen_nut1 → Nut 1 loosened
5. loosen_nut2 → Nut 2 loosened
6. loosen_nut3 → Nut 3 loosened
7. loosen_nut4 → Nut 4 loosened
8. position_jack → Jack positioned

All 8 actions stored = 400 tokens, no summarization possible
```

**Problems**:

- ❌ **No Compression Boundaries**: Can't identify what to summarize together
- ❌ **Lost Semantic Meaning**: Related actions not grouped logically
- ❌ **Poor Summaries**: Generic compression loses critical context
- ❌ **Context Dilution**: Important milestones buried in action noise

### Why This Matters

| Approach | Success Rate | Token Cost | Summary Quality |
|----------|--------------|------------|-----------------|
| No subgoals | 21% | 100% | N/A |
| Poor subgoals | 28% | 60% | Low |
| Good subgoals | **42%** | **25%** | High |

Without subgoal detection:
- Cannot identify **when** to compress (no natural boundaries)
- Cannot identify **what** to group (no semantic context)
- Summaries become generic and lose task-critical information

## Core Concept

### What is a Subgoal?

A **subgoal** is an intermediate milestone that breaks down a complex task into manageable steps. It represents a meaningful unit of work that can be summarized as a single accomplishment.

### Visual Representation

```
Task: Change car tire
│
├── Subgoal 1: Prepare tools ────────────────────────┐
│   ├── open_boot                                    │
│   ├── get_jack                                     │ → Summary: "Tools ready"
│   └── get_wrench                                   │
│                                                    ┘
├── Subgoal 2: Loosen nuts ──────────────────────────┐
│   ├── loosen_nut1                                  │
│   ├── loosen_nut2                                  │ → Summary: "All nuts loosened"
│   ├── loosen_nut3                                  │
│   └── loosen_nut4                                  │
│                                                    ┘
├── Subgoal 3: Jack up car (current) ────────────────┐
│   ├── position_jack                                │
│   └── pump_jack ← Current action                   │
│                                                    ┘
└── Subgoal 4: Replace tire (pending)
```

### Key Characteristics of Good Subgoals

| Property | Description | Example |
|----------|-------------|---------|
| **Specific** | Clear objective | "Loosen all wheel nuts" |
| **Actionable** | 3-7 actions to complete | Not "Fix the car" (too broad) |
| **Measurable** | Success criteria exist | "All 4 nuts loosened" |
| **Semantic** | Meaningful milestone | Natural breakpoint in task |

### Detection Strategies

```
┌─────────────────────────────────────────────────────────────┐
│                    DETECTION APPROACHES                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────────┐   ┌──────────────────┐                │
│  │ LLM Generation   │   │ Pattern Heuristics│               │
│  │ (95% accuracy)   │   │ (60-70% accuracy) │               │
│  │ Medium cost      │   │ Zero cost         │               │
│  └────────┬─────────┘   └────────┬──────────┘               │
│           │                      │                           │
│           └───────────┬──────────┘                          │
│                       ↓                                      │
│           ┌───────────────────────┐                         │
│           │   Hybrid Approach     │                         │
│           │   Heuristics first,   │                         │
│           │   LLM as fallback     │                         │
│           └───────────────────────┘                         │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

## Implementation Patterns

### Pattern 1: LLM-Based Generation (Highest Accuracy)

**Use Case**: Tasks requiring semantic understanding, high accuracy needed

```typescript
import { generateObject } from 'ai';
import { z } from 'zod';

const SubgoalSchema = z.object({
  isNewSubgoal: z.boolean(),
  subgoalName: z.string(),
  confidence: z.number().min(0).max(1),
  reasoning: z.string(),
});

async function detectSubgoalWithLLM(
  taskDescription: string,
  previousSubgoal: string,
  recentActions: Array<{ action: string; observation: string }>
): Promise<z.infer<typeof SubgoalSchema>> {
  const { object } = await generateObject({
    model: openai('gpt-4o-mini'),
    schema: SubgoalSchema,
    prompt: `
Task: ${taskDescription}
Previous subgoal: ${previousSubgoal}

Recent actions:
${recentActions.map(a => `- ${a.action} → ${a.observation}`).join('\n')}

Has the agent transitioned to a NEW subgoal?
Consider: action patterns ending, state changes, logical breakpoints.
    `.trim(),
  });

  return object;
}
```

**Pros**:
- ✅ 95% detection accuracy
- ✅ Works for any task domain
- ✅ Understands semantic context

**Cons**:
- ❌ ~500ms latency per detection
- ❌ $0.001-0.01 per detection
- ❌ Requires LLM availability

**When to Use**: High-stakes tasks, complex domains, accuracy is critical

### Pattern 2: Heuristic-Based Detection (Zero Cost)

**Use Case**: Structured tasks with predictable patterns

```typescript
interface HeuristicResult {
  detected: boolean;
  subgoalName: string;
  confidence: number;
}

class HeuristicDetector {
  detectSubgoal(actions: string[]): HeuristicResult {
    // Pattern 1: Repeated action type completion
    if (this.detectRepeatedCompletion(actions)) {
      const baseAction = actions[actions.length - 1].split('_')[0];
      return {
        detected: true,
        subgoalName: `Completed ${baseAction} operations`,
        confidence: 0.9,
      };
    }

    // Pattern 2: Action category change
    const categoryChange = this.detectCategoryChange(actions);
    if (categoryChange) {
      return {
        detected: true,
        subgoalName: `Starting ${categoryChange.newCategory} phase`,
        confidence: 0.7,
      };
    }

    return { detected: false, subgoalName: '', confidence: 0 };
  }

  private detectRepeatedCompletion(actions: string[]): boolean {
    if (actions.length < 4) return false;

    const last4 = actions.slice(-4).map(a => a.split('_')[0]);
    return last4.every(a => a === last4[0]);
  }

  private detectCategoryChange(actions: string[]): { newCategory: string } | null {
    if (actions.length < 2) return null;

    const categories: Record<string, string[]> = {
      prepare: ['open', 'get', 'retrieve'],
      manipulate: ['loosen', 'tighten', 'remove', 'attach'],
      position: ['move', 'position', 'adjust'],
      verify: ['check', 'test', 'inspect'],
    };

    const getCategory = (action: string): string => {
      const type = action.split('_')[0];
      for (const [cat, keywords] of Object.entries(categories)) {
        if (keywords.some(k => type.includes(k))) return cat;
      }
      return 'other';
    };

    const lastCat = getCategory(actions[actions.length - 1]);
    const prevCat = getCategory(actions[actions.length - 2]);

    return lastCat !== prevCat ? { newCategory: lastCat } : null;
  }
}
```

**Pros**:
- ✅ Zero latency
- ✅ Zero cost
- ✅ Deterministic behavior

**Cons**:
- ❌ 60-70% accuracy
- ❌ Domain-specific rules needed
- ❌ May miss subtle transitions

**When to Use**: Structured tasks, high-volume systems, cost-sensitive

### Pattern 3: Hybrid Approach (Recommended)

**Use Case**: Production systems balancing accuracy and cost

```typescript
class HybridSubgoalDetector {
  private heuristicDetector = new HeuristicDetector();
  private confidenceThreshold = 0.8;

  async detect(
    task: string,
    previousSubgoal: string,
    actions: Array<{ action: string; observation: string }>
  ): Promise<{ isNewSubgoal: boolean; subgoalName: string; method: string }> {
    // Try heuristics first (free)
    const heuristic = this.heuristicDetector.detectSubgoal(
      actions.map(a => a.action)
    );

    if (heuristic.detected && heuristic.confidence >= this.confidenceThreshold) {
      return {
        isNewSubgoal: true,
        subgoalName: heuristic.subgoalName,
        method: 'heuristic',
      };
    }

    // Fall back to LLM (costs money, more accurate)
    const llmResult = await detectSubgoalWithLLM(task, previousSubgoal, actions);

    return {
      isNewSubgoal: llmResult.isNewSubgoal,
      subgoalName: llmResult.subgoalName,
      method: 'llm',
    };
  }
}
```

**Pros**:
- ✅ Best of both approaches
- ✅ Low cost for common patterns
- ✅ High accuracy for edge cases

**Cons**:
- ❌ More complex implementation
- ❌ Variable latency

**When to Use**: Production systems, mixed task complexity

### Pattern 4: State-Based Detection

**Use Case**: Environments with observable state changes

```typescript
interface EnvironmentState {
  [key: string]: unknown;
}

class StateBasedDetector {
  private previousState: EnvironmentState = {};

  detectTransition(currentState: EnvironmentState): {
    isTransition: boolean;
    changedKeys: string[];
  } {
    const changedKeys: string[] = [];

    for (const key of Object.keys(currentState)) {
      if (currentState[key] !== this.previousState[key]) {
        changedKeys.push(key);
      }
    }

    // Significant state change = subgoal transition
    const isTransition = changedKeys.length >= 2;
    this.previousState = { ...currentState };

    return { isTransition, changedKeys };
  }
}
```

**Pros**:
- ✅ Objective (based on facts)
- ✅ Works for stateful environments

**Cons**:
- ❌ Requires state tracking
- ❌ May miss action-only subgoals

**When to Use**: Simulated environments, game agents, robotic tasks

## Framework Integration

### AI SDK v6 with Subgoal Detection

```typescript
import { generateText, tool, stepCountIs } from 'ai';
import { z } from 'zod';

const detector = new HybridSubgoalDetector();
const memory = new HiAgentMemoryManager(task, goal);

const executeAction = tool({
  description: 'Execute an action',
  inputSchema: z.object({
    action: z.string(),
  }),
  execute: async ({ action }) => {
    const observation = await performAction(action);

    // Add to memory
    memory.addAction(action, observation);

    // Check for subgoal transition
    const detection = await detector.detect(
      task,
      memory.getCurrentSubgoal(),
      memory.getRecentActions()
    );

    if (detection.isNewSubgoal) {
      // Compress completed subgoal
      await memory.compressCurrentSubgoal();
      memory.setCurrentSubgoal(detection.subgoalName);
      console.log(`New subgoal: ${detection.subgoalName}`);
    }

    return { action, observation };
  },
});

async function runAgent(prompt: string) {
  const result = await generateText({
    model: openai('gpt-4o'),
    prompt: `${memory.getContext()}\n\n${prompt}`,
    tools: { executeAction },
    stopWhen: stepCountIs(10),
  });

  return result.text;
}
```

### Continuous Monitoring Integration

```typescript
class SubgoalMonitor {
  private detector = new HybridSubgoalDetector();
  private actionBuffer: Array<{ action: string; observation: string }> = [];
  private checkInterval = 3; // Check every 3 actions

  async processAction(
    action: string,
    observation: string,
    task: string,
    currentSubgoal: string
  ): Promise<{ newSubgoal: string | null }> {
    this.actionBuffer.push({ action, observation });

    if (this.actionBuffer.length >= this.checkInterval) {
      const result = await this.detector.detect(
        task,
        currentSubgoal,
        this.actionBuffer
      );

      if (result.isNewSubgoal) {
        this.actionBuffer = []; // Clear buffer
        return { newSubgoal: result.subgoalName };
      }

      // Keep last 2 actions for continuity
      this.actionBuffer = this.actionBuffer.slice(-2);
    }

    return { newSubgoal: null };
  }
}
```

## Research & Benchmarks

### Detection Method Comparison

| Method | Success Rate | Accuracy | Cost | Latency |
|--------|--------------|----------|------|---------|
| **No Subgoals** | 21% | N/A | $0 | 0ms |
| **Heuristic Only** | 28% | 65% | $0 | <1ms |
| **LLM Detection** | 35% | 85% | ~$0.01 | ~500ms |
| **LLM Generation** | 42% | 95% | ~$0.02 | ~700ms |
| **Hybrid** | 40% | 88% | ~$0.005 | ~200ms |

*Results from long-horizon agent benchmarks*

### Hierarchical Planning Research

| System | Approach | Improvement |
|--------|----------|-------------|
| **HiAgent** | Explicit subgoal generation | +100% success |
| **ReAcTree** | Tree-based decomposition | +163% success |
| **SelfGoal** | Automatic decomposition | +40-60% |
| **LgTS** | LLM-generated sub-goals | +30% sample efficiency |

### Optimal Subgoal Size

Research shows 3-7 actions per subgoal is optimal:

| Actions per Subgoal | Compression Ratio | Summary Quality |
|---------------------|-------------------|-----------------|
| 1-2 | 2:1 | Poor (overhead) |
| **3-7** | **10:1** | **Optimal** |
| 8-15 | 15:1 | Acceptable |
| 16+ | 20:1 | Lossy |

## When to Use This Pattern

### ✅ Use When:

1. **Long-horizon tasks** (10+ actions)
   - Multi-step workflows
   - Complex problem-solving

2. **Hierarchical memory needed**
   - HiAgent implementation
   - Subgoal-based compression

3. **Semantic grouping valuable**
   - Related actions should be summarized together
   - Task has natural phases

### ❌ Don't Use When:

1. **Short tasks** (<5 actions)
   - Detection overhead exceeds benefit
   - No compression needed

2. **Homogeneous actions**
   - All actions same type
   - No natural boundaries

3. **Real-time requirements**
   - LLM detection too slow
   - Use heuristics only

### Decision Matrix

| Scenario | Recommended Approach |
|----------|---------------------|
| Structured tasks, predictable | Heuristic only |
| Complex tasks, accuracy critical | LLM generation |
| Production, mixed complexity | Hybrid |
| Stateful environments | State-based + heuristics |

## Production Best Practices

### 1. Tune Detection Frequency

Don't check every action—batch for efficiency:

```typescript
const CHECK_INTERVAL = 3; // Check every 3 actions

if (actionCount % CHECK_INTERVAL === 0) {
  const result = await detectSubgoal();
}
```

### 2. Set Confidence Thresholds

Only accept high-confidence detections:

```typescript
const CONFIDENCE_THRESHOLD = 0.8;

if (detection.isNewSubgoal && detection.confidence >= CONFIDENCE_THRESHOLD) {
  await compressSubgoal();
} else {
  // Continue accumulating actions
}
```

### 3. Handle Detection Failures

Graceful fallback when detection fails:

```typescript
try {
  const result = await detector.detect(task, subgoal, actions);
  return result;
} catch (error) {
  // Fallback to time/count-based compression
  if (actions.length >= MAX_ACTIONS_PER_SUBGOAL) {
    return { isNewSubgoal: true, subgoalName: 'Auto-checkpoint' };
  }
  return { isNewSubgoal: false };
}
```

### 4. Common Pitfalls

#### ❌ Pitfall: Over-detection

**Problem**: Detecting subgoals too frequently fragments memory.

**Solution**: Require minimum action count before detection:
```typescript
if (recentActions.length < 3) {
  return { isNewSubgoal: false }; // Too early to detect
}
```

#### ❌ Pitfall: Generic Subgoal Names

**Problem**: Names like "Continue task" don't help compression.

**Solution**: Require specific, outcome-focused names:
```
BAD:  "Continue working"
GOOD: "Loosen all wheel nuts"
```

## Key Takeaways

1. **LLM generation achieves 95% accuracy** - Best for complex, semantic detection
2. **Heuristics are free but 60-70% accurate** - Good for structured, predictable tasks
3. **Hybrid approach balances cost and accuracy** - Recommended for production
4. **Target 3-7 actions per subgoal** - Optimal for compression quality
5. **Check every 3 actions, not every action** - Reduces overhead

**Quick Implementation Checklist**:

- [ ] Choose detection strategy (LLM, heuristic, hybrid)
- [ ] Define domain-specific patterns for heuristics
- [ ] Set confidence threshold (0.8 recommended)
- [ ] Implement fallback for detection failures
- [ ] Monitor detection frequency and accuracy
- [ ] Tune action count per subgoal (target 3-7)

## References

1. **Hu, M. et al.** (2025). "HiAgent: Hierarchical Working Memory Management for Solving Long-Horizon Agent Tasks". *ACL 2025*. https://aclanthology.org/2025.acl-long.1575.pdf
2. **Choi, J. et al.** (2025). "ReAcTree: Hierarchical Task Planning with Dynamic Tree Structures". *ICLR 2025*. https://openreview.net/forum?id=KgKN7F0PyQ
3. **Li, Z. et al.** (2024). "SelfGoal: Your Language Agents Already Know How to Achieve High-level Goals". *arXiv:2406.04784*. https://arxiv.org/abs/2406.04784
4. **Shukla, Y. et al.** (2024). "LgTS: Dynamic Task Sampling using LLM-generated Sub-goals". *AAMAS 2024*. https://aamas.csc.liv.ac.uk/Proceedings/aamas2024/pdfs/p1736.pdf
5. **Anthropic** (2025). "How we built our multi-agent research system". https://www.anthropic.com/engineering/multi-agent-research-system
6. **HiAgent GitHub Repository** (2024). https://github.com/HiAgent2024/HiAgent

**Related Topics**:

- [4.2.1 HiAgent Hierarchical Memory](./4.2.1-hiagent-hierarchical-memory.md)
- [4.2.2 Compression Triggers](./4.2.2-compression-triggers.md)
- [4.2.4 Summarization Strategies](./4.2.4-summarization-strategies.md)

**Layer Index**: [Layer 4: Memory & State](../AI_KNOWLEDGE_BASE_TOC.md#layer-4-memory--state)
