# 4.4.4 - How to Resume: Load and Continue Execution

## TL;DR

**Resume execution in three phases: load checkpoint from storage, reconstruct agent state, and continue from the current step while skipping completed work.** Key challenges include ensuring idempotency (don't re-execute), validating checkpoint integrity, and handling external state changes since the checkpoint was created.

- **Status**: ✅ Complete
- **Last Updated**: 2025-12-12
- **Prerequisites**: [4.4.1 Why Checkpoint](./4.4.1-why-checkpoint.md), [4.4.2 What to Save](./4.4.2-what-to-save.md), [4.4.3 When to Checkpoint](./4.4.3-when-to-checkpoint.md)
- **Grounded In**: LangGraph persistence (2025), Microsoft Agent Framework, Restate durable execution

## Table of Contents

- [Overview](#overview)
- [The Problem](#the-problem-correct-resumption)
- [Core Concept](#core-concept)
- [Implementation Patterns](#implementation-patterns)
- [Framework Integration](#framework-integration)
- [Research & Benchmarks](#research--benchmarks)
- [When to Use This Pattern](#when-to-use-this-pattern)
- [Production Best Practices](#production-best-practices)
- [Key Takeaways](#key-takeaways)
- [References](#references)

## Overview

Resuming from a checkpoint requires more than just loading data—you must reconstruct the exact execution context and continue without re-executing completed work. The three-phase recovery process (load, reconstruct, continue) handles this systematically.

**Key Challenges**:
- **Idempotency**: Don't re-execute completed steps
- **Partial results**: Handle mid-operation failures
- **Integrity**: Validate checkpoint data isn't corrupted
- **External state**: Handle changes since checkpoint was saved

**Key Research Findings (2024-2025)**:

- **LangGraph**: Automatic state reconstruction with thread_id resumption
- **Restate**: Replay successful steps, only re-execute failed step
- **Production Impact**: <1s resume time with proper implementation

## The Problem: Correct Resumption

### The Classic Challenge

```
Naive Resume:
1. Load checkpoint: {step: 50, completedSteps: [1-49]}
2. Start from step 1 again ← WRONG! Re-executes 49 steps
3. Result: Wasted time, duplicate operations, potential data corruption

Correct Resume:
1. Load checkpoint: {step: 50, completedSteps: [1-49]}
2. Skip steps 1-49, start from step 50
3. Result: Fast recovery, no duplicate work
```

**Problems**:

- ❌ **Re-execution**: Duplicating API calls, database writes
- ❌ **Corruption**: Applying same mutation twice
- ❌ **Cost waste**: Re-running expensive LLM calls
- ❌ **State mismatch**: External resources changed since checkpoint

### Why This Matters

A correct resume implementation saves the full cost of re-execution while maintaining consistency. For a 50-step workflow interrupted at step 40, proper resume saves 40 steps of work (~80% of total execution time).

## Core Concept

### Three-Phase Recovery

```
┌─────────────────────────────────────────────────────────────┐
│                    RESUME PROCESS                            │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  PHASE 1: LOAD CHECKPOINT                                   │
│  ├── Query database for latest checkpoint                   │
│  ├── Deserialize JSON → state objects                       │
│  ├── Validate schema version                                │
│  └── Verify integrity (checksum if available)               │
│                 ↓                                            │
│  PHASE 2: RECONSTRUCT STATE                                 │
│  ├── Restore conversation history                           │
│  ├── Rebuild working memory (entities, facts)               │
│  ├── Identify current step/phase                            │
│  └── Reconnect to external resources                        │
│                 ↓                                            │
│  PHASE 3: CONTINUE EXECUTION                                │
│  ├── Skip completed steps                                   │
│  ├── Resume from current step                               │
│  └── Maintain normal checkpoint cadence                     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Key Data Flow

```
Storage              Memory                 Execution
   │                    │                      │
   │  load()            │                      │
   ├──────────────────→│                      │
   │                    │  reconstruct()       │
   │                    ├─────────────────────→│
   │                    │                      │ skip completed
   │                    │                      │ execute remaining
   │                    │  checkpoint()        │
   │←──────────────────├─────────────────────│
   │                    │                      │
```

### Checkpoint Loading Checklist

| Step | Action | Failure Handling |
|------|--------|-----------------|
| 1 | Query latest checkpoint | Return null, start fresh |
| 2 | Validate schema version | Migrate or reject |
| 3 | Verify checksum | Load previous checkpoint |
| 4 | Deserialize state | Error, load previous |
| 5 | Reconnect resources | Re-fetch if missing |

## Implementation Patterns

### Pattern 1: Basic Load and Resume

**Use Case**: Simple checkpoint resume with validation

```typescript
interface Checkpoint {
  id: string;
  threadId: string;
  timestamp: string;
  version: string;
  state: AgentState;
}

async function loadCheckpoint(threadId: string): Promise<Checkpoint | null> {
  const result = await db.query(
    `SELECT * FROM checkpoints
     WHERE thread_id = $1
     ORDER BY timestamp DESC
     LIMIT 1`,
    [threadId]
  );

  if (result.rows.length === 0) return null;

  const row = result.rows[0];
  const state = deserialize(row.state);

  return {
    id: row.id,
    threadId: row.thread_id,
    timestamp: row.timestamp,
    version: row.version,
    state,
  };
}

function validateCheckpoint(checkpoint: Checkpoint): boolean {
  // Check schema version
  if (checkpoint.version !== CURRENT_VERSION) {
    checkpoint.state = migrateCheckpoint(checkpoint.state, checkpoint.version);
  }

  // Validate required fields
  if (!checkpoint.state.messages || !Array.isArray(checkpoint.state.messages)) {
    throw new Error('Invalid checkpoint: missing messages');
  }

  // Verify integrity
  if (checkpoint.state.checksum) {
    const computed = computeChecksum(checkpoint.state);
    if (computed !== checkpoint.state.checksum) {
      throw new Error('Checkpoint corrupted - checksum mismatch');
    }
  }

  return true;
}

async function resumeExecution(threadId: string, newMessage?: string) {
  // Phase 1: Load
  const checkpoint = await loadCheckpoint(threadId);

  if (!checkpoint) {
    return startNewConversation(threadId, newMessage);
  }

  // Phase 2: Validate and reconstruct
  validateCheckpoint(checkpoint);
  const state = await reconstructState(checkpoint);

  console.log(`Resuming from step ${state.currentStep}`);

  // Add new message if provided
  if (newMessage) {
    state.messages.push({
      role: 'user',
      content: newMessage,
      timestamp: new Date().toISOString(),
    });
  }

  // Phase 3: Continue execution
  return continueWorkflow(state);
}
```

**Pros**:
- ✅ Simple, clear flow
- ✅ Handles missing checkpoints
- ✅ Validates before resuming

**Cons**:
- ❌ No fallback to previous checkpoint
- ❌ Basic error handling

**When to Use**: Simple workflows, development environments

### Pattern 2: State Reconstruction with Resource Reconnection

**Use Case**: Complex state with external dependencies

```typescript
async function reconstructState(checkpoint: Checkpoint): Promise<AgentState> {
  const state: AgentState = {
    // Restore conversation history
    messages: checkpoint.state.messages.map(deserializeMessage),

    // Rebuild working memory
    memory: {
      entities: new Map(Object.entries(checkpoint.state.memory.entities)),
      facts: checkpoint.state.memory.facts,
      references: new Map(Object.entries(checkpoint.state.memory.references)),
    },

    // Restore execution state
    phase: checkpoint.state.execution.phase,
    currentStep: checkpoint.state.execution.currentStep,
    completedSteps: new Set(checkpoint.state.execution.completedSteps),

    // Restore subgoals
    subgoals: checkpoint.state.subgoals,

    // Restore metadata
    userId: checkpoint.state.metadata.userId,
    sessionId: checkpoint.state.metadata.sessionId,
    config: checkpoint.state.metadata.config,
  };

  // Reconnect external resources
  await reconnectResources(state);

  return state;
}

async function reconnectResources(state: AgentState): Promise<void> {
  // Validate external resources still exist
  for (const resource of state.externalResources ?? []) {
    const exists = await checkResourceExists(resource.id);

    if (!exists) {
      console.warn(`Resource ${resource.id} no longer exists - removing`);
      state.externalResources = state.externalResources?.filter(
        r => r.id !== resource.id
      );
    }
  }

  // Reload user context if needed
  if (state.userId) {
    const userContext = await loadUserContext(state.userId);
    state.userContext = userContext;
  }
}
```

**Pros**:
- ✅ Handles complex state structures
- ✅ Validates external resources
- ✅ Graceful handling of missing resources

**Cons**:
- ❌ More complex implementation
- ❌ Additional latency for resource checks

**When to Use**: Production systems with external dependencies

### Pattern 3: Idempotent Continuation

**Use Case**: Ensure completed steps are never re-executed

```typescript
async function continueWorkflow(state: AgentState): Promise<any> {
  const workflow = getWorkflowDefinition();
  const remainingSteps = workflow.steps.slice(state.currentStep);

  for (const step of remainingSteps) {
    // Skip if already completed
    if (state.completedSteps.has(step.id)) {
      console.log(`Skipping completed step: ${step.id}`);
      continue;
    }

    // Execute step idempotently
    const result = await executeStepIdempotent(step, state);

    // Update state
    state.currentStep++;
    state.completedSteps.add(step.id);
    state.stepResults.set(step.id, result);

    // Checkpoint after step
    if (shouldCheckpoint(state)) {
      await checkpointStore.save(state);
    }
  }

  // Mark complete
  state.phase = 'complete';
  await checkpointStore.save(state);

  return { status: 'complete', result: state.result };
}

async function executeStepIdempotent(
  step: WorkflowStep,
  state: AgentState
): Promise<any> {
  // Check for existing result (idempotency key)
  const existingResult = state.stepResults.get(step.id);
  if (existingResult) {
    console.log(`Using cached result for step ${step.id}`);
    return existingResult;
  }

  // Execute step
  return step.execute(state);
}
```

**Pros**:
- ✅ Guarantees no re-execution
- ✅ Caches step results
- ✅ Safe for non-idempotent operations

**Cons**:
- ❌ Requires step result storage
- ❌ More memory usage

**When to Use**: Workflows with non-idempotent or expensive steps

### Pattern 4: Fallback Recovery

**Use Case**: Handle corrupted checkpoints gracefully

```typescript
async function loadWithFallback(threadId: string): Promise<AgentState> {
  try {
    const checkpoint = await loadCheckpoint(threadId);
    if (!checkpoint) return initializeNewState(threadId);

    validateCheckpoint(checkpoint);
    return reconstructState(checkpoint);
  } catch (error) {
    console.error('Checkpoint corrupted:', error);

    // Fallback: Load previous checkpoint
    const previousCheckpoint = await loadPreviousCheckpoint(threadId);

    if (previousCheckpoint) {
      console.log('Falling back to previous checkpoint');
      return reconstructState(previousCheckpoint);
    }

    // Ultimate fallback: Start fresh
    console.warn('No valid checkpoint - starting fresh');
    return initializeNewState(threadId);
  }
}

async function loadPreviousCheckpoint(threadId: string): Promise<Checkpoint | null> {
  const result = await db.query(
    `SELECT * FROM checkpoints
     WHERE thread_id = $1
     ORDER BY timestamp DESC
     OFFSET 1 LIMIT 1`, // Skip the corrupted one
    [threadId]
  );

  if (result.rows.length === 0) return null;
  return deserializeCheckpoint(result.rows[0]);
}
```

**Pros**:
- ✅ Graceful degradation
- ✅ Never fails completely
- ✅ Uses checkpoint history

**Cons**:
- ❌ May lose recent progress
- ❌ Requires checkpoint history storage

**When to Use**: Production systems requiring high availability

## Framework Integration

### AI SDK v6 with Manual Resume

```typescript
import { generateText, tool } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';

class ResumableAgent {
  private checkpointStore: CheckpointStore;

  async run(threadId: string, userMessage: string): Promise<string> {
    // Load or create state
    const state = await this.loadOrCreate(threadId);

    // Add new user message
    state.messages.push({
      role: 'user',
      content: userMessage,
      timestamp: new Date().toISOString(),
    });

    // Execute with AI SDK
    const result = await generateText({
      model: openai('gpt-4o'),
      messages: state.messages,
      tools: {
        completeTask: tool({
          description: 'Mark a task as complete',
          parameters: z.object({ taskId: z.string() }),
          execute: async ({ taskId }) => {
            // Skip if already completed
            if (state.completedSteps.has(taskId)) {
              return { skipped: true, taskId };
            }

            const result = await performTask(taskId);
            state.completedSteps.add(taskId);
            state.currentStep++;

            // Checkpoint after task
            await this.checkpointStore.save(threadId, state);

            return { completed: true, taskId, result };
          },
        }),
      },
      maxSteps: 10,
    });

    // Add assistant response
    state.messages.push({
      role: 'assistant',
      content: result.text,
      timestamp: new Date().toISOString(),
    });

    // Final checkpoint
    await this.checkpointStore.save(threadId, state);

    return result.text;
  }

  private async loadOrCreate(threadId: string): Promise<AgentState> {
    const checkpoint = await this.checkpointStore.load(threadId);

    if (checkpoint) {
      console.log(`Resuming from step ${checkpoint.state.currentStep}`);
      return checkpoint.state;
    }

    console.log('Starting new conversation');
    return this.initializeState(threadId);
  }
}
```

### LangGraph Automatic Resume

```typescript
import { StateGraph } from '@langchain/langgraph';
import { PostgresSaver } from '@langchain/langgraph-checkpoint-postgres';
import { Pool } from 'pg';

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const checkpointer = new PostgresSaver(pool);

const workflow = new StateGraph({
  channels: {
    messages: { value: (x, y) => x.concat(y) },
    currentStep: { value: (x, y) => y },
  },
});

workflow.addNode('research', researchNode);
workflow.addNode('plan', planNode);
workflow.addNode('execute', executeNode);

const app = workflow.compile({ checkpointer });

// First invocation
const config = { configurable: { thread_id: 'thread_123' } };
await app.invoke({ messages: ['Start task'] }, config);

// ... crash/restart ...

// Second invocation - automatically resumes from checkpoint
await app.invoke({ messages: ['Continue'] }, config);
// ✅ LangGraph handles load/reconstruct/continue automatically
```

## Research & Benchmarks

### Resume Time Benchmarks

| Backend | Load Time | Reconstruct Time | Total Resume |
|---------|-----------|------------------|--------------|
| Redis | 1-3ms | 5-10ms | <15ms |
| PostgreSQL | 3-8ms | 5-10ms | <20ms |
| SQLite | 5-10ms | 5-10ms | <25ms |
| S3 | 30-80ms | 5-10ms | <100ms |

### Recovery Scenarios

| Scenario | Without Resume | With Proper Resume | Savings |
|----------|----------------|-------------------|---------|
| 50-step workflow at step 40 | 50 steps | 10 steps | 80% |
| 100-turn conversation | Full re-process | Instant continue | 99%+ |
| Multi-hour batch job at 6hrs | 6 hours | Seconds | ~100% |

## When to Use This Pattern

### ✅ Use Proper Resume When:

1. **Multi-step workflows**
   - Sequential task execution
   - Expensive step operations

2. **Long-running conversations**
   - Sessions spanning hours/days
   - Context preservation required

3. **Non-idempotent operations**
   - Database mutations
   - External API calls

4. **Cost-sensitive applications**
   - Expensive LLM calls
   - Metered API usage

### ❌ Simpler Approaches When:

1. **Stateless queries**
   - Single-turn Q&A
   - No persistence needed

2. **Fast operations**
   - <30 second workflows
   - Cheap to restart

3. **Fully idempotent**
   - Safe to re-execute any step
   - No side effects

## Production Best Practices

### 1. Always Validate Before Resume

```typescript
const checkpoint = await loadCheckpoint(threadId);
if (checkpoint) {
  validateCheckpoint(checkpoint);
  // Only proceed if valid
}
```

### 2. Log Resume Events

```typescript
console.log({
  event: 'checkpoint_resume',
  threadId,
  checkpointId: checkpoint.id,
  ageMs: Date.now() - new Date(checkpoint.timestamp).getTime(),
  step: checkpoint.state.currentStep,
  phase: checkpoint.state.phase,
});
```

### 3. Handle Missing Resources Gracefully

```typescript
if (!await resourceExists(state.resourceId)) {
  console.warn('Resource missing - re-fetching');
  state.resource = await refetchResource(state.resourceId);
}
```

### Common Pitfalls

#### ❌ Pitfall: Not Skipping Completed Steps

**Problem**: Re-executes all steps from beginning

```typescript
// BAD: Re-executes everything
for (const step of workflow) {
  await executeStep(step);
}

// GOOD: Skip completed steps
for (const step of workflow) {
  if (state.completedSteps.has(step.id)) continue;
  await executeStep(step);
}
```

#### ❌ Pitfall: Assuming External State Unchanged

**Problem**: Using stale references to external resources

```typescript
// BAD: Use cached IDs without validation
await deleteFile(state.fileId); // May not exist!

// GOOD: Verify before using
if (await fileExists(state.fileId)) {
  await deleteFile(state.fileId);
}
```

#### ❌ Pitfall: Ignoring Schema Migrations

**Problem**: Old checkpoint format incompatible with new code

```typescript
// BAD: Assume schema is current
const state = JSON.parse(checkpoint.state);

// GOOD: Migrate old schemas
const state = migrateToCurrentVersion(
  JSON.parse(checkpoint.state),
  checkpoint.version
);
```

## Key Takeaways

1. **Three phases**: Load → Reconstruct → Continue
2. **Skip completed steps** - Use completedSteps set for idempotency
3. **Validate before resuming** - Check schema version, checksum
4. **Handle missing resources** - External state may have changed
5. **Log resume events** - Essential for debugging

**Quick Implementation Checklist**:

- [ ] Implement loadCheckpoint with validation
- [ ] Add schema version checking and migration
- [ ] Implement completedSteps tracking for idempotency
- [ ] Add external resource validation on resume
- [ ] Implement fallback to previous checkpoint
- [ ] Log all resume events with metrics
- [ ] Test resume scenarios with various failure points

## References

1. **Microsoft** (2025). "Persisting and Resuming Agent Conversations". https://learn.microsoft.com/en-us/agent-framework/tutorials/agents/persisted-conversations
2. **LangChain** (2024). "LangGraph v0.2: Increased customization with new checkpointer libraries". https://blog.langchain.com/langgraph-v0-2
3. **Koog** (2025). "Agent Persistence Documentation". https://docs.koog.ai/agent-persistence/
4. **Restate** (2025). "Durable AI Loops: Fault Tolerance across Frameworks". https://www.restate.dev/blog/durable-ai-loops-fault-tolerance-across-frameworks-and-without-handcuffs

**Related Topics**:

- [4.4.1 Why Checkpoint](./4.4.1-why-checkpoint.md)
- [4.4.2 What to Save](./4.4.2-what-to-save.md)
- [4.4.3 When to Checkpoint](./4.4.3-when-to-checkpoint.md)
- [4.4.5 Implementation](./4.4.5-implementation.md)

**Layer Index**: [Layer 4: Memory & State](../AI_KNOWLEDGE_BASE_TOC.md#layer-4-memory--state)
