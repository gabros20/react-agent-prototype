# 4.4.3 When to Checkpoint: Every 3 Steps, Phase Transitions, Errors

**Layer**: 4 - Memory & State  
**Sublayer**: 4.4 - State Persistence & Checkpointing  
**Audience**: Intermediate  
**Updated**: 2025-11-18

---

## Table of Contents

- [Overview](#overview)
- [Checkpoint Timing Strategies](#checkpoint-timing-strategies)
- [Frequency Rules](#frequency-rules)
- [Event-Based Triggers](#event-based-triggers)
- [Cost-Benefit Analysis](#cost-benefit-analysis)
- [Implementation Examples](#implementation-examples)
- [Production Patterns](#production-patterns)
- [Best Practices](#best-practices)
- [Common Pitfalls](#common-pitfalls)
- [Related Topics](#related-topics)
- [References](#references)

---

## Overview

**When to checkpoint** balances two competing goals[^1]:
- **Checkpoint too often** → Slow execution (overhead from saving)
- **Checkpoint too rarely** → Lose progress on crash

**The Optimal Balance**: Checkpoint **just enough** to minimize recovery time while keeping overhead acceptable (<5% of total execution time).

**Key Principle**: √N Rule - For N steps, checkpoint every √N steps
- 100 steps → checkpoint every 10 steps
- 400 steps → checkpoint every 20 steps
- 10,000 steps → checkpoint every 100 steps

---

## Checkpoint Timing Strategies

### 1. Fixed Frequency (Every N Steps)

**When**: Regular intervals during execution

**Rule**: Every 3-10 steps for typical workflows[^2]

```typescript
let stepCount = 0;
const CHECKPOINT_FREQUENCY = 5;

async function executeStep(action: Action) {
  await performAction(action);
  stepCount++;

  // Checkpoint every 5 steps
  if (stepCount % CHECKPOINT_FREQUENCY === 0) {
    await checkpoint.save({
      step: stepCount,
      state: currentState,
    });
  }
}
```

**Pros**:
- ✅ Simple to implement
- ✅ Predictable overhead
- ✅ Works well for uniform workflows

**Cons**:
- ❌ May checkpoint at inefficient times (mid-operation)
- ❌ Doesn't adapt to workflow complexity

**Best For**: Simple, linear workflows with uniform step costs

---

### 2. Phase Transitions (After Major Milestones)

**When**: After completing a major phase or milestone

**Rule**: Checkpoint after each phase completion

```typescript
const workflow = [
  { phase: "research", steps: ["search", "analyze", "summarize"] },
  { phase: "plan", steps: ["outline", "decompose", "schedule"] },
  { phase: "execute", steps: ["implement", "test", "review"] },
];

for (const { phase, steps } of workflow) {
  console.log(`Starting phase: ${phase}`);

  for (const step of steps) {
    await executeStep(step);
  }

  // Checkpoint after each phase completes
  await checkpoint.save({
    phase: phase,
    status: "completed",
    completedPhases: [...completedPhases, phase],
  });
  console.log(`✅ Checkpoint saved after ${phase} phase`);
}
```

**Pros**:
- ✅ Checkpoints at logical boundaries
- ✅ Easy to resume (from phase start)
- ✅ Lower frequency = lower overhead

**Cons**:
- ❌ May lose progress if phase is long
- ❌ Not suitable for workflows without clear phases

**Best For**: Multi-phase workflows with clear boundaries

---

### 3. Before Expensive Operations

**When**: Before any expensive or risky operation

**Rule**: Checkpoint before API calls, LLM invocations, external service calls

```typescript
async function performExpensiveAnalysis(document: string) {
  // Checkpoint BEFORE expensive operation
  await checkpoint.save({
    step: "pre_analysis",
    document_id: documentId,
    timestamp: new Date().toISOString(),
  });

  try {
    // Expensive LLM call ($5 API cost)
    const analysis = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [{ role: "user", content: `Analyze: ${document}` }],
      max_tokens: 4000,
    });

    // Checkpoint AFTER successful completion
    await checkpoint.save({
      step: "post_analysis",
      document_id: documentId,
      analysis: analysis.choices[0].message.content,
      timestamp: new Date().toISOString(),
    });

    return analysis;
  } catch (error) {
    // On error, we can retry from pre_analysis checkpoint
    // without redoing previous work
    throw error;
  }
}
```

**Pros**:
- ✅ Protects expensive operations
- ✅ Enables precise retry logic
- ✅ Minimizes wasted costs

**Cons**:
- ❌ Higher checkpoint frequency
- ❌ Requires identifying "expensive" operations

**Best For**: Workflows with expensive external calls

---

### 4. After Errors (Recovery Points)

**When**: After encountering and recovering from errors

**Rule**: Checkpoint after successful error recovery

```typescript
async function executeWithRetry(action: Action, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const result = await performAction(action);

      // Checkpoint after successful execution (especially after errors)
      if (attempt > 1) {
        await checkpoint.save({
          step: action.name,
          status: "recovered",
          attempt: attempt,
          result: result,
        });
        console.log(`✅ Recovered from error after ${attempt} attempts`);
      }

      return result;
    } catch (error) {
      if (attempt === maxRetries) {
        // Final failure - checkpoint before giving up
        await checkpoint.save({
          step: action.name,
          status: "failed",
          attempts: maxRetries,
          error: error.message,
        });
        throw error;
      }

      // Wait before retry
      await new Promise((resolve) => setTimeout(resolve, 1000 * attempt));
    }
  }
}
```

**Pros**:
- ✅ Captures error recovery state
- ✅ Helps debug failure patterns
- ✅ Prevents re-encountering same errors

**Cons**:
- ❌ Unpredictable frequency
- ❌ Only useful if errors are recoverable

**Best For**: Unreliable external services, flaky APIs

---

### 5. Before Human-in-the-Loop (HITL)

**When**: Before requesting user approval/input

**Rule**: Always checkpoint before pausing for human input[^3]

```typescript
async function performDestructiveAction(files: string[]) {
  // Checkpoint before HITL pause
  await checkpoint.save({
    step: "pending_approval",
    action: "delete_files",
    files: files,
    timestamp: new Date().toISOString(),
  });

  // Wait for user approval (could be hours/days)
  const approved = await waitForUserApproval({
    message: `Approve deletion of ${files.length} files?`,
    files: files,
  });

  if (approved) {
    // Checkpoint after approval received
    await checkpoint.save({
      step: "approved",
      action: "delete_files",
      files: files,
    });

    await deleteFiles(files);

    // Checkpoint after action complete
    await checkpoint.save({
      step: "completed",
      action: "delete_files",
      deleted_count: files.length,
    });
  } else {
    // Checkpoint cancellation
    await checkpoint.save({
      step: "cancelled",
      action: "delete_files",
      reason: "User rejected",
    });
  }
}
```

**Pros**:
- ✅ Essential for long pauses
- ✅ Enables session resumption
- ✅ Audit trail for approvals

**Cons**:
- ❌ Requires user action tracking
- ❌ Must handle timeout/abandonment

**Best For**: Workflows requiring user approval, multi-day tasks

---

### 6. Time-Based (Every N Minutes)

**When**: After a certain time has elapsed

**Rule**: Every 1-3 minutes for long-running tasks

```typescript
let lastCheckpointTime = Date.now();
const CHECKPOINT_INTERVAL_MS = 2 * 60 * 1000; // 2 minutes

async function executeStep(action: Action) {
  await performAction(action);

  const now = Date.now();
  const elapsed = now - lastCheckpointTime;

  // Checkpoint every 2 minutes
  if (elapsed >= CHECKPOINT_INTERVAL_MS) {
    await checkpoint.save({
      step: currentStep,
      state: currentState,
      elapsed_since_last: elapsed,
    });
    lastCheckpointTime = now;
    console.log(`✅ Time-based checkpoint (${elapsed}ms since last)`);
  }
}
```

**Pros**:
- ✅ Protects long-running operations
- ✅ Independent of step count
- ✅ Catches stuck/slow operations

**Cons**:
- ❌ May interrupt mid-operation
- ❌ Overhead from timer checks

**Best For**: Long-running batch jobs, multi-hour workflows

---

## Frequency Rules

### General Guidelines

| Workflow Type          | Checkpoint Frequency | Example                          |
|------------------------|----------------------|----------------------------------|
| **Fast (<5 min)**      | Every 5-10 steps     | Simple Q&A, single document      |
| **Medium (5-30 min)**  | Every 3-5 steps      | Multi-step research, data analysis |
| **Long (30+ min)**     | Every 1-3 steps      | Batch processing, training jobs  |
| **Very Long (hours)**  | Every 1-3 minutes    | Large-scale data migration       |

### √N Rule (Mathematical Optimal)

**Formula**: For N total steps, checkpoint every √N steps

**Reasoning**:
- Expected position of crash: N/2 (midpoint)
- Work lost per crash: √N / 2
- Checkpoint overhead: √N checkpoints
- Total cost: √N (recovery) + √N (checkpoints) = 2√N

**Examples**:
```typescript
const totalSteps = 100;
const checkpointFrequency = Math.sqrt(totalSteps); // 10
// Checkpoint every 10 steps

const totalSteps = 10000;
const checkpointFrequency = Math.sqrt(totalSteps); // 100
// Checkpoint every 100 steps
```

### Adaptive Frequency

**Adjust based on failure rate**:

```typescript
let checkpointFrequency = 5; // Start with every 5 steps
let consecutiveSuccesses = 0;
let consecutiveFailures = 0;

async function executeStep(action: Action) {
  try {
    await performAction(action);
    consecutiveSuccesses++;
    consecutiveFailures = 0;

    // If stable, reduce checkpoint frequency (less overhead)
    if (consecutiveSuccesses >= 50) {
      checkpointFrequency = Math.min(checkpointFrequency + 1, 10);
      console.log(`Increasing checkpoint interval to ${checkpointFrequency}`);
      consecutiveSuccesses = 0;
    }
  } catch (error) {
    consecutiveFailures++;
    consecutiveSuccesses = 0;

    // If unstable, increase checkpoint frequency (more protection)
    if (consecutiveFailures >= 3) {
      checkpointFrequency = Math.max(checkpointFrequency - 1, 1);
      console.log(`Decreasing checkpoint interval to ${checkpointFrequency}`);
      consecutiveFailures = 0;
    }

    throw error;
  }

  // Checkpoint at current frequency
  if (stepCount % checkpointFrequency === 0) {
    await checkpoint.save(currentState);
  }
}
```

---

## Event-Based Triggers

### Trigger Checklist

Checkpoint when:

1. **✅ Phase completes** (research → planning → execution)
2. **✅ Before expensive operations** (LLM calls, API requests)
3. **✅ After expensive operations succeed**
4. **✅ Before destructive actions** (delete, update, modify)
5. **✅ After successful error recovery**
6. **✅ Before HITL pauses** (user approval, input)
7. **✅ After receiving HITL input**
8. **✅ Every N steps** (backup strategy)
9. **✅ Every N minutes** (long-running tasks)
10. **✅ On explicit save request** (user-triggered)

### LangGraph Example

```typescript
import { StateGraph } from "@langchain/langgraph";

const workflow = new StateGraph({
  channels: {
    messages: { value: (x, y) => x.concat(y) },
    phase: { value: (x, y) => y },
  },
});

// Automatically checkpoints after each node execution
workflow.addNode("research", researchNode); // → checkpoint
workflow.addNode("plan", planNode);       // → checkpoint
workflow.addNode("execute", executeNode); // → checkpoint

// Compile with PostgreSQL checkpointer
const app = workflow.compile({
  checkpointer: new PostgresSaver(pool),
});

// Run with thread ID - automatically checkpoints after each node
await app.invoke(
  { messages: ["Start task"] },
  { configurable: { thread_id: "thread_123" } }
);

// LangGraph handles checkpoint timing automatically!
```

**LangGraph Default**: Checkpoints after **every node execution**[^4]

---

## Cost-Benefit Analysis

### Overhead Calculation

```typescript
// Scenario: 100-step workflow
const TOTAL_STEPS = 100;
const STEP_DURATION_MS = 1000; // 1 second per step
const CHECKPOINT_DURATION_MS = 50; // 50ms to save checkpoint

// Option 1: Checkpoint every step (very frequent)
const checkpoints1 = TOTAL_STEPS;
const overhead1 = checkpoints1 * CHECKPOINT_DURATION_MS; // 5,000ms = 5s
const totalTime1 = TOTAL_STEPS * STEP_DURATION_MS + overhead1; // 105s
const overheadPercent1 = (overhead1 / totalTime1) * 100; // 4.8%

// Option 2: Checkpoint every 10 steps (√N rule)
const checkpoints2 = TOTAL_STEPS / 10;
const overhead2 = checkpoints2 * CHECKPOINT_DURATION_MS; // 500ms = 0.5s
const totalTime2 = TOTAL_STEPS * STEP_DURATION_MS + overhead2; // 100.5s
const overheadPercent2 = (overhead2 / totalTime2) * 100; // 0.5%

// Option 3: Checkpoint every 50 steps (infrequent)
const checkpoints3 = TOTAL_STEPS / 50;
const overhead3 = checkpoints3 * CHECKPOINT_DURATION_MS; // 100ms = 0.1s
const totalTime3 = TOTAL_STEPS * STEP_DURATION_MS + overhead3; // 100.1s
const overheadPercent3 = (overhead3 / totalTime3) * 100; // 0.1%

console.log(`Option 1 (every step): ${overheadPercent1.toFixed(1)}% overhead`);
console.log(`Option 2 (every 10): ${overheadPercent2.toFixed(1)}% overhead`);
console.log(`Option 3 (every 50): ${overheadPercent3.toFixed(1)}% overhead`);

// If failure occurs at step 50:
// Option 1: Lose 0 steps (checkpoint at 50)
// Option 2: Lose 0-10 steps (checkpoint at 50)
// Option 3: Lose 0-50 steps (no checkpoint yet!)
```

**Recommendation**: Keep overhead <5% (Option 2: every 10 steps)

---

### Recovery Time vs Overhead Trade-off

| Checkpoint Frequency | Overhead | Max Steps Lost | Recovery Time (100-step workflow) |
|----------------------|----------|----------------|-----------------------------------|
| **Every step**       | 5%       | 0              | 0s                                |
| **Every 5 steps**    | 1%       | 4              | 4s                                |
| **Every 10 steps**   | 0.5%     | 9              | 9s                                |
| **Every 20 steps**   | 0.25%    | 19             | 19s                               |
| **Every 50 steps**   | 0.1%     | 49             | 49s                               |

**Sweet Spot**: Every 5-10 steps (0.5-1% overhead, <10s recovery)

---

## Implementation Examples

### Complete Checkpoint Timing System

```typescript
interface CheckpointTiming {
  strategy: "fixed" | "phase" | "adaptive" | "time" | "hybrid";
  frequency?: number;
  intervalMs?: number;
  triggers: string[];
}

class CheckpointScheduler {
  private stepCount = 0;
  private lastCheckpointTime = Date.now();
  private config: CheckpointTiming;

  constructor(config: CheckpointTiming) {
    this.config = config;
  }

  shouldCheckpoint(context: {
    phase?: string;
    phaseComplete?: boolean;
    beforeExpensive?: boolean;
    afterError?: boolean;
    beforeHITL?: boolean;
  }): boolean {
    // Event-based triggers (always checkpoint)
    if (context.phaseComplete && this.config.triggers.includes("phase")) {
      return true;
    }
    if (context.beforeExpensive && this.config.triggers.includes("expensive")) {
      return true;
    }
    if (context.afterError && this.config.triggers.includes("error")) {
      return true;
    }
    if (context.beforeHITL && this.config.triggers.includes("hitl")) {
      return true;
    }

    // Step-based checkpoint
    if (this.config.strategy === "fixed" && this.config.frequency) {
      return this.stepCount % this.config.frequency === 0;
    }

    // Time-based checkpoint
    if (this.config.strategy === "time" && this.config.intervalMs) {
      const elapsed = Date.now() - this.lastCheckpointTime;
      return elapsed >= this.config.intervalMs;
    }

    return false;
  }

  markCheckpoint() {
    this.lastCheckpointTime = Date.now();
  }

  incrementStep() {
    this.stepCount++;
  }
}

// Usage
const scheduler = new CheckpointScheduler({
  strategy: "hybrid",
  frequency: 5, // Every 5 steps
  intervalMs: 2 * 60 * 1000, // Every 2 minutes
  triggers: ["phase", "expensive", "hitl"],
});

async function executeWorkflow(steps: Action[]) {
  for (const step of steps) {
    // Check if checkpoint needed BEFORE execution
    if (scheduler.shouldCheckpoint({ beforeExpensive: step.isExpensive })) {
      await checkpoint.save({ step: scheduler.stepCount });
      scheduler.markCheckpoint();
    }

    // Execute step
    await executeStep(step);
    scheduler.incrementStep();

    // Check if checkpoint needed AFTER execution
    if (scheduler.shouldCheckpoint({ phaseComplete: step.endsPhase })) {
      await checkpoint.save({ step: scheduler.stepCount });
      scheduler.markCheckpoint();
    }
  }
}
```

---

## Production Patterns

### Your Codebase Example

```typescript
// File: server/agent/orchestrator.ts

async function prepareStep(
  config: AgentConfig,
  state: AgentState
): Promise<PrepareStepResult> {
  // Your code already implements smart checkpointing:

  // 1. Checkpoint every 3 steps (fixed frequency)
  if (state.stepCount % 3 === 0) {
    await saveCheckpoint(state);
  }

  // 2. Checkpoint before phase transitions
  if (state.phase === "planning" && nextPhase === "execution") {
    await saveCheckpoint({ ...state, phase: "execution" });
  }

  // 3. Checkpoint on errors
  try {
    return await executeStep(config, state);
  } catch (error) {
    await saveCheckpoint({ ...state, error: error.message });
    throw error;
  }
}
```

**Your Pattern**: Every 3 steps + phase transitions + errors ✅

---

## Best Practices

### 1. Checkpoint Before Expensive Operations

```typescript
// ✅ Always checkpoint before expensive ops
await checkpoint.save({ step: "pre_llm_call" });
const result = await expensiveLLMCall();
await checkpoint.save({ step: "post_llm_call", result });
```

### 2. Use Explicit Phase Boundaries

```typescript
// ✅ Clear phase transitions
for (const phase of ["research", "plan", "execute"]) {
  await executePhase(phase);
  await checkpoint.save({ phase, status: "complete" });
}
```

### 3. Measure and Adjust Frequency

```typescript
// ✅ Monitor checkpoint performance
const start = performance.now();
await checkpoint.save(state);
const duration = performance.now() - start;

if (duration > 100) {
  console.warn(`Checkpoint slow: ${duration}ms - consider reducing frequency`);
}
```

---

## Common Pitfalls

### 1. ❌ Checkpointing Too Frequently

```typescript
// ❌ Bad: Checkpoint after EVERY operation (5% overhead)
for (const item of items) {
  await process(item);
  await checkpoint.save(state); // Overkill!
}

// ✅ Good: Checkpoint every 10 items (0.5% overhead)
for (let i = 0; i < items.length; i++) {
  await process(items[i]);
  if (i % 10 === 0) {
    await checkpoint.save(state);
  }
}
```

### 2. ❌ Not Checkpointing Before Long Operations

```typescript
// ❌ Bad: No checkpoint before 10-minute process
await longRunningProcess(); // 10 minutes
// If crash → lose 10 minutes of work

// ✅ Good: Checkpoint before long operation
await checkpoint.save({ step: "pre_long_process" });
await longRunningProcess();
await checkpoint.save({ step: "post_long_process" });
```

### 3. ❌ Ignoring Checkpoint Failures

```typescript
// ❌ Bad: Silent failure
await checkpoint.save(state); // What if this fails?
await criticalOperation();

// ✅ Good: Handle checkpoint failures
try {
  await checkpoint.save(state);
} catch (error) {
  console.error("Checkpoint failed! Aborting workflow", error);
  throw error; // Don't continue without checkpoint
}
```

---

## Related Topics

- **[4.4.1 Why Checkpoint](./4.4.1-why-checkpoint.md)** - Benefits of checkpointing
- **[4.4.2 What to Save](./4.4.2-what-to-save.md)** - State components to include
- **[4.4.4 How to Resume](./4.4.4-how-to-resume.md)** - Loading and resuming from checkpoints
- **[4.4.5 Implementation Patterns](./4.4.5-implementation.md)** - Database storage strategies
- **[7.2 Recovery Strategies](../../7-errors/7.2.1-retry.md)** - Error recovery with checkpoints

---

## References

[^1]: "Mastering LangGraph Checkpointing: Best Practices for 2025" - Sparkco AI (2025): https://sparkco.ai/blog/mastering-langgraph-checkpointing-best-practices-for-2025
[^2]: "Building Agents with LangGraph Course #5: Persistence & Streaming" - Youssef Hosni (2025): https://youssefh.substack.com/p/building-agents-with-langgraph-course-bd2
[^3]: "Agent Persistence - Koog" - Koog Documentation (2025): https://docs.koog.ai/agent-persistence/
[^4]: "LangGraph v0.2: Increased customization with new checkpointer libraries" - LangChain (2024): https://blog.langchain.com/langgraph-v0-2

---

**Next**: [4.4.4 How to Resume](./4.4.4-how-to-resume.md) - Learn how to load checkpoints and continue execution seamlessly.

**Previous**: [4.4.2 What to Save](./4.4.2-what-to-save.md) - Understanding which state to include in checkpoints.
