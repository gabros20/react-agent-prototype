# 4.1.4 Reference Resolution ("this page", "that entry")

**Status**: ✅ Complete  
**Last Updated**: 2025-11-18  
**Grounded In**: Coreference resolution research (2024-2025), LLM-based resolution, Stanford NLP, production systems

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [The Problem: Ambiguous References](#the-problem-ambiguous-references)
3. [What is Reference Resolution?](#what-is-reference-resolution)
4. [Types of References](#types-of-references)
5. [Resolution Strategies](#resolution-strategies)
6. [Implementation in JavaScript/TypeScript](#implementation-in-javascripttypescript)
7. [LLM-Based Resolution](#llm-based-resolution)
8. [Production Patterns](#production-patterns)
9. [Trade-offs and Best Practices](#trade-offs-and-best-practices)
10. [References](#references)

---

## Executive Summary

**Reference resolution** (also called **coreference resolution** or **anaphora resolution**) is the task of determining what entity a pronoun or demonstrative refers to in context. In AI agents, this enables understanding phrases like "this page," "that entry," or "update it" by linking them to previously mentioned entities in working memory.

### Key Metrics (Research Benchmarks, 2024-2025)
- **LLM-based systems**: 83.3 F1-score on CoNLL-2012 (English)
- **Traditional supervised**: 87.1 F1-score (state-of-the-art)
- **LQCA framework**: +3.61% improvement on GPT-4
- **Simple heuristics**: 70-80% accuracy in domain-specific tasks

### Why It Matters
- **Natural Conversation**: Users say "update this" instead of "update page 42"
- **Context Awareness**: Agents understand implicit references
- **Reduced Token Usage**: No need to repeat entity IDs explicitly
- **Better UX**: More human-like interaction patterns

---

## The Problem: Ambiguous References

### Scenario: User Uses Pronouns

```typescript
// Turn 1
User: "Show me page 42"
Agent: [Calls cms_getPage(42)]
// Working memory: [{ type: 'page', id: 42, label: 'Home' }]

// Turn 2
User: "Update this page's title to 'Welcome'"
//             ^^^^ What does "this page" refer to?

// Without reference resolution:
Agent: "ERROR: pageId parameter is required"

// With reference resolution:
Agent: [Resolves "this page" → pageId: 42 from working memory]
      [Calls cms_updatePage(42, { title: 'Welcome' })]
      "Updated page 42 title to 'Welcome'"
```

### Common Ambiguous References

| User Says | Refers To | Challenge |
|-----------|-----------|-----------|
| "this page" | Most recent page | Which page? |
| "that entry" | Previously mentioned entry | How far back? |
| "update it" | Last entity operated on | What type? |
| "the first one" | First item in list | Which list? |
| "those pages" | Multiple pages (plural) | Which subset? |

**Problem**: Without resolution, agents can't understand these natural references.

---

## What is Reference Resolution?

### Definition

**Reference resolution** is the process of linking **referring expressions** (pronouns, demonstratives) to their **antecedents** (the entities they refer to). This involves:

1. **Detecting** referring expressions ("this", "that", "it")
2. **Finding** candidate antecedents (entities in working memory)
3. **Selecting** the most likely referent based on context

### Linguistic Terminology

```
Sentence: "Alice submitted her application. She was hopeful."
           -----             ---              ---
           antecedent      anaphor 1       anaphor 2

"Alice" is the ANTECEDENT (the entity being referred to)
"her" and "She" are ANAPHORS (referring expressions)

Coreference chain: [Alice, her, She] → all refer to same entity
```

### In AI Agent Context

```typescript
// Turn 1: Introduce entity
User: "Show me page 42"
// Working memory: [{ type: 'page', id: 42, label: 'Home' }]
// Antecedent: page 42

// Turn 2: Refer using pronoun
User: "Update this page"
//             ^^^^ anaphor (referring expression)
// Resolution: "this page" → { type: 'page', id: 42 }
```

---

## Types of References

### 1. Demonstrative Pronouns

**This, that, these, those** + noun phrase

```typescript
// Singular
"this page"     // Refers to most recent page
"that entry"    // Refers to previously mentioned entry

// Plural
"these pages"   // Refers to recent page collection
"those entries" // Refers to previously mentioned entries

// Distance-based
"this" → near/recent (recency bias)
"that" → far/older (less recent)
```

### 2. Personal Pronouns

**It, they, them** (third-person)

```typescript
// Singular
User: "Show page 42"
User: "Update it"  // "it" → page 42

// Plural
User: "List pages 42, 57, 99"
User: "Delete them"  // "them" → [42, 57, 99]
```

### 3. Ordinal References

**First, second, last, next** one/ones

```typescript
User: "List all pages"
Agent: "Found 5 pages: Home, About, Contact, Blog, FAQ"
User: "Show me the first one"  // "first one" → Home (page 42)
User: "And the last one"        // "last one" → FAQ (page 99)
```

### 4. Definite Descriptions

**The X** (where X is a known entity)

```typescript
User: "Show page 42"
User: "Update the page"  // "the page" → page 42 (definite reference)
```

### 5. Zero Anaphora (Implicit Reference)

**No explicit pronoun**, implied from context

```typescript
User: "Show page 42"
User: "Update title to 'Welcome'"  // Implicit: page 42
// In languages like Chinese/Japanese, subject often omitted
```

---

## Resolution Strategies

### 1. Recency Heuristic (Simplest)

**Always resolve to most recent entity** of matching type.

```typescript
function resolveReference(
  reference: string,
  workingMemory: Entity[]
): Entity | null {
  // Extract entity type from reference
  const type = extractType(reference);  // "this page" → "page"
  
  // Find most recent entity of that type
  const entities = workingMemory
    .filter(e => e.type === type)
    .sort((a, b) => b.timestamp - a.timestamp);
  
  return entities[0] || null;  // Most recent
}

// Examples
resolveReference("this page", memory);   // → Most recent page
resolveReference("that entry", memory);  // → Most recent entry
resolveReference("update it", memory);   // → Most recent entity (any type)
```

**Pros**: Fast, simple, works well for short conversations  
**Cons**: Ignores context, may pick wrong entity in complex dialogs

### 2. Type-Based Resolution

**Match entity type** from reference phrase.

```typescript
function resolveByType(
  reference: string,
  workingMemory: Entity[]
): Entity | null {
  const typeMap: Record<string, string> = {
    'this page': 'page',
    'that page': 'page',
    'this entry': 'entry',
    'that entry': 'entry',
    'the user': 'user'
  };

  const type = typeMap[reference.toLowerCase()];
  if (!type) {
    return null;
  }

  // Get most recent entity of that type
  const entities = workingMemory.filter(e => e.type === type);
  return entities[entities.length - 1] || null;
}
```

**Pros**: Type-safe, prevents wrong entity types  
**Cons**: Requires predefined type mappings

### 3. Distance-Based Resolution

**Use "this" vs "that"** to determine recency.

```typescript
function resolveByDistance(
  reference: string,
  workingMemory: Entity[]
): Entity | null {
  const isNear = reference.startsWith('this');  // "this" = recent
  const isFar = reference.startsWith('that');   // "that" = older

  const type = extractType(reference);
  const entities = workingMemory
    .filter(e => e.type === type)
    .sort((a, b) => b.timestamp - a.timestamp);

  if (isNear) {
    return entities[0];  // Most recent
  } else if (isFar && entities.length >= 2) {
    return entities[1];  // Second most recent
  }

  return entities[0] || null;
}

// Examples
"this page"  → entities[0]  // Most recent page
"that page"  → entities[1]  // Second most recent page
```

**Pros**: Handles "this" vs "that" distinction  
**Cons**: Still heuristic-based, limited by working memory size

### 4. Agreement Constraints

**Check number and gender agreement**.

```typescript
interface Entity {
  type: string;
  id: number;
  label: string;
  attributes?: {
    number?: 'singular' | 'plural';
    gender?: 'male' | 'female' | 'neutral';
  };
}

function resolveWithAgreement(
  pronoun: string,
  workingMemory: Entity[]
): Entity | null {
  // Define pronoun constraints
  const constraints: Record<string, { number?: string; gender?: string }> = {
    'it': { number: 'singular' },
    'they': { number: 'plural' },
    'he': { number: 'singular', gender: 'male' },
    'she': { number: 'singular', gender: 'female' }
  };

  const constraint = constraints[pronoun.toLowerCase()];
  if (!constraint) {
    return null;
  }

  // Filter entities matching constraints
  const candidates = workingMemory.filter(e => {
    if (constraint.number && e.attributes?.number !== constraint.number) {
      return false;
    }
    if (constraint.gender && e.attributes?.gender !== constraint.gender) {
      return false;
    }
    return true;
  });

  // Return most recent matching entity
  return candidates[candidates.length - 1] || null;
}
```

**Pros**: More accurate than pure recency  
**Cons**: Requires entity metadata (number, gender)

### 5. LLM-Based Resolution (Most Powerful)

**Use LLM to resolve** based on full context.

```typescript
import { openai } from '@ai-sdk/openai';
import { generateObject } from 'ai';
import { z } from 'zod';

async function resolveWithLLM(
  reference: string,
  conversation: Message[],
  workingMemory: Entity[]
): Promise<Entity | null> {
  const prompt = `
Given this conversation:
${conversation.map(m => `${m.role}: ${m.content}`).join('\n')}

Working memory (available entities):
${workingMemory.map(e => `- ${e.type} ${e.id}: ${e.label}`).join('\n')}

What does "${reference}" refer to?

Return the entity type and ID.
  `.trim();

  const { object } = await generateObject({
    model: openai('gpt-4o-mini'),
    schema: z.object({
      type: z.string(),
      id: z.number(),
      confidence: z.number().min(0).max(1)
    }),
    prompt
  });

  // Find entity in working memory
  return workingMemory.find(e => 
    e.type === object.type && e.id === object.id
  ) || null;
}
```

**Pros**: Handles complex context, high accuracy  
**Cons**: Slow (50-200ms), costs tokens, may hallucinate

---

## Implementation in JavaScript/TypeScript

### Basic Reference Resolver

```typescript
// reference-resolver.ts
export interface Entity {
  type: string;
  id: number | string;
  label: string;
  timestamp: number;
}

export interface ResolverOptions {
  strategy?: 'recency' | 'type' | 'distance' | 'llm';
  fallbackToRecent?: boolean;
}

export class ReferenceResolver {
  private workingMemory: Entity[];
  private options: ResolverOptions;

  constructor(workingMemory: Entity[], options: ResolverOptions = {}) {
    this.workingMemory = workingMemory;
    this.options = {
      strategy: 'recency',
      fallbackToRecent: true,
      ...options
    };
  }

  // Main resolution method
  resolve(reference: string): Entity | null {
    switch (this.options.strategy) {
      case 'recency':
        return this.resolveByRecency(reference);
      case 'type':
        return this.resolveByType(reference);
      case 'distance':
        return this.resolveByDistance(reference);
      default:
        return this.resolveByRecency(reference);
    }
  }

  // Recency strategy: most recent entity
  private resolveByRecency(reference: string): Entity | null {
    const type = this.extractType(reference);
    
    const candidates = this.workingMemory
      .filter(e => !type || e.type === type)
      .sort((a, b) => b.timestamp - a.timestamp);

    return candidates[0] || null;
  }

  // Type-based strategy
  private resolveByType(reference: string): Entity | null {
    const type = this.extractType(reference);
    if (!type) {
      return this.options.fallbackToRecent 
        ? this.resolveByRecency(reference)
        : null;
    }

    const candidates = this.workingMemory
      .filter(e => e.type === type)
      .sort((a, b) => b.timestamp - a.timestamp);

    return candidates[0] || null;
  }

  // Distance strategy: "this" vs "that"
  private resolveByDistance(reference: string): Entity | null {
    const ref = reference.toLowerCase();
    const isNear = ref.includes('this');
    const isFar = ref.includes('that');
    
    const type = this.extractType(reference);
    const candidates = this.workingMemory
      .filter(e => !type || e.type === type)
      .sort((a, b) => b.timestamp - a.timestamp);

    if (isNear) {
      return candidates[0] || null;  // Most recent
    } else if (isFar && candidates.length >= 2) {
      return candidates[1] || null;  // Second most recent
    }

    return candidates[0] || null;
  }

  // Extract entity type from reference phrase
  private extractType(reference: string): string | null {
    const ref = reference.toLowerCase().trim();
    
    // Common patterns
    const patterns: Record<string, string> = {
      'page': 'page',
      'entry': 'entry',
      'user': 'user',
      'task': 'task',
      'project': 'project'
    };

    for (const [keyword, type] of Object.entries(patterns)) {
      if (ref.includes(keyword)) {
        return type;
      }
    }

    return null;
  }

  // Get all entities of a type
  getByType(type: string): Entity[] {
    return this.workingMemory.filter(e => e.type === type);
  }

  // Get N most recent entities
  getRecent(n: number = 5): Entity[] {
    return [...this.workingMemory]
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, n);
  }
}
```

### Usage in Agent Tools

```typescript
import { ReferenceResolver } from './reference-resolver';
import { tool } from 'ai';
import { z } from 'zod';

// Tool that accepts references
const cms_updatePage = tool({
  description: 'Update page by ID or reference (e.g., "this page")',
  parameters: z.object({
    pageRef: z.string().describe('Page ID number or reference like "this page"'),
    updates: z.object({
      title: z.string().optional(),
      status: z.string().optional()
    })
  }),
  execute: async ({ pageRef, updates }, context) => {
    let pageId: number;

    // Check if pageRef is a number or reference
    if (/^\d+$/.test(pageRef)) {
      // Direct page ID
      pageId = parseInt(pageRef, 10);
    } else {
      // Reference like "this page"
      const resolver = new ReferenceResolver(
        context.workingMemory.getAll()
      );
      const entity = resolver.resolve(pageRef);
      
      if (!entity || entity.type !== 'page') {
        return `Could not resolve "${pageRef}" to a page`;
      }
      
      pageId = entity.id as number;
    }

    // Update page
    const page = await db.pages.update({
      where: { id: pageId },
      data: updates
    });

    return `Updated page ${pageId}: ${JSON.stringify(updates)}`;
  }
});
```

---

## LLM-Based Resolution

### Prompt-Based Resolution

```typescript
import { openai } from '@ai-sdk/openai';
import { generateText } from 'ai';

async function resolveReferenceWithPrompt(
  reference: string,
  conversation: Message[],
  entities: Entity[]
): Promise<{ type: string; id: number } | null> {
  const prompt = `
You are a reference resolution assistant.

Recent conversation:
${conversation.slice(-5).map(m => `${m.role}: ${m.content}`).join('\n')}

Available entities in memory:
${entities.map(e => `- ${e.type} ${e.id}: ${e.label}`).join('\n')}

User said: "${reference}"

What entity does "${reference}" refer to?
Respond in format: type:id (e.g., "page:42")
If ambiguous, respond with the most recent matching entity.
If no match, respond with "NONE".
  `.trim();

  const result = await generateText({
    model: openai('gpt-4o-mini'),
    prompt
  });

  const response = result.text.trim();
  
  if (response === 'NONE') {
    return null;
  }

  // Parse response "type:id"
  const match = response.match(/^(\w+):(\d+)$/);
  if (match) {
    return {
      type: match[1],
      id: parseInt(match[2], 10)
    };
  }

  return null;
}
```

### Structured Output Resolution

```typescript
import { generateObject } from 'ai';
import { z } from 'zod';

const ResolutionSchema = z.object({
  type: z.string().describe('Entity type (page, entry, user, etc.)'),
  id: z.number().describe('Entity ID'),
  confidence: z.number().min(0).max(1).describe('Confidence score 0-1'),
  reasoning: z.string().optional().describe('Why this entity was chosen')
});

async function resolveWithStructuredOutput(
  reference: string,
  context: {
    conversation: Message[];
    workingMemory: Entity[];
  }
): Promise<z.infer<typeof ResolutionSchema> | null> {
  try {
    const { object } = await generateObject({
      model: openai('gpt-4o-mini'),
      schema: ResolutionSchema,
      prompt: `
Resolve the reference "${reference}" to an entity.

Conversation:
${context.conversation.slice(-5).map(m => `${m.role}: ${m.content}`).join('\n')}

Available entities:
${context.workingMemory.map(e => `- ${e.type} ${e.id}: ${e.label} (timestamp: ${e.timestamp})`).join('\n')}

Rules:
- "this" prefers most recent entity
- "that" prefers second most recent
- Match entity type from reference phrase
- Confidence < 0.5 if ambiguous
      `.trim()
    });

    return object;
  } catch (error) {
    console.error('LLM resolution failed:', error);
    return null;
  }
}
```

### Hybrid: Heuristics + LLM Fallback

```typescript
class HybridReferenceResolver {
  private simpleResolver: ReferenceResolver;

  constructor(workingMemory: Entity[]) {
    this.simpleResolver = new ReferenceResolver(workingMemory, {
      strategy: 'type',
      fallbackToRecent: true
    });
  }

  async resolve(
    reference: string,
    conversation: Message[]
  ): Promise<Entity | null> {
    // Try simple heuristics first (fast, free)
    const simple = this.simpleResolver.resolve(reference);
    
    // If high confidence, return immediately
    if (simple && this.isHighConfidence(reference, simple)) {
      return simple;
    }

    // Fallback to LLM (slow, costs tokens)
    const llmResult = await resolveWithStructuredOutput(reference, {
      conversation,
      workingMemory: this.simpleResolver.getRecent(10)
    });

    if (llmResult && llmResult.confidence >= 0.5) {
      // Find entity in working memory
      return this.simpleResolver
        .getByType(llmResult.type)
        .find(e => e.id === llmResult.id) || null;
    }

    // Return simple result as last resort
    return simple;
  }

  private isHighConfidence(reference: string, entity: Entity): boolean {
    // High confidence if reference explicitly matches entity type
    const ref = reference.toLowerCase();
    return ref.includes(entity.type);
  }
}
```

---

## Production Patterns

### Pattern 1: Reference Resolution Middleware

```typescript
import { tool } from 'ai';

function createToolWithReferenceResolution<P extends z.ZodType>(
  definition: {
    description: string;
    parameters: P;
    execute: (params: z.infer<P>, context: AgentContext) => Promise<unknown>;
    referenceParams?: string[];  // Which params accept references
  }
) {
  return tool({
    description: definition.description,
    parameters: definition.parameters,
    execute: async (params, context) => {
      // Resolve references before execution
      if (definition.referenceParams) {
        const resolver = new ReferenceResolver(
          context.workingMemory.getAll()
        );

        for (const paramName of definition.referenceParams) {
          const value = params[paramName];
          
          if (typeof value === 'string' && !/^\d+$/.test(value)) {
            // Looks like a reference, not a direct ID
            const entity = resolver.resolve(value);
            
            if (entity) {
              params[paramName] = entity.id;  // Replace with resolved ID
            }
          }
        }
      }

      // Execute tool with resolved params
      return await definition.execute(params, context);
    }
  });
}

// Usage
const cms_updatePage = createToolWithReferenceResolution({
  description: 'Update page',
  parameters: z.object({
    pageId: z.union([z.number(), z.string()]),
    title: z.string()
  }),
  referenceParams: ['pageId'],  // Resolve pageId if it's a reference
  execute: async ({ pageId, title }) => {
    // pageId is now guaranteed to be a number
    await db.pages.update({ where: { id: pageId }, data: { title } });
    return `Updated page ${pageId}`;
  }
});
```

### Pattern 2: Explicit Resolution Tool

```typescript
const resolveReference = tool({
  description: 'Resolve a reference like "this page" to an entity ID',
  parameters: z.object({
    reference: z.string().describe('Reference phrase to resolve')
  }),
  execute: async ({ reference }, context) => {
    const resolver = new ReferenceResolver(
      context.workingMemory.getAll(),
      { strategy: 'type' }
    );

    const entity = resolver.resolve(reference);
    
    if (!entity) {
      return `Could not resolve "${reference}"`;
    }

    return JSON.stringify({
      type: entity.type,
      id: entity.id,
      label: entity.label
    });
  }
});

// Agent can now explicitly resolve references when needed
```

### Pattern 3: Proactive Disambiguation

```typescript
async function resolveWithDisambiguation(
  reference: string,
  workingMemory: Entity[]
): Promise<Entity | null> {
  const resolver = new ReferenceResolver(workingMemory);
  const type = resolver['extractType'](reference);  // Access private method
  
  // Get all candidates
  const candidates = workingMemory
    .filter(e => !type || e.type === type)
    .sort((a, b) => b.timestamp - a.timestamp)
    .slice(0, 3);  // Top 3 candidates

  if (candidates.length === 0) {
    return null;
  }

  if (candidates.length === 1) {
    return candidates[0];  // Unambiguous
  }

  // Multiple candidates → Ask user to clarify
  const clarificationPrompt = `
Multiple ${type || 'entities'} match "${reference}":
${candidates.map((e, i) => `${i + 1}. ${e.type} ${e.id}: ${e.label}`).join('\n')}

Which one did you mean? (respond with number)
  `.trim();

  // In practice, this would pause execution and wait for user input
  console.log(clarificationPrompt);
  
  // For now, default to most recent
  return candidates[0];
}
```

---

## Trade-offs and Best Practices

### Pros ✅
- **Natural Interaction**: Users can say "this" instead of IDs
- **Context Awareness**: Agent understands implicit references
- **Reduced Verbosity**: No need to repeat entity IDs
- **Better UX**: More human-like conversation

### Cons ❌
- **Ambiguity**: References can be unclear
- **Error Propagation**: Wrong resolution breaks subsequent steps
- **Complexity**: Harder to debug than explicit IDs
- **Context Dependency**: Requires working memory

### Best Practices

1. **Prefer explicit IDs when possible**
   ```typescript
   // ✅ GOOD: Explicit ID (unambiguous)
   cms_updatePage({ pageId: 42, title: 'Welcome' })

   // ⚠️ OK: Reference (convenient but ambiguous)
   cms_updatePage({ pageId: 'this page', title: 'Welcome' })
   ```

2. **Always validate resolved entities**
   ```typescript
   const entity = resolver.resolve(reference);
   if (!entity) {
     return `Could not resolve "${reference}". Please specify the entity ID.`;
   }
   if (entity.type !== 'page') {
     return `"${reference}" resolved to ${entity.type} ${entity.id}, not a page.`;
   }
   ```

3. **Use hybrid strategy (fast path + LLM fallback)**
   ```typescript
   // Try simple heuristics first (0.2ms)
   const simple = simpleResolver.resolve(reference);
   if (simple && highConfidence(simple)) {
     return simple;
   }

   // Fallback to LLM (50-200ms)
   return await llmResolver.resolve(reference);
   ```

4. **Log resolution decisions**
   ```typescript
   console.log({
     reference,
     resolved: entity,
     strategy: 'recency',
     confidence: 0.9,
     candidates: allCandidates.length
   });
   ```

5. **Support both references and explicit IDs**
   ```typescript
   parameters: z.object({
     pageId: z.union([
       z.number(),                    // Explicit ID
       z.string().regex(/^\d+$/),     // String ID
       z.string()                      // Reference
     ])
   })
   ```

---

## References

### Research Papers

1. **Improving LLMs' Learning for Coreference Resolution** (2025)  
   [https://aclanthology.org/2025.sigdial-1.25.pdf](https://aclanthology.org/2025.sigdial-1.25.pdf)  
   - LLM-based coreference resolution
   - QA template and document template methods
   - 87.1 F1-score on CoNLL-2012 (state-of-the-art)

2. **Low-Hallucination and Efficient Coreference Resolution** (2025)  
   [https://aclanthology.org/2025.findings-emnlp.934.pdf](https://aclanthology.org/2025.findings-emnlp.934.pdf)  
   - Constrained decoding for coreference
   - 95.1 F1-score with 8B parameter model
   - Reduces hallucination in LLM-based resolution

3. **Bridging Context Gaps: Leveraging Coreference** (ICLR 2025)  
   [https://proceedings.iclr.cc/paper/2025/](https://proceedings.iclr.cc/paper/2025/)  
   - LQCA framework for long-context resolution
   - +3.61% improvement on GPT-4
   - Iterative document generation method

4. **Incorporating Context and External Knowledge for Pronoun Coreference Resolution** (2019)  
   [http://arxiv.org/pdf/1905.10238.pdf](http://arxiv.org/pdf/1905.10238.pdf)  
   - Two-layer model with knowledge attention
   - 87.7 F1-score on pronoun resolution
   - External knowledge integration

5. **Coreference Resolution and Entity Linking** (Stanford NLP, Jurafsky & Martin)  
   [https://web.stanford.edu/~jurafsky/slp3/23.pdf](https://web.stanford.edu/~jurafsky/slp3/23.pdf)  
   - Comprehensive NLP textbook chapter
   - Linguistic foundations of coreference
   - Agreement constraints (number, gender)

### Production Systems

6. **Findings of the Fourth Shared Task on Multilingual Coreference Resolution** (2025)  
   [https://arxiv.org/html/2509.17796](https://arxiv.org/html/2509.17796)  
   - CoNLL 2025 shared task results
   - LLM vs traditional systems comparison
   - 22 datasets in 17 languages

7. **How LLMs Understand Pronouns: AI Reference Resolution Explained** (2025)  
   [https://nat.io/blog/reference-resolution-llms](https://nat.io/blog/reference-resolution-llms)  
   - Practical guide to LLM-based resolution
   - Real-world examples and patterns
   - Production implementation tips

8. **Coreference Resolution with LLMs** (Exploring AI, 2024)  
   [https://unimatrixz.com/topics/ai-text/nlp-tasks/core-nlp-tasks/coreference-resolution/](https://unimatrixz.com/topics/ai-text/nlp-tasks/core-nlp-tasks/coreference-resolution/)  
   - Rule-based vs ML-based approaches
   - Hybrid systems
   - Application to QA, MT, summarization

### Linguistic Resources

9. **Anaphora Resolution** (Wikipedia)  
   [https://en.wikipedia.org/wiki/Anaphor_resolution](https://en.wikipedia.org/wiki/Anaphor_resolution)  
   - Linguistic terminology
   - Types of anaphora (pronominal, definite, zero)
   - Centering theory

10. **Resolution of English Event Pronouns Based on Machine Learning** (2022)  
    [https://onlinelibrary.wiley.com/doi/10.1155/2022/8560873](https://onlinelibrary.wiley.com/doi/10.1155/2022/8560873)  
    - Event coreference (not just entities)
    - End-to-end neural network approach
    - KBP dataset evaluation

### Implementation Examples

11. **What is Coreference Resolution?** (ThinkStack AI, 2025)  
    [https://www.thinkstack.ai/glossary/coreference-resolution/](https://www.thinkstack.ai/glossary/coreference-resolution/)  
    - Practical implementation guide
    - Preprocessing, mention detection, clustering
    - Production challenges and solutions

12. **NLP Task: Coreference Resolution** (Natural Language Processing Overview)  
    [https://en.wikipedia.org/wiki/Outline_of_natural_language_processing](https://en.wikipedia.org/wiki/Outline_of_natural_language_processing)  
    - Component processes
    - Discourse analysis
    - Related NLP tasks

---

**Next Topic**: [4.1.5 Universal Working Memory Implementation](./4.1.5-universal-working-memory.md)

**Related Topics**:
- [4.1.1 Working Memory Concept](./4.1.1-working-memory-concept.md)
- [4.1.2 Entity Extraction](./4.1.2-entity-extraction.md)
- [4.1.3 Sliding Window](./4.1.3-sliding-window.md)
